// Copyright Â© 2022, SAS Institute Inc., Cary, NC, USA. All Rights Reserved.
// Licensed under SAS Code Extension Terms, available at Code_Extension_Agreement.pdf

/**
 * Compute
 * The Compute API defines the replacement for the application servers that were used for SAS 9. The Compute API enables clients to perform the following tasks: <UL> <LI>Submit and execute SAS code. <LI>Obtain the SAS log or listing information from executed SAS code. <LI>View output that is generated by a SAS code submission. <LI>Access SAS data sets that are created by a SAS code submission. <LI>Access SAS filerefs that are created by a SAS code submission. <LI>Access SAS variables that are defined and used in a SAS code submission. <LI>Retrieve information about engines that are available in a session. </UL>
 *
 * The version of the OpenAPI document: 11
 * Contact: devex@sas.com
 *
 * NOTE: This class is auto generated by OpenAPI
 * Do not edit the class manually.
 */

/* tslint:disable */
/* eslint-disable */

import { Configuration } from "./configuration";
import globalAxios, { AxiosResponse, AxiosRequestConfig } from "axios";
import { URL, URLSearchParams } from "url";

/**
 *
 * @export
 */
export const DUMMY_BASE_URL = "https://example.com";

/**
 *
 * @export
 * @interface RequestArgs
 */
export interface RequestArgs {
  url: string;
  options: AxiosRequestConfig;
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name: "RequiredError" = "RequiredError";
  constructor(public field: string, msg?: string) {
    super(msg);
  }
}

/**
 *
 * @throws {RequiredError}
 * @export
 */
export const assertParamExists = function (
  functionName: string,
  paramName: string,
  paramValue: unknown
) {
  if (paramValue === null || paramValue === undefined) {
    throw new RequiredError(
      paramName,
      `Required parameter ${paramName} was null or undefined when calling ${functionName}.`
    );
  }
};

function setFlattenedQueryParams(
  urlSearchParams: URLSearchParams,
  parameter: any,
  key: string = ""
): void {
  if (typeof parameter === "object") {
    if (Array.isArray(parameter)) {
      (parameter as any[]).forEach((item) =>
        setFlattenedQueryParams(urlSearchParams, item, key)
      );
    } else {
      Object.keys(parameter).forEach((currentKey) =>
        setFlattenedQueryParams(
          urlSearchParams,
          parameter[currentKey],
          `${key}${key !== "" ? "." : ""}${currentKey}`
        )
      );
    }
  } else {
    if (urlSearchParams.has(key)) {
      urlSearchParams.append(key, parameter);
    } else {
      urlSearchParams.set(key, parameter);
    }
  }
}

/**
 *
 * @export
 */
export const setSearchParams = function (url: URL, ...objects: any[]) {
  const searchParams = new URLSearchParams(url.search);
  setFlattenedQueryParams(searchParams, objects);
  url.search = searchParams.toString();
};

/**
 *
 * @export
 */
export const serializeDataIfNeeded = function (
  value: any,
  requestOptions: any,
  configuration?: Configuration
) {
  const nonString = typeof value !== "string";
  const needsSerialization =
    nonString && configuration && configuration.isJsonMime
      ? configuration.isJsonMime(requestOptions.headers["Content-Type"])
      : nonString;
  return needsSerialization
    ? JSON.stringify(value !== undefined ? value : {})
    : value || "";
};

/**
 *
 * @export
 */
export const toPathString = function (url: URL) {
  return url.pathname + url.search + url.hash;
};

/**
 *
 * @export
 */
export const createRequestFunction = function <T>(
  axiosArgs: RequestArgs,
  configuration?: Configuration
) {
  const axiosRequestArgs = {
    ...axiosArgs.options,
    url: (configuration?.basePath || "") + axiosArgs.url,
  };
  if (axiosRequestArgs.headers && configuration?.accessToken)
    axiosRequestArgs.headers["Authorization"] =
      "Bearer " + configuration?.accessToken;
  console.log({ axiosRequestArgs });
  return globalAxios.request<T, AxiosResponse<T>>(axiosRequestArgs);
};
