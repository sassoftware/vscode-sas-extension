// Copyright Â© 2022, SAS Institute Inc., Cary, NC, USA. All Rights Reserved.
// Licensed under SAS Code Extension Terms, available at Code_Extension_Agreement.pdf

/**
 * Compute
 * The Compute API defines the replacement for the application servers that were used for SAS 9. The Compute API enables clients to perform the following tasks: <UL> <LI>Submit and execute SAS code. <LI>Obtain the SAS log or listing information from executed SAS code. <LI>View output that is generated by a SAS code submission. <LI>Access SAS data sets that are created by a SAS code submission. <LI>Access SAS filerefs that are created by a SAS code submission. <LI>Access SAS variables that are defined and used in a SAS code submission. <LI>Retrieve information about engines that are available in a session. </UL>
 *
 * The version of the OpenAPI document: 11
 * Contact: devex@sas.com
 *
 * NOTE: This class is auto generated by OpenAPI
 * Do not edit the class manually.
 */

/* tslint:disable */
/* eslint-disable */

import { Configuration } from "./configuration";
import { AxiosResponse, AxiosRequestConfig } from "axios";
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from "url";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  RequestArgs,
  assertParamExists,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";

/**
 * The list of links to top-level resources and operations available from the root of the API.
 * @export
 * @interface Api
 */
export interface Api {
  /**
   * The version number of the API representation. This is version 1.
   * @type {number}
   * @memberof Api
   */
  version: number;
  /**
   * The API\'s top-level links.
   * @type {Array<Link>}
   * @memberof Api
   */
  links: Array<Link>;
}
/**
 * This is a base schema used to define paginated collections of resources. This base schema is extended by other schemas in APIs by adding an \'items\' array property. These extensions define the application/vnd.sas.collection media type (version 2)
 * @export
 * @interface BaseCollection2
 */
export interface BaseCollection2 {
  /**
   * The name of the collection.
   * @type {string}
   * @memberof BaseCollection2
   */
  name?: string;
  /**
   * The zero-based index of the first item in the collection.
   * @type {number}
   * @memberof BaseCollection2
   */
  start?: number;
  /**
   * The number of items that were requested for the collection.
   * @type {number}
   * @memberof BaseCollection2
   */
  limit?: number;
  /**
   * If populated indicates the number of items in the collection.
   * @type {number}
   * @memberof BaseCollection2
   */
  count?: number;
  /**
   * A space-delimited list of media types from which an `Accept` header may be constructed.
   * @type {string}
   * @memberof BaseCollection2
   */
  accept?: string;
  /**
   * The links that apply to the collection.
   * @type {Array<Link>}
   * @memberof BaseCollection2
   */
  links?: Array<Link>;
  /**
   * The version number of the collection representation. This representation is version 2.
   * @type {number}
   * @memberof BaseCollection2
   */
  version?: number;
}
/**
 * Describes a column from a table.
 * @export
 * @interface Column
 */
export interface Column {
  /**
   * Specifies the version number of this representation schema. This is version 1.
   * @type {number}
   * @memberof Column
   */
  version?: number;
  /**
   * Specifies the identifier for this column.
   * @type {string}
   * @memberof Column
   */
  id?: string;
  /**
   * Specifies the name for this column.
   * @type {string}
   * @memberof Column
   */
  name?: string;
  /**
   * Specifies the numerical index for this column. This is a zero-based index.
   * @type {number}
   * @memberof Column
   */
  index?: number;
  /**
   * Specifies the label for this column. The label is optional.
   * @type {string}
   * @memberof Column
   */
  label?: string;
  /**
   * Specifies the length of the data in this column.
   * @type {number}
   * @memberof Column
   */
  length?: number;
  /**
   * Specifies the data type of the column.
   * @type {string}
   * @memberof Column
   */
  type?: string;
  /**
   *
   * @type {ColumnSimpleFormat}
   * @memberof Column
   */
  format?: ColumnSimpleFormat;
  /**
   *
   * @type {ColumnSimpleFormat}
   * @memberof Column
   */
  informat?: ColumnSimpleFormat;
}
/**
 * Provides a paginated collection of table columns.
 * @export
 * @interface ColumnCollection
 */
export interface ColumnCollection {
  /**
   * The name of the collection.
   * @type {string}
   * @memberof ColumnCollection
   */
  name?: string;
  /**
   * The zero-based index of the first item in the collection.
   * @type {number}
   * @memberof ColumnCollection
   */
  start?: number;
  /**
   * The number of items that were requested for the collection.
   * @type {number}
   * @memberof ColumnCollection
   */
  limit?: number;
  /**
   * If populated indicates the number of items in the collection.
   * @type {number}
   * @memberof ColumnCollection
   */
  count?: number;
  /**
   * A space-delimited list of media types from which an `Accept` header may be constructed.
   * @type {string}
   * @memberof ColumnCollection
   */
  accept?: string;
  /**
   * The links that apply to the collection.
   * @type {Array<Link>}
   * @memberof ColumnCollection
   */
  links?: Array<Link>;
  /**
   * The version number of the collection representation. This representation is version 2.
   * @type {number}
   * @memberof ColumnCollection
   */
  version?: number;
  /**
   * Specifies an array that contains column resources.
   * @type {Array<Column>}
   * @memberof ColumnCollection
   */
  items: Array<Column>;
}
/**
 *
 * @export
 * @interface ColumnCollectionAllOf
 */
export interface ColumnCollectionAllOf {
  /**
   * Specifies an array that contains column resources.
   * @type {Array<Column>}
   * @memberof ColumnCollectionAllOf
   */
  items: Array<Column>;
}
/**
 * Specifies the format to apply to a column when retrieving data from a cell.
 * @export
 * @interface ColumnFormatting
 */
export interface ColumnFormatting {
  /**
   * Specifies the name of a column.
   * @type {string}
   * @memberof ColumnFormatting
   */
  name?: string;
  /**
   * Specifies the format to use when retrieving data from a column.
   * @type {string}
   * @memberof ColumnFormatting
   */
  format?: string;
}
/**
 * Specifies the format to use for values in a column.
 * @export
 * @interface ColumnSimpleFormat
 */
export interface ColumnSimpleFormat {
  /**
   * Specifies the number of digits to the right of the decimal point.
   * @type {number}
   * @memberof ColumnSimpleFormat
   */
  decimals?: number;
  /**
   * Specifies the length of a formatted value.
   * @type {number}
   * @memberof ColumnSimpleFormat
   */
  length?: number;
  /**
   * Specifies the qualified name of the format or informat in the form of: <$>name<w>.<d>
   * @type {string}
   * @memberof ColumnSimpleFormat
   */
  name?: string;
}
/**
 * Provides a request to generate a column collection.
 * @export
 * @interface ColumnsRequest
 */
export interface ColumnsRequest {
  /**
   * Specifies the version number of this representation schema. This is version 2.
   * @type {number}
   * @memberof ColumnsRequest
   */
  version?: number;
  /**
   * Specifies the identifier for a column.
   * @type {string}
   * @memberof ColumnsRequest
   */
  id?: string;
  /**
   * Specifies an array of strings that indicate the columns to include in a row set. If you do not specify a value, then all columns are returned. The order of the column names in the list indicates the order of the cells of the row set.
   * @type {Array<string>}
   * @memberof ColumnsRequest
   */
  includeColumns?: Array<string>;
  /**
   *
   * @type {FileProtection}
   * @memberof ColumnsRequest
   */
  fileProtection?: FileProtection;
  /**
   * Specifies the encoding for the password values in the fileProtection structure. If the value is \"base64\", then the password values in the fileProtection structure should be encoded by converting the text to UTF-8 and base64-encoding the result. If no value is provided, then the password values of the fileProtection structure are expected to be clear text.
   * @type {string}
   * @memberof ColumnsRequest
   */
  fileProtectionEncoding?: string;
}
/**
 * Provides a concatenation of libraries.
 * @export
 * @interface Concatenation
 */
export interface Concatenation {
  /**
   * Specifies the name of the engine that is used for this member of the concatenation.
   * @type {string}
   * @memberof Concatenation
   */
  engineName?: string;
  /**
   * Specifies the name of the file format that is used for this member of the concatenation.
   * @type {string}
   * @memberof Concatenation
   */
  fileFormat?: string;
  /**
   * Specifies the physical name that is used for this member of the concatenation.
   * @type {string}
   * @memberof Concatenation
   */
  physicalName?: string;
}
/**
 * Provides information about the context that is stored for a service.
 * @export
 * @interface Context
 */
export interface Context {
  /**
   * Specifies the version number of this representation schema. This is version 4.
   * @type {number}
   * @memberof Context
   */
  version?: number;
  /**
   * Specifies the Compute context definition ID.
   * @type {string}
   * @memberof Context
   */
  id: string;
  /**
   * Specifies the localized context name.
   * @type {string}
   * @memberof Context
   */
  name: string;
  /**
   * Specifies the localized description.
   * @type {string}
   * @memberof Context
   */
  description?: string;
  /**
   *
   * @type {ContextLaunchContext}
   * @memberof Context
   */
  launchContext: ContextLaunchContext;
  /**
   * Specifies the type of launcher to use when launching SAS Compute Servers. The only value currently supported is <b>service</b>, which refers to the Launcher service.
   * @type {string}
   * @memberof Context
   */
  launchType: string;
  /**
   * Specifies the service-defined attributes that were set when this context was created.
   * @type {object}
   * @memberof Context
   */
  attributes?: object;
  /**
   *
   * @type {Environment}
   * @memberof Context
   */
  environment?: Environment;
  /**
   * Specifies optional information that overrides mappings of file extensions to media types in the sessions that was launched for this context. The session attempts to use file extensions to determine the media type of the files that are returned. Standard IANA type mappings are used. To override the default behavior of the server, specify a mapping from a file extension to a media type name. That media type is then used for that file extension.
   * @type {{ [key: string]: string; }}
   * @memberof Context
   */
  mediaTypeMap?: { [key: string]: string };
  /**
   * Specifies the user-ID that created the context definition.
   * @type {string}
   * @memberof Context
   */
  createdBy?: string;
  /**
   * Specifies the user ID that last updated the context definition.
   * @type {string}
   * @memberof Context
   */
  modifiedBy?: string;
  /**
   * Specifies the timestamp when the context was created.
   * @type {string}
   * @memberof Context
   */
  creationTimeStamp?: string;
  /**
   * Specifies the timestamp when the context was last updated.
   * @type {string}
   * @memberof Context
   */
  modifiedTimeStamp?: string;
  /**
   * Specifies links that apply to the context.
   * @type {Array<Link>}
   * @memberof Context
   */
  links?: Array<Link>;
  /**
   * Specifies the resources that have been configured for this context.
   * @type {Array<Resource>}
   * @memberof Context
   */
  resources?: Array<Resource>;
  /**
   * Specifies the name of the workload queue where Compute servers configured from this context should run. If workload queues are not supported, this specification will be ignored. The value of the queue name is limited to 250 characters.
   * @type {string}
   * @memberof Context
   */
  queueName?: string;
}
/**
 * Provides information about the Launch context that is used by the Compute service.
 * @export
 * @interface ContextLaunchContext
 */
export interface ContextLaunchContext {
  /**
   * Specifies the command that launches the server for this context. If this value is not set, the service uses the default command that is determined at runtime.
   * @type {string}
   * @memberof ContextLaunchContext
   */
  command?: string;
  /**
   * Specifies the context name from the launcher context. If the launchType is service, then contextId or contextName is required.
   * @type {string}
   * @memberof ContextLaunchContext
   */
  contextName?: string;
  /**
   * Specifies the context ID from the launcher context. If the launchType is service, then contextId or contextName is required.
   * @type {string}
   * @memberof ContextLaunchContext
   */
  contextId?: string;
}
/**
 * Enables the creation of a new Compute context.
 * @export
 * @interface ContextRequest
 */
export interface ContextRequest {
  /**
   * Specifies the version number of this representation schema. This is version 3.
   * @type {number}
   * @memberof ContextRequest
   */
  version?: number;
  /**
   * Specifies the context name. The value of the name is limited to 100 characters. The value must be unique.
   * @type {string}
   * @memberof ContextRequest
   */
  name: string;
  /**
   * Specifies a localized description. The value of description is limited to 1000 characters.
   * @type {string}
   * @memberof ContextRequest
   */
  description?: string;
  /**
   *
   * @type {ContextLaunchContext}
   * @memberof ContextRequest
   */
  launchContext: ContextLaunchContext;
  /**
   * Specifies the type of launcher to use when launching SAS Compute Servers. The only value currently supported is <b>service</b>, which refers to the Launcher service.
   * @type {string}
   * @memberof ContextRequest
   */
  launchType: string;
  /**
   * Specifies the attributes that control the behavior of sessions, based on this context. See the example for details.
   * @type {object}
   * @memberof ContextRequest
   */
  attributes?: object;
  /**
   *
   * @type {Environment}
   * @memberof ContextRequest
   */
  environment?: Environment;
  /**
   * Specifies the list of users who are allowed to request sessions using the specified context.
   * @type {Array<string>}
   * @memberof ContextRequest
   */
  authorizedUsers?: Array<string>;
  /**
   * Specifies the list of groups whose memes are allowed to request sessions using the specified context.
   * @type {Array<string>}
   * @memberof ContextRequest
   */
  authorizedGroups?: Array<string>;
  /**
   * Specifies whether all authenticated users are allowed to request sessions using the specified context. If <b>true</b>, then <b>authorizedUsers</b> and <b>authorizedGroups</b> are ignored.
   * @type {boolean}
   * @memberof ContextRequest
   */
  authorizeAllAuthenticatedUsers?: boolean;
  /**
   * Specifies whether the guest user is allowed to request sessions using the specified context.
   * @type {boolean}
   * @memberof ContextRequest
   */
  facilitateGuest?: boolean;
  /**
   * Specifies optional information that overrides mappings of file extensions to media types in sessions that are launched for this context. The session attempts to use file extensions to determine the media type of files that are returned. Standard IANA type mappings are used. To override the default behavior of the server, specify a mapping from a file extension to a media type name. That media type is then used for that file extension.
   * @type {{ [key: string]: string; }}
   * @memberof ContextRequest
   */
  mediaTypeMap?: { [key: string]: string };
  /**
   * Specifies the resources that have been requested to be added to this context.
   * @type {Array<Resource>}
   * @memberof ContextRequest
   */
  resources?: Array<Resource>;
  /**
   * Specifies the name of the workload queue where Compute servers configured from this context should run. If workload queues are not supported, this specification will be ignored. The value of the queue name is limited to 250 characters.
   * @type {string}
   * @memberof ContextRequest
   */
  queueName?: string;
}
/**
 * Provides summary information about the context that is stored for a service.
 * @export
 * @interface ContextSummary
 */
export interface ContextSummary {
  /**
   * Specifies the version number of this representation schema. This is version 2.
   * @type {number}
   * @memberof ContextSummary
   */
  version?: number;
  /**
   * Specifies the definition ID of the Compute context summary.
   * @type {string}
   * @memberof ContextSummary
   */
  id?: string;
  /**
   * Specifies the localized context name.
   * @type {string}
   * @memberof ContextSummary
   */
  name?: string;
  /**
   * Specifies the user-ID that created the context definition.
   * @type {string}
   * @memberof ContextSummary
   */
  createdBy?: string;
  /**
   * Specifies the links that apply to the context.
   * @type {Array<Link>}
   * @memberof ContextSummary
   */
  links?: Array<Link>;
}
/**
 * Provides a paginated collection of context summaries.
 * @export
 * @interface ContextSummaryCollection
 */
export interface ContextSummaryCollection {
  /**
   * The name of the collection.
   * @type {string}
   * @memberof ContextSummaryCollection
   */
  name?: string;
  /**
   * The zero-based index of the first item in the collection.
   * @type {number}
   * @memberof ContextSummaryCollection
   */
  start?: number;
  /**
   * The number of items that were requested for the collection.
   * @type {number}
   * @memberof ContextSummaryCollection
   */
  limit?: number;
  /**
   * If populated indicates the number of items in the collection.
   * @type {number}
   * @memberof ContextSummaryCollection
   */
  count?: number;
  /**
   * A space-delimited list of media types from which an `Accept` header may be constructed.
   * @type {string}
   * @memberof ContextSummaryCollection
   */
  accept?: string;
  /**
   * The links that apply to the collection.
   * @type {Array<Link>}
   * @memberof ContextSummaryCollection
   */
  links?: Array<Link>;
  /**
   * The version number of the collection representation. This representation is version 2.
   * @type {number}
   * @memberof ContextSummaryCollection
   */
  version?: number;
  /**
   * Specifies the array that contains context summaries.
   * @type {Array<ContextSummary>}
   * @memberof ContextSummaryCollection
   */
  items: Array<ContextSummary>;
}
/**
 *
 * @export
 * @interface ContextSummaryCollectionAllOf
 */
export interface ContextSummaryCollectionAllOf {
  /**
   * Specifies the array that contains context summaries.
   * @type {Array<ContextSummary>}
   * @memberof ContextSummaryCollectionAllOf
   */
  items: Array<ContextSummary>;
}
/**
 * Describes a member of a directory-based fileref object.
 * @export
 * @interface DirMember
 */
export interface DirMember {
  /**
   * Specifies a Compute context definition id.
   * @type {string}
   * @memberof DirMember
   */
  id?: string;
  /**
   * Links that apply to this directory member
   * @type {Array<Link>}
   * @memberof DirMember
   */
  links?: Array<Link>;
}
/**
 * Provides a collection that contains the members of a directory-based fileref object.
 * @export
 * @interface DirectoryCollection
 */
export interface DirectoryCollection {
  /**
   * The name of the collection.
   * @type {string}
   * @memberof DirectoryCollection
   */
  name?: string;
  /**
   * The zero-based index of the first item in the collection.
   * @type {number}
   * @memberof DirectoryCollection
   */
  start?: number;
  /**
   * The number of items that were requested for the collection.
   * @type {number}
   * @memberof DirectoryCollection
   */
  limit?: number;
  /**
   * If populated indicates the number of items in the collection.
   * @type {number}
   * @memberof DirectoryCollection
   */
  count?: number;
  /**
   * A space-delimited list of media types from which an `Accept` header may be constructed.
   * @type {string}
   * @memberof DirectoryCollection
   */
  accept?: string;
  /**
   * The links that apply to the collection.
   * @type {Array<Link>}
   * @memberof DirectoryCollection
   */
  links?: Array<Link>;
  /**
   * The version number of the collection representation. This representation is version 2.
   * @type {number}
   * @memberof DirectoryCollection
   */
  version?: number;
  /**
   * Specifies an array that contains a listing of members of a directory fileref.
   * @type {Array<DirMember>}
   * @memberof DirectoryCollection
   */
  items: Array<DirMember>;
}
/**
 *
 * @export
 * @interface DirectoryCollectionAllOf
 */
export interface DirectoryCollectionAllOf {
  /**
   * Specifies an array that contains a listing of members of a directory fileref.
   * @type {Array<DirMember>}
   * @memberof DirectoryCollectionAllOf
   */
  items: Array<DirMember>;
}
/**
 * Provides a description of a SAS LIBNAME engine.
 * @export
 * @interface Engine
 */
export interface Engine {
  /**
   * Specifies the version number of this representation schema. This is version 1.
   * @type {number}
   * @memberof Engine
   */
  version?: number;
  /**
   * Specifies the unique name of this engine.
   * @type {string}
   * @memberof Engine
   */
  name?: string;
  /**
   * Specifies the label for this engine. This value maps to the nickname for the engine in the Compute session.
   * @type {string}
   * @memberof Engine
   */
  label?: string;
  /**
   * Specifies the engine description. In the Compute session, this is the short legal name of the engine.
   * @type {string}
   * @memberof Engine
   */
  description?: string;
  /**
   * Specifies the providerId for this service. In a Compute session, this value is compute.
   * @type {string}
   * @memberof Engine
   */
  providerId?: string;
  /**
   * Specifies the identifier of the data source that provides the engine. In a Compute session, this is the context id.
   * @type {string}
   * @memberof Engine
   */
  dataSourceId?: string;
  /**
   * Specifies whether the engine is licensed.
   * @type {boolean}
   * @memberof Engine
   */
  licensed?: boolean;
  /**
   * Specifies links that apply to this engine.
   * @type {Array<Link>}
   * @memberof Engine
   */
  links?: Array<Link>;
}
/**
 * Provides a paginated collection of SAS engine objects.
 * @export
 * @interface EngineCollection
 */
export interface EngineCollection {
  /**
   * The name of the collection.
   * @type {string}
   * @memberof EngineCollection
   */
  name?: string;
  /**
   * The zero-based index of the first item in the collection.
   * @type {number}
   * @memberof EngineCollection
   */
  start?: number;
  /**
   * The number of items that were requested for the collection.
   * @type {number}
   * @memberof EngineCollection
   */
  limit?: number;
  /**
   * If populated indicates the number of items in the collection.
   * @type {number}
   * @memberof EngineCollection
   */
  count?: number;
  /**
   * A space-delimited list of media types from which an `Accept` header may be constructed.
   * @type {string}
   * @memberof EngineCollection
   */
  accept?: string;
  /**
   * The links that apply to the collection.
   * @type {Array<Link>}
   * @memberof EngineCollection
   */
  links?: Array<Link>;
  /**
   * The version number of the collection representation. This representation is version 2.
   * @type {number}
   * @memberof EngineCollection
   */
  version?: number;
  /**
   * Specifies an array that contains engine resources.
   * @type {Array<Engine>}
   * @memberof EngineCollection
   */
  items: Array<Engine>;
}
/**
 *
 * @export
 * @interface EngineCollectionAllOf
 */
export interface EngineCollectionAllOf {
  /**
   * Specifies an array that contains engine resources.
   * @type {Array<Engine>}
   * @memberof EngineCollectionAllOf
   */
  items: Array<Engine>;
}
/**
 * Provides the SAS options and initialization code that is used by the Compute service and its sessions.
 * @export
 * @interface Environment
 */
export interface Environment {
  /**
   * Specifies the SAS options to apply to a context.
   * @type {Array<string>}
   * @memberof Environment
   */
  options?: Array<string>;
  /**
   * Specifies the SAS code to execute during session initialization.
   * @type {Array<string>}
   * @memberof Environment
   */
  autoExecLines?: Array<string>;
}
/**
 * The representation of an error.
 * @export
 * @interface Error2
 */
export interface Error2 {
  /**
   * The message for the error.
   * @type {string}
   * @memberof Error2
   */
  message?: string;
  /**
   * The string ID for the error.
   * @type {string}
   * @memberof Error2
   */
  id?: string;
  /**
   * The numeric ID for the error.
   * @type {number}
   * @memberof Error2
   */
  errorCode?: number;
  /**
   * The HTTP status code for the error.
   * @type {number}
   * @memberof Error2
   */
  httpStatusCode: number;
  /**
   * Messages that provide additional details about the cause of the error.
   * @type {Array<string>}
   * @memberof Error2
   */
  details?: Array<string>;
  /**
   * A message that describes how to resolve the error.
   * @type {string}
   * @memberof Error2
   */
  remediation?: string;
  /**
   * Any additional errors that occurred.
   * @type {Array<Error2>}
   * @memberof Error2
   */
  errors?: Array<Error2>;
  /**
   * The links that apply to the error.
   * @type {Array<Link>}
   * @memberof Error2
   */
  links?: Array<Link>;
  /**
   * The version number of the error representation. This representation is version 2.
   * @type {number}
   * @memberof Error2
   */
  version: number;
}
/**
 * Provides properties of a file or directory object.
 * @export
 * @interface FileProperties
 */
export interface FileProperties {
  /**
   * Specifies the version number of this representation schema. This is version 1.
   * @type {number}
   * @memberof FileProperties
   */
  version?: number;
  /**
   * Specifies whether the object references a directory on the system.
   * @type {boolean}
   * @memberof FileProperties
   */
  isDirectory?: boolean;
  /**
   * Specifies whether the file or directory is Read Only.
   * @type {boolean}
   * @memberof FileProperties
   */
  readOnly?: boolean;
  /**
   * Specifies links that apply to this file or directory object.
   * @type {Array<Link>}
   * @memberof FileProperties
   */
  links?: Array<Link>;
  /**
   * Specifies the name of the file or directory.
   * @type {string}
   * @memberof FileProperties
   */
  name?: string;
  /**
   * Specifies the path of the file or directory.
   * @type {string}
   * @memberof FileProperties
   */
  path?: string;
  /**
   * Specifies the size of the file or directory.
   * @type {number}
   * @memberof FileProperties
   */
  size?: number;
  /**
   * Specifies the modification timestamp for this file or directory.
   * @type {string}
   * @memberof FileProperties
   */
  modifiedTimeStamp?: string;
  /**
   * Specifies the creation timestamp for this file or directory. This information is returned only if the file or directory is available.
   * @type {string}
   * @memberof FileProperties
   */
  creationTimeStamp?: string;
}
/**
 * Provides a collection that contains the members of a directory.
 * @export
 * @interface FilePropertiesCollection
 */
export interface FilePropertiesCollection {
  /**
   * The name of the collection.
   * @type {string}
   * @memberof FilePropertiesCollection
   */
  name?: string;
  /**
   * The zero-based index of the first item in the collection.
   * @type {number}
   * @memberof FilePropertiesCollection
   */
  start?: number;
  /**
   * The number of items that were requested for the collection.
   * @type {number}
   * @memberof FilePropertiesCollection
   */
  limit?: number;
  /**
   * If populated indicates the number of items in the collection.
   * @type {number}
   * @memberof FilePropertiesCollection
   */
  count?: number;
  /**
   * A space-delimited list of media types from which an `Accept` header may be constructed.
   * @type {string}
   * @memberof FilePropertiesCollection
   */
  accept?: string;
  /**
   * The links that apply to the collection.
   * @type {Array<Link>}
   * @memberof FilePropertiesCollection
   */
  links?: Array<Link>;
  /**
   * The version number of the collection representation. This representation is version 2.
   * @type {number}
   * @memberof FilePropertiesCollection
   */
  version?: number;
  /**
   * Specifies an array that contains a listing of members of a directory.
   * @type {Array<FileProperties>}
   * @memberof FilePropertiesCollection
   */
  items: Array<FileProperties>;
}
/**
 *
 * @export
 * @interface FilePropertiesCollectionAllOf
 */
export interface FilePropertiesCollectionAllOf {
  /**
   * Specifies an array that contains a listing of members of a directory.
   * @type {Array<FileProperties>}
   * @memberof FilePropertiesCollectionAllOf
   */
  items: Array<FileProperties>;
}
/**
 * Specifies information that you use to access data sets or tables that are protected. Provide password values in the format password-type=password. Possible values for password-type are \"ALTER\", \"PW\", \"READ\", or \"WRITE\". A password value must be a valid eight-character SAS name.
 * @export
 * @interface FileProtection
 */
export interface FileProtection {
  /**
   * Specifies the password that grants Read access to the file that represents the data set.
   * @type {string}
   * @memberof FileProtection
   */
  read?: string;
  /**
   * Specifies the password that grants Alter access to the file that represents the data set.
   * @type {string}
   * @memberof FileProtection
   */
  alter?: string;
  /**
   * Specifies the password that grants Write access to the file that represents the data set.
   * @type {string}
   * @memberof FileProtection
   */
  write?: string;
}
/**
 * Provides properties of a file or directory object.
 * @export
 * @interface FileRequest
 */
export interface FileRequest {
  /**
   * Specifies the name of the file or directory.
   * @type {string}
   * @memberof FileRequest
   */
  name?: string;
  /**
   * Specifies the path of the file or directory.
   * @type {string}
   * @memberof FileRequest
   */
  path?: string;
}
/**
 * An object representing a file
 * @export
 * @interface FileResource
 */
export interface FileResource {
  /**
   * The username of whoever created the resource.
   * @type {string}
   * @memberof FileResource
   */
  createdBy?: string;
  /**
   * The username of whoever last modified the resource.
   * @type {string}
   * @memberof FileResource
   */
  modifiedBy?: string;
  /**
   * The timestamp for when the resource was created.
   * @type {string}
   * @memberof FileResource
   */
  creationTimeStamp?: string;
  /**
   * The timestamp for when the resource was last modified.
   * @type {string}
   * @memberof FileResource
   */
  modifiedTimeStamp?: string;
  /**
   * URI of the object which is either associated or linked with file resource
   * @type {string}
   * @memberof FileResource
   */
  parentUri?: string;
  /**
   * Properties specific to this file. Each property uses a \"key\" : \"value\" format and a comma is used as the separator between properties.
   * @type {{ [key: string]: string; }}
   * @memberof FileResource
   */
  properties?: { [key: string]: string };
  /**
   * Value for Content Disposition header which will be set in response while downloading the file
   * @type {string}
   * @memberof FileResource
   */
  contentDisposition?: string;
  /**
   * Type of the content
   * @type {string}
   * @memberof FileResource
   */
  contentType?: string;
  /**
   * Description of the document
   * @type {string}
   * @memberof FileResource
   */
  description?: string;
  /**
   * Type of the document
   * @type {string}
   * @memberof FileResource
   */
  documentType?: string;
  /**
   * Encoding of the document
   * @type {string}
   * @memberof FileResource
   */
  encoding?: string;
  /**
   * Id of the file resource
   * @type {string}
   * @memberof FileResource
   */
  id?: string;
  /**
   * Links that apply to this object.  Includes \"self\", \"content\", \"patch\", \"update\" and \"delete\"
   * @type {Array<Link>}
   * @memberof FileResource
   */
  links?: Array<Link>;
  /**
   * Name of the document
   * @type {string}
   * @memberof FileResource
   */
  name?: string;
  /**
   * Byte size of the document content
   * @type {number}
   * @memberof FileResource
   */
  size?: number;
}
/**
 *
 * @export
 * @interface FileResourceAllOf
 */
export interface FileResourceAllOf {
  /**
   * URI of the object which is either associated or linked with file resource
   * @type {string}
   * @memberof FileResourceAllOf
   */
  parentUri?: string;
  /**
   * Properties specific to this file. Each property uses a \"key\" : \"value\" format and a comma is used as the separator between properties.
   * @type {{ [key: string]: string; }}
   * @memberof FileResourceAllOf
   */
  properties?: { [key: string]: string };
  /**
   * Value for Content Disposition header which will be set in response while downloading the file
   * @type {string}
   * @memberof FileResourceAllOf
   */
  contentDisposition?: string;
  /**
   * Type of the content
   * @type {string}
   * @memberof FileResourceAllOf
   */
  contentType?: string;
  /**
   * Description of the document
   * @type {string}
   * @memberof FileResourceAllOf
   */
  description?: string;
  /**
   * Type of the document
   * @type {string}
   * @memberof FileResourceAllOf
   */
  documentType?: string;
  /**
   * Encoding of the document
   * @type {string}
   * @memberof FileResourceAllOf
   */
  encoding?: string;
  /**
   * Id of the file resource
   * @type {string}
   * @memberof FileResourceAllOf
   */
  id?: string;
  /**
   * Links that apply to this object.  Includes \"self\", \"content\", \"patch\", \"update\" and \"delete\"
   * @type {Array<Link>}
   * @memberof FileResourceAllOf
   */
  links?: Array<Link>;
  /**
   * Name of the document
   * @type {string}
   * @memberof FileResourceAllOf
   */
  name?: string;
  /**
   * Byte size of the document content
   * @type {number}
   * @memberof FileResourceAllOf
   */
  size?: number;
}
/**
 * Provides a description of a SAS fileref object.
 * @export
 * @interface Fileref
 */
export interface Fileref {
  /**
   * Specifies the version number of this representation schema. This is version 2.
   * @type {number}
   * @memberof Fileref
   */
  version?: number;
  /**
   * Specifies the access method that is used for this fileref. Common values are \"DISK\" and \"TEMP\", but other values  be supported.
   * @type {string}
   * @memberof Fileref
   */
  accessMethod?: string;
  /**
   * Specifies whether the fileref references a directory on the system.
   * @type {boolean}
   * @memberof Fileref
   */
  isDirectory?: boolean;
  /**
   * Specifies links that apply to this fileref.
   * @type {Array<Link>}
   * @memberof Fileref
   */
  links?: Array<Link>;
  /**
   * Specifies the name of fileref resource.
   * @type {string}
   * @memberof Fileref
   */
  name?: string;
  /**
   * Specifies the modification timestamp for this fileref.
   * @type {string}
   * @memberof Fileref
   */
  modifiedTimeStamp?: string;
  /**
   * Specifies the name of the file.
   * @type {string}
   * @memberof Fileref
   */
  fileName?: string;
  /**
   * Specifies the size of the file.
   * @type {number}
   * @memberof Fileref
   */
  fileSize?: number;
  /**
   * Specifies the identifier for this fileref.
   * @type {string}
   * @memberof Fileref
   */
  id?: string;
  /**
   * Specifies the resolved path of the file. Support for this value was added in version 2.
   * @type {string}
   * @memberof Fileref
   */
  filePath?: string;
}
/**
 * Enables you to create a new SAS fileref object.
 * @export
 * @interface FilerefRequest
 */
export interface FilerefRequest {
  /**
   * Specifies the version number of this representation schema. This is version 1.
   * @type {number}
   * @memberof FilerefRequest
   */
  version?: number;
  /**
   * Specifies the name of this fileref.
   * @type {string}
   * @memberof FilerefRequest
   */
  name: string;
  /**
   * Specifies the path to the file or directory that is referenced by this fileref.
   * @type {string}
   * @memberof FilerefRequest
   */
  path: string;
  /**
   * Specifies the access method that is used for this fileref. Common values are \"DISK\" and \"TEMP\", but other values can be supported.
   * @type {string}
   * @memberof FilerefRequest
   */
  accessMethod?: string;
  /**
   * Specifies an options string for the creation of the fileref.
   * @type {string}
   * @memberof FilerefRequest
   */
  options?: string;
}
/**
 * Provides summary information about a SAS fileref.
 * @export
 * @interface FilerefSummary
 */
export interface FilerefSummary {
  /**
   * Specifies the version number of this representation schema. This is version 1.
   * @type {number}
   * @memberof FilerefSummary
   */
  version?: number;
  /**
   * Specifies the identifier for this fileref.
   * @type {string}
   * @memberof FilerefSummary
   */
  id?: string;
  /**
   * Specifies the name of fileref resource.
   * @type {string}
   * @memberof FilerefSummary
   */
  name?: string;
  /**
   * Specifies links that apply to this fileref.
   * @type {Array<Link>}
   * @memberof FilerefSummary
   */
  links?: Array<Link>;
}
/**
 * Provides a collection of fileref summaries.
 * @export
 * @interface FilerefSummaryCollection
 */
export interface FilerefSummaryCollection {
  /**
   * The name of the collection.
   * @type {string}
   * @memberof FilerefSummaryCollection
   */
  name?: string;
  /**
   * The zero-based index of the first item in the collection.
   * @type {number}
   * @memberof FilerefSummaryCollection
   */
  start?: number;
  /**
   * The number of items that were requested for the collection.
   * @type {number}
   * @memberof FilerefSummaryCollection
   */
  limit?: number;
  /**
   * If populated indicates the number of items in the collection.
   * @type {number}
   * @memberof FilerefSummaryCollection
   */
  count?: number;
  /**
   * A space-delimited list of media types from which an `Accept` header may be constructed.
   * @type {string}
   * @memberof FilerefSummaryCollection
   */
  accept?: string;
  /**
   * The links that apply to the collection.
   * @type {Array<Link>}
   * @memberof FilerefSummaryCollection
   */
  links?: Array<Link>;
  /**
   * The version number of the collection representation. This representation is version 2.
   * @type {number}
   * @memberof FilerefSummaryCollection
   */
  version?: number;
  /**
   * Array containing list of fileref summary resources.
   * @type {Array<FilerefSummary>}
   * @memberof FilerefSummaryCollection
   */
  items: Array<FilerefSummary>;
}
/**
 *
 * @export
 * @interface FilerefSummaryCollectionAllOf
 */
export interface FilerefSummaryCollectionAllOf {
  /**
   * Array containing list of fileref summary resources.
   * @type {Array<FilerefSummary>}
   * @memberof FilerefSummaryCollectionAllOf
   */
  items: Array<FilerefSummary>;
}
/**
 * Provides a description of a SAS format or informat.
 * @export
 * @interface Format
 */
export interface Format {
  /**
   * Specifies the category that this format falls into (for example, CHAR, DATE, BINARY, and so on).
   * @type {string}
   * @memberof Format
   */
  category?: string;
  /**
   * Specifies the decimal precision that a format defaults to.
   * @type {number}
   * @memberof Format
   */
  defaultDecimals?: number;
  /**
   * Specifies the default modifier that is applied to a format.
   * @type {number}
   * @memberof Format
   */
  defaultModifier?: number;
  /**
   * Specifies the default width of this format.
   * @type {number}
   * @memberof Format
   */
  defaultWidth?: number;
  /**
   * Specifies the format type, which is either \'format\' or \'informat\'.
   * @type {string}
   * @memberof Format
   */
  formatType?: string;
  /**
   * Specifies whether a format is left-justified or right-justified.
   * @type {string}
   * @memberof Format
   */
  justification?: string;
  /**
   * Specifies the maximum decimal precision that you can set for a format.
   * @type {number}
   * @memberof Format
   */
  maximumDecimals?: number;
  /**
   * Specifies the maximum width that you can set for a format.
   * @type {number}
   * @memberof Format
   */
  maximumWidth?: number;
  /**
   * Specifies the minimum decimal precision that you can set for a format.
   * @type {number}
   * @memberof Format
   */
  minimumDecimals?: number;
  /**
   * Specifies the minimum width that you can set for a format.
   * @type {number}
   * @memberof Format
   */
  minimumWidth?: number;
  /**
   * Specifies the version number of this representation schema. This is version 1.
   * @type {number}
   * @memberof Format
   */
  version?: number;
  /**
   * Specifies the identifier of a format.
   * @type {string}
   * @memberof Format
   */
  id?: string;
  /**
   * Specifies the name of a format.
   * @type {string}
   * @memberof Format
   */
  name?: string;
  /**
   * Specifies the links that apply to a format.
   * @type {Array<Link>}
   * @memberof Format
   */
  links?: Array<Link>;
}
/**
 * Provides a summary of a SAS format or informat.
 * @export
 * @interface FormatSummary
 */
export interface FormatSummary {
  /**
   * Specifies the version number of this representation schema. This is version 1.
   * @type {number}
   * @memberof FormatSummary
   */
  version?: number;
  /**
   * Specifies the identifier of this format.
   * @type {string}
   * @memberof FormatSummary
   */
  id?: string;
  /**
   * Specifies the name of this format.
   * @type {string}
   * @memberof FormatSummary
   */
  name?: string;
  /**
   * Specifies the links that apply to this format.
   * @type {Array<Link>}
   * @memberof FormatSummary
   */
  links?: Array<Link>;
}
/**
 * Provides a collection of format summaries.
 * @export
 * @interface FormatSummaryCollection
 */
export interface FormatSummaryCollection {
  /**
   * The name of the collection.
   * @type {string}
   * @memberof FormatSummaryCollection
   */
  name?: string;
  /**
   * The zero-based index of the first item in the collection.
   * @type {number}
   * @memberof FormatSummaryCollection
   */
  start?: number;
  /**
   * The number of items that were requested for the collection.
   * @type {number}
   * @memberof FormatSummaryCollection
   */
  limit?: number;
  /**
   * If populated indicates the number of items in the collection.
   * @type {number}
   * @memberof FormatSummaryCollection
   */
  count?: number;
  /**
   * A space-delimited list of media types from which an `Accept` header may be constructed.
   * @type {string}
   * @memberof FormatSummaryCollection
   */
  accept?: string;
  /**
   * The links that apply to the collection.
   * @type {Array<Link>}
   * @memberof FormatSummaryCollection
   */
  links?: Array<Link>;
  /**
   * The version number of the collection representation. This representation is version 2.
   * @type {number}
   * @memberof FormatSummaryCollection
   */
  version?: number;
  /**
   * Specifies an array that contains a list of format summary resources.
   * @type {Array<FormatSummary>}
   * @memberof FormatSummaryCollection
   */
  items: Array<FormatSummary>;
}
/**
 *
 * @export
 * @interface FormatSummaryCollectionAllOf
 */
export interface FormatSummaryCollectionAllOf {
  /**
   * Specifies an array that contains a list of format summary resources.
   * @type {Array<FormatSummary>}
   * @memberof FormatSummaryCollectionAllOf
   */
  items: Array<FormatSummary>;
}
/**
 * Provides a description of a job that has been submitted to a Compute session.
 * @export
 * @interface Job
 */
export interface Job {
  /**
   * Specifies the version number of this representation schema. This is version 1.
   * @type {number}
   * @memberof Job
   */
  version?: number;
  /**
   * Specifies the identifier that describes this job.
   * @type {string}
   * @memberof Job
   */
  id?: string;
  /**
   * Specifies an optional name that is associated with this job.
   * @type {string}
   * @memberof Job
   */
  name?: string;
  /**
   * Specifies an optional description for this job.
   * @type {string}
   * @memberof Job
   */
  description?: string;
  /**
   * Specifies the timestamp when the job was created.
   * @type {string}
   * @memberof Job
   */
  creationTimeStamp?: string;
  /**
   * Specifies the timestamp when the job completed.
   * @type {string}
   * @memberof Job
   */
  completedTimeStamp?: string;
  /**
   * Specifies the session that this job was submitted in.
   * @type {string}
   * @memberof Job
   */
  sessionId?: string;
  /**
   * Specifies the current state of this job. Here are the possible values: pending, running, canceled, warning, error, or completed.
   * @type {string}
   * @memberof Job
   */
  state?: string;
  /**
   * Specifies the condition code for this job. This value is set when the job completes, and the value is set to the value of the SYSCC macro variable.
   * @type {number}
   * @memberof Job
   */
  jobConditionCode?: number;
  /**
   *
   * @type {LogStatistics}
   * @memberof Job
   */
  logStatistics?: LogStatistics;
  /**
   *
   * @type {ListingStatistics}
   * @memberof Job
   */
  listingStatistics?: ListingStatistics;
  /**
   *
   * @type {JobStatistics}
   * @memberof Job
   */
  statistics?: JobStatistics;
  /**
   * Specifies the links that apply to this job.
   * @type {Array<Link>}
   * @memberof Job
   */
  links?: Array<Link>;
}
/**
 * Provides a paginated collection of jobs.
 * @export
 * @interface JobCollection
 */
export interface JobCollection {
  /**
   * The name of the collection.
   * @type {string}
   * @memberof JobCollection
   */
  name?: string;
  /**
   * The zero-based index of the first item in the collection.
   * @type {number}
   * @memberof JobCollection
   */
  start?: number;
  /**
   * The number of items that were requested for the collection.
   * @type {number}
   * @memberof JobCollection
   */
  limit?: number;
  /**
   * If populated indicates the number of items in the collection.
   * @type {number}
   * @memberof JobCollection
   */
  count?: number;
  /**
   * A space-delimited list of media types from which an `Accept` header may be constructed.
   * @type {string}
   * @memberof JobCollection
   */
  accept?: string;
  /**
   * The links that apply to the collection.
   * @type {Array<Link>}
   * @memberof JobCollection
   */
  links?: Array<Link>;
  /**
   * The version number of the collection representation. This representation is version 2.
   * @type {number}
   * @memberof JobCollection
   */
  version?: number;
  /**
   * Specifies an array that contains job resources.
   * @type {Array<Job>}
   * @memberof JobCollection
   */
  items: Array<Job>;
}
/**
 *
 * @export
 * @interface JobCollectionAllOf
 */
export interface JobCollectionAllOf {
  /**
   * Specifies an array that contains job resources.
   * @type {Array<Job>}
   * @memberof JobCollectionAllOf
   */
  items: Array<Job>;
}
/**
 * Provides a collection of line objects that comprise the output for a job.
 * @export
 * @interface JobListingCollection
 */
export interface JobListingCollection {
  /**
   * The name of the collection.
   * @type {string}
   * @memberof JobListingCollection
   */
  name?: string;
  /**
   * The zero-based index of the first item in the collection.
   * @type {number}
   * @memberof JobListingCollection
   */
  start?: number;
  /**
   * The number of items that were requested for the collection.
   * @type {number}
   * @memberof JobListingCollection
   */
  limit?: number;
  /**
   * If populated indicates the number of items in the collection.
   * @type {number}
   * @memberof JobListingCollection
   */
  count?: number;
  /**
   * A space-delimited list of media types from which an `Accept` header may be constructed.
   * @type {string}
   * @memberof JobListingCollection
   */
  accept?: string;
  /**
   * The links that apply to the collection.
   * @type {Array<Link>}
   * @memberof JobListingCollection
   */
  links?: Array<Link>;
  /**
   * The version number of the collection representation. This representation is version 2.
   * @type {number}
   * @memberof JobListingCollection
   */
  version?: number;
  /**
   * Specifies an array that contains listing lines from a job.
   * @type {Array<LogLine>}
   * @memberof JobListingCollection
   */
  items: Array<LogLine>;
}
/**
 *
 * @export
 * @interface JobListingCollectionAllOf
 */
export interface JobListingCollectionAllOf {
  /**
   * Specifies an array that contains listing lines from a job.
   * @type {Array<LogLine>}
   * @memberof JobListingCollectionAllOf
   */
  items: Array<LogLine>;
}
/**
 * Provides a collection of line objects that comprise the log for a job.
 * @export
 * @interface JobLogCollection
 */
export interface JobLogCollection {
  /**
   * The name of the collection.
   * @type {string}
   * @memberof JobLogCollection
   */
  name?: string;
  /**
   * The zero-based index of the first item in the collection.
   * @type {number}
   * @memberof JobLogCollection
   */
  start?: number;
  /**
   * The number of items that were requested for the collection.
   * @type {number}
   * @memberof JobLogCollection
   */
  limit?: number;
  /**
   * If populated indicates the number of items in the collection.
   * @type {number}
   * @memberof JobLogCollection
   */
  count?: number;
  /**
   * A space-delimited list of media types from which an `Accept` header may be constructed.
   * @type {string}
   * @memberof JobLogCollection
   */
  accept?: string;
  /**
   * The links that apply to the collection.
   * @type {Array<Link>}
   * @memberof JobLogCollection
   */
  links?: Array<Link>;
  /**
   * The version number of the collection representation. This representation is version 2.
   * @type {number}
   * @memberof JobLogCollection
   */
  version?: number;
  /**
   * Specifies an array that contains log lines from a job.
   * @type {Array<LogLine>}
   * @memberof JobLogCollection
   */
  items: Array<LogLine>;
}
/**
 *
 * @export
 * @interface JobLogCollectionAllOf
 */
export interface JobLogCollectionAllOf {
  /**
   * Specifies an array that contains log lines from a job.
   * @type {Array<LogLine>}
   * @memberof JobLogCollectionAllOf
   */
  items: Array<LogLine>;
}
/**
 * Provides an object that you use to request a new job in a Compute session.
 * @export
 * @interface JobRequest
 */
export interface JobRequest {
  /**
   * Specifies the version number of this representation schema. This is version 3.
   * @type {number}
   * @memberof JobRequest
   */
  version?: number;
  /**
   * Specifies an optional name that is associated with this job.
   * @type {string}
   * @memberof JobRequest
   */
  name?: string;
  /**
   * Specifies an optional description for this job.
   * @type {string}
   * @memberof JobRequest
   */
  description?: string;
  /**
   *
   * @type {Environment}
   * @memberof JobRequest
   */
  environment?: Environment;
  /**
   * Specifies input variables for this request.
   * @type {{ [key: string]: string; }}
   * @memberof JobRequest
   */
  variables?: { [key: string]: string };
  /**
   *
   * @type {Array<string>}
   * @memberof JobRequest
   */
  code?: Array<string>;
  /**
   * Specifies a URI path to a resource reference from the Files service. You must specify code or codeUri.
   * @type {string}
   * @memberof JobRequest
   */
  codeUri?: string;
  /**
   * Specifies the resources that are requested for this job.
   * @type {Array<Resource>}
   * @memberof JobRequest
   */
  resources?: Array<Resource>;
  /**
   * Specifies the attributes that modify the behavior of this job request. See example for details. Support for these attributes was added in version 2.
   * @type {object}
   * @memberof JobRequest
   */
  attributes?: object;
}
/**
 * Provides performance data for a job.
 * @export
 * @interface JobStatistics
 */
export interface JobStatistics {
  /**
   * Specifies the elapsed CPU time that is related to the system.
   * @type {number}
   * @memberof JobStatistics
   */
  systemCpuTime?: number;
  /**
   * Specifies the elapsed CPU time that is related to user tasks.
   * @type {number}
   * @memberof JobStatistics
   */
  userCpuTime?: number;
}
/**
 * Describes a SAS libref.
 * @export
 * @interface Library
 */
export interface Library {
  /**
   * Specifies the version number of this representation schema. This is version 2.
   * @type {number}
   * @memberof Library
   */
  version?: number;
  /**
   * Specifies the identifier for this library. This value is the same as the specified libref at assignment.
   * @type {string}
   * @memberof Library
   */
  id?: string;
  /**
   * Specifies the number of concatenated libraries, if any are concatenated.
   * @type {number}
   * @memberof Library
   */
  concatenationCount?: number;
  /**
   * Specifies the information about the concatenated members, if any are concatenated.
   * @type {Array<Concatenation>}
   * @memberof Library
   */
  concatenations?: Array<Concatenation>;
  /**
   * Specifies the name of the engine that is used with this library.
   * @type {string}
   * @memberof Library
   */
  engineName?: string;
  /**
   * Specifies the identifier of the format for this library.
   * @type {string}
   * @memberof Library
   */
  fileFormat?: string;
  /**
   * Specifies the flags that were used when the library was created.
   * @type {number}
   * @memberof Library
   */
  flags?: number;
  /**
   * Specifies the name of the referenced library.
   * @type {string}
   * @memberof Library
   */
  libref?: string;
  /**
   * Specifies the name of the library resource.
   * @type {string}
   * @memberof Library
   */
  name?: string;
  /**
   * Specifies the options that were used to create this library.
   * @type {string}
   * @memberof Library
   */
  options?: string;
  /**
   * Specifies the resolved location of this library.
   * @type {string}
   * @memberof Library
   */
  physicalName?: string;
  /**
   * Specifies whether the library is read only.
   * @type {boolean}
   * @memberof Library
   */
  readOnly?: boolean;
  /**
   * Specifies links that apply to this library.
   * @type {Array<Link>}
   * @memberof Library
   */
  links?: Array<Link>;
}
/**
 * Assigns a new library or libref.
 * @export
 * @interface LibraryRequest
 */
export interface LibraryRequest {
  /**
   * Specifies the version number of this representation schema. This is version 1.
   * @type {number}
   * @memberof LibraryRequest
   */
  version?: number;
  /**
   * Specifies the name of the library to assign.
   * @type {string}
   * @memberof LibraryRequest
   */
  name: string;
  /**
   * Specifies the engine to use with this library.
   * @type {string}
   * @memberof LibraryRequest
   */
  engine: string;
  /**
   * Specifies the engine-specific path information for this library.
   * @type {string}
   * @memberof LibraryRequest
   */
  path: string;
  /**
   * Specifies options that the engine uses.
   * @type {Array<string>}
   * @memberof LibraryRequest
   */
  options?: Array<string>;
}
/**
 * Summarizes a SAS libref.
 * @export
 * @interface LibrarySummary
 */
export interface LibrarySummary {
  /**
   * The version number of this representation schema.  This is version 2.
   * @type {number}
   * @memberof LibrarySummary
   */
  version?: number;
  /**
   * Specifies the identifier for this library summary object. This is currently the same as the libref given at assignment time.
   * @type {string}
   * @memberof LibrarySummary
   */
  id?: string;
  /**
   * Specifies the name of this library summary.
   * @type {string}
   * @memberof LibrarySummary
   */
  name?: string;
  /**
   * Specifies links that apply to this library summary.
   * @type {Array<Link>}
   * @memberof LibrarySummary
   */
  links?: Array<Link>;
}
/**
 * Provides a collection of library summaries.
 * @export
 * @interface LibrarySummaryCollection
 */
export interface LibrarySummaryCollection {
  /**
   * The name of the collection.
   * @type {string}
   * @memberof LibrarySummaryCollection
   */
  name?: string;
  /**
   * The zero-based index of the first item in the collection.
   * @type {number}
   * @memberof LibrarySummaryCollection
   */
  start?: number;
  /**
   * The number of items that were requested for the collection.
   * @type {number}
   * @memberof LibrarySummaryCollection
   */
  limit?: number;
  /**
   * If populated indicates the number of items in the collection.
   * @type {number}
   * @memberof LibrarySummaryCollection
   */
  count?: number;
  /**
   * A space-delimited list of media types from which an `Accept` header may be constructed.
   * @type {string}
   * @memberof LibrarySummaryCollection
   */
  accept?: string;
  /**
   * The links that apply to the collection.
   * @type {Array<Link>}
   * @memberof LibrarySummaryCollection
   */
  links?: Array<Link>;
  /**
   * The version number of the collection representation. This representation is version 2.
   * @type {number}
   * @memberof LibrarySummaryCollection
   */
  version?: number;
  /**
   * Specifies an array that contains library summary resources.
   * @type {Array<LibrarySummary>}
   * @memberof LibrarySummaryCollection
   */
  items: Array<LibrarySummary>;
}
/**
 *
 * @export
 * @interface LibrarySummaryCollectionAllOf
 */
export interface LibrarySummaryCollectionAllOf {
  /**
   * Specifies an array that contains library summary resources.
   * @type {Array<LibrarySummary>}
   * @memberof LibrarySummaryCollectionAllOf
   */
  items: Array<LibrarySummary>;
}
/**
 * A link to a related operation or resource.
 * @export
 * @interface Link
 */
export interface Link {
  /**
   * The HTTP method for the link.
   * @type {string}
   * @memberof Link
   */
  method?: string;
  /**
   * The relationship of the link to the resource.
   * @type {string}
   * @memberof Link
   */
  rel: string;
  /**
   * The relative URI for the link.
   * @type {string}
   * @memberof Link
   */
  uri?: string;
  /**
   * The URL for the link.
   * @type {string}
   * @memberof Link
   */
  href?: string;
  /**
   * The title for the link.
   * @type {string}
   * @memberof Link
   */
  title?: string;
  /**
   * The media type or link type for the link.
   * @type {string}
   * @memberof Link
   */
  type?: string;
  /**
   * If this is a link to a container, `itemType` is the media type or link type for the items in the container.
   * @type {string}
   * @memberof Link
   */
  itemType?: string;
  /**
   * The media type or link type of the response body for a `PUT`, `POST`, or `PATCH` operation.
   * @type {string}
   * @memberof Link
   */
  responseType?: string;
  /**
   * The media type or link type of the items in the response body for a `PUT`, `POST`, or `PATCH` operation.
   * @type {string}
   * @memberof Link
   */
  responseItemType?: string;
}
/**
 * Provides information about the output for a session or job.
 * @export
 * @interface ListingStatistics
 */
export interface ListingStatistics {
  /**
   * Specifies the number of lines in the specified listing.
   * @type {number}
   * @memberof ListingStatistics
   */
  lineCount?: number;
  /**
   * Specifies the timestamp when the listing information was last updated.
   * @type {string}
   * @memberof ListingStatistics
   */
  modifiedTimeStamp?: string;
}
/**
 * Provides an individual line from a log or listing resource.
 * @export
 * @interface LogLine
 */
export interface LogLine {
  /**
   * Specifies the version number of this representation schema. This is version 1.
   * @type {number}
   * @memberof LogLine
   */
  version?: number;
  /**
   * Specifies the line entry classification.
   * @type {string}
   * @memberof LogLine
   */
  type: LogLineTypeEnum;
  /**
   * Specifies the line of text without the type (classification) prefix marker.
   * @type {string}
   * @memberof LogLine
   */
  line: string;
}

export const LogLineTypeEnum = {
  Normal: "normal",
  Hilighted: "hilighted",
  Source: "source",
  Title: "title",
  Byline: "byline",
  Footnote: "footnote",
  Error: "error",
  Warning: "warning",
  Note: "note",
  Message: "message",
} as const;

export type LogLineTypeEnum =
  (typeof LogLineTypeEnum)[keyof typeof LogLineTypeEnum];

/**
 * Provides information about the log for a session or a job.
 * @export
 * @interface LogStatistics
 */
export interface LogStatistics {
  /**
   * Specifies the number of lines in the specified log.
   * @type {number}
   * @memberof LogStatistics
   */
  lineCount?: number;
  /**
   * Specifies the timestamp when the log information was last updated.
   * @type {string}
   * @memberof LogStatistics
   */
  modifiedTimeStamp?: string;
}
/**
 * Requests that session or job log or listing output be uploaded to the Files service.
 * @export
 * @interface OutputStreamFileRequest
 */
export interface OutputStreamFileRequest {
  /**
   * Specifies the version number of this representation schema. This is version 1.
   * @type {number}
   * @memberof OutputStreamFileRequest
   */
  version?: number;
  /**
   * Specifies the attributes that modify the behavior of this stream request. See example for details.
   * @type {object}
   * @memberof OutputStreamFileRequest
   */
  attributes?: object;
}
/**
 * Provides data from a table for use in building prompts
 * @export
 * @interface PromptContent
 */
export interface PromptContent {
  /**
   * Specifies the version number of this representation schema. This is version 1.
   * @type {number}
   * @memberof PromptContent
   */
  version?: number;
  /**
   * Specifies the level of column information that is returned.  Values are names (default), detail, or summary.
   * @type {string}
   * @memberof PromptContent
   */
  columnDetail?: string;
  /**
   * Specifies column information for the prompt content.
   * @type {Array<string>}
   * @memberof PromptContent
   */
  columns?: Array<string>;
  /**
   * Specifies the formatted and raw data for the cells in this row.
   * @type {Array<FormatSummary>}
   * @memberof PromptContent
   */
  rows?: Array<FormatSummary>;
  /**
   * Specifies the start index of the returned rows.
   * @type {number}
   * @memberof PromptContent
   */
  start?: number;
  /**
   * Specifies links that apply to this prompt content.
   * @type {Array<Link>}
   * @memberof PromptContent
   */
  links?: Array<Link>;
}
/**
 * Provides a request that you can use to build prompt content based on a given dataset.
 * @export
 * @interface PromptContentRequest
 */
export interface PromptContentRequest {
  /**
   * Specifies the version number of this representation schema. This is version 1.
   * @type {number}
   * @memberof PromptContentRequest
   */
  version?: number;
  /**
   * Specifies that a standard SAS WHERE clause was used to build the content for this request.
   * @type {string}
   * @memberof PromptContentRequest
   */
  where?: string;
  /**
   *
   * @type {FileProtection}
   * @memberof PromptContentRequest
   */
  fileProtection?: FileProtection;
  /**
   * Specifies the encoding for the password values in the fileProtection structure. If the value is \"base64\", then the password values in the fileProtection structure should be encoded by converting the text to UTF-8 and base64-encoding the result. If no value is provided, then the password values of the fileProtection structure are expected to be clear text.
   * @type {string}
   * @memberof PromptContentRequest
   */
  fileProtectionEncoding?: string;
  /**
   * Specifies the level of column information to return.
   * @type {string}
   * @memberof PromptContentRequest
   */
  columnDetail?: PromptContentRequestColumnDetailEnum;
  /**
   * Specifies an array of strings that indicate the columns to include in the returned content. If you do not specify a value, then all columns are returned. The order of the column names in the list indicates the order for the cells of the prompt content.
   * @type {Array<string>}
   * @memberof PromptContentRequest
   */
  includeColumns?: Array<string>;
  /**
   * When includeColumns is specified, a value of true for columnNatrualOrder specifies that the cells of the prompt content are returned in the order in which they occur in the data set instead of in the order that is specified by includeColumns.
   * @type {boolean}
   * @memberof PromptContentRequest
   */
  columnNaturalOrder?: boolean;
  /**
   * Specifies an array of objects that describe the sort definitions to use in the prompt content.
   * @type {Array<SortByRequest>}
   * @memberof PromptContentRequest
   */
  sortBy?: Array<SortByRequest>;
  /**
   *
   * @type {Array<ColumnFormatting>}
   * @memberof PromptContentRequest
   */
  columnFormatting?: Array<ColumnFormatting>;
}

export const PromptContentRequestColumnDetailEnum = {
  Names: "names",
  Detail: "detail",
  Summary: "summary",
} as const;

export type PromptContentRequestColumnDetailEnum =
  (typeof PromptContentRequestColumnDetailEnum)[keyof typeof PromptContentRequestColumnDetailEnum];

/**
 * Contains the formatted and raw row data for prompt content
 * @export
 * @interface PromptContentRowData
 */
export interface PromptContentRowData {
  /**
   * Formatted cells of the given row
   * @type {Array<object>}
   * @memberof PromptContentRowData
   */
  formatted?: Array<object>;
  /**
   * Raw, unformatted cells of the given row
   * @type {Array<object>}
   * @memberof PromptContentRowData
   */
  raw?: Array<object>;
}
/**
 * Provides information about a resource from a different service that can be referenced by the Compute service.
 * @export
 * @interface Resource
 */
export interface Resource {
  /**
   * Specifies the name for the resource. This name can be used to reference this resource on the server. The value of the name is limited to 40 characters. The value must be unique within a context.
   * @type {string}
   * @memberof Resource
   */
  name: string;
  /**
   * Specifies the URI path to the resource. The URI path contains information about how to access the resource under the services base URL. The value of the URI is limited to 500 characters.
   * @type {string}
   * @memberof Resource
   */
  uri: string;
  /**
   * Specifies the type of resource that is referenced in this item. The value of the type is limited to 100 characters.
   * @type {string}
   * @memberof Resource
   */
  type: string;
  /**
   * Specifies whether the resource can be referenced in the output or results of a session or job.
   * @type {boolean}
   * @memberof Resource
   */
  output?: boolean;
  /**
   * Specifies the scope of the resource. If a resource is specified for a job and the resource has JOB scope, then the resource is deleted or deassigned at the end of the job.
   * @type {string}
   * @memberof Resource
   */
  scope?: ResourceScopeEnum;
  /**
   * Specifies the options to add to the resource for the creation or assignment of an internal SAS component that is created based on type.
   * @type {object}
   * @memberof Resource
   */
  options?: object;
  /**
   * Specifies whether a resource is required. If a required resource cannot be instantiated by the session or job, then that session or job is considered to have failed.
   * @type {boolean}
   * @memberof Resource
   */
  required?: boolean;
  /**
   * Specifies the attributes for the resource. Support for resource attributes was added in version 3 for contexts, context requests, and job requests, and in version 2 for session requests.
   * @type {object}
   * @memberof Resource
   */
  attributes?: object;
}

export const ResourceScopeEnum = {
  Session: "SESSION",
  Job: "JOB",
} as const;

export type ResourceScopeEnum =
  (typeof ResourceScopeEnum)[keyof typeof ResourceScopeEnum];

/**
 * Provides a result that was created by a job and that is available for use by a consumer of a service.
 * @export
 * @interface Result
 */
export interface Result {
  /**
   * Specifies the identifier for this result item.
   * @type {string}
   * @memberof Result
   */
  id?: string;
  /**
   * Specifies the human readable name of the result item.
   * @type {string}
   * @memberof Result
   */
  name?: string;
  /**
   * Specifies the type of output that is generated for this result.
   * @type {string}
   * @memberof Result
   */
  type?: ResultTypeEnum;
  /**
   * Specifies links that apply to this result.
   * @type {Array<Link>}
   * @memberof Result
   */
  links?: Array<Link>;
}

export const ResultTypeEnum = {
  Library: "LIBRARY",
  Table: "TABLE",
  File: "FILE",
  Ods: "ODS",
} as const;

export type ResultTypeEnum =
  (typeof ResultTypeEnum)[keyof typeof ResultTypeEnum];

/**
 * Provides a paginated collection of result objects.
 * @export
 * @interface ResultCollection
 */
export interface ResultCollection {
  /**
   * The name of the collection.
   * @type {string}
   * @memberof ResultCollection
   */
  name?: string;
  /**
   * The zero-based index of the first item in the collection.
   * @type {number}
   * @memberof ResultCollection
   */
  start?: number;
  /**
   * The number of items that were requested for the collection.
   * @type {number}
   * @memberof ResultCollection
   */
  limit?: number;
  /**
   * If populated indicates the number of items in the collection.
   * @type {number}
   * @memberof ResultCollection
   */
  count?: number;
  /**
   * A space-delimited list of media types from which an `Accept` header may be constructed.
   * @type {string}
   * @memberof ResultCollection
   */
  accept?: string;
  /**
   * The links that apply to the collection.
   * @type {Array<Link>}
   * @memberof ResultCollection
   */
  links?: Array<Link>;
  /**
   * The version number of the collection representation. This representation is version 2.
   * @type {number}
   * @memberof ResultCollection
   */
  version?: number;
  /**
   * Specifies an array that contains results.
   * @type {Array<Result>}
   * @memberof ResultCollection
   */
  items: Array<Result>;
}
/**
 *
 * @export
 * @interface ResultCollectionAllOf
 */
export interface ResultCollectionAllOf {
  /**
   * Specifies an array that contains results.
   * @type {Array<Result>}
   * @memberof ResultCollectionAllOf
   */
  items: Array<Result>;
}
/**
 * Provides data from a row of a table.
 * @export
 * @interface Row
 */
export interface Row {
  /**
   * Specifies values for the data cells in this row.
   * @type {Array<any>}
   * @memberof Row
   */
  cells?: Array<any>;
}
/**
 * Provides a paginated collection of table rows.
 * @export
 * @interface RowCollection
 */
export interface RowCollection {
  /**
   * The name of the collection.
   * @type {string}
   * @memberof RowCollection
   */
  name?: string;
  /**
   * The zero-based index of the first item in the collection.
   * @type {number}
   * @memberof RowCollection
   */
  start?: number;
  /**
   * The number of items that were requested for the collection.
   * @type {number}
   * @memberof RowCollection
   */
  limit?: number;
  /**
   * If populated indicates the number of items in the collection.
   * @type {number}
   * @memberof RowCollection
   */
  count?: number;
  /**
   * A space-delimited list of media types from which an `Accept` header may be constructed.
   * @type {string}
   * @memberof RowCollection
   */
  accept?: string;
  /**
   * The links that apply to the collection.
   * @type {Array<Link>}
   * @memberof RowCollection
   */
  links?: Array<Link>;
  /**
   * The version number of the collection representation. This representation is version 2.
   * @type {number}
   * @memberof RowCollection
   */
  version?: number;
  /**
   * Specifies an array that contains row resources.
   * @type {Array<Row>}
   * @memberof RowCollection
   */
  items: Array<Row>;
}
/**
 *
 * @export
 * @interface RowCollectionAllOf
 */
export interface RowCollectionAllOf {
  /**
   * Specifies an array that contains row resources.
   * @type {Array<Row>}
   * @memberof RowCollectionAllOf
   */
  items: Array<Row>;
}
/**
 * Provides data from a table in row set formation.
 * @export
 * @interface RowSet
 */
export interface RowSet {
  /**
   * Specifies the version number of this representation schema. This is version 1.
   * @type {number}
   * @memberof RowSet
   */
  version?: number;
  /**
   * Specifies the level of column information that is returned. Values are names (default), detail, or summary.
   * @type {string}
   * @memberof RowSet
   */
  columnDetail?: string;
  /**
   * Specifies column information for the row set.
   * @type {Array<string>}
   * @memberof RowSet
   */
  columns?: Array<string>;
  /**
   * Specifies the values for the data cells in this row.
   * @type {Array<Array<any>>}
   * @memberof RowSet
   */
  rows?: Array<Array<any>>;
  /**
   * Specifies the start index of the returned rows.
   * @type {number}
   * @memberof RowSet
   */
  start?: number;
  /**
   * Specifies links that apply to this row set.
   * @type {Array<Link>}
   * @memberof RowSet
   */
  links?: Array<Link>;
}
/**
 * Provides a request that you can use to generate a row set.
 * @export
 * @interface RowSetRequest
 */
export interface RowSetRequest {
  /**
   * Specifies the version number of this representation schema. This is version 3.
   * @type {number}
   * @memberof RowSetRequest
   */
  version?: number;
  /**
   * Specifies that a standard SAS WHERE clause was used to build the row set for this request.
   * @type {string}
   * @memberof RowSetRequest
   */
  where?: string;
  /**
   *
   * @type {FileProtection}
   * @memberof RowSetRequest
   */
  fileProtection?: FileProtection;
  /**
   * Specifies the encoding for the password values in the fileProtection structure. If the value is \"base64\", then the password values in the fileProtection structure should be encoded by converting the text to UTF-8 and base64-encoding the result. If no value is provided, then the password values of the fileProtection structure are expected to be clear text.
   * @type {string}
   * @memberof RowSetRequest
   */
  fileProtectionEncoding?: string;
  /**
   * Specifies the level of column information to return.
   * @type {string}
   * @memberof RowSetRequest
   */
  columnDetail?: RowSetRequestColumnDetailEnum;
  /**
   * Specifies an array of strings that indicate the columns to include in a row set. If you do not specify a value, then all columns are returned. The order of the column names in the list indicates the order for the cells of the row set.
   * @type {Array<string>}
   * @memberof RowSetRequest
   */
  includeColumns?: Array<string>;
  /**
   * When includeColumns is specified, a value of true for columnNatrualOrder specifies that the cells of the row set are returned in the order in which they occur in the data set instead of in the order that is specified by includeColumns.
   * @type {boolean}
   * @memberof RowSetRequest
   */
  columnNaturalOrder?: boolean;
  /**
   * Specifies an array of objects that describe the sort definitions to use in this row set.
   * @type {Array<SortByRequest>}
   * @memberof RowSetRequest
   */
  sortBy?: Array<SortByRequest>;
  /**
   *
   * @type {Array<ColumnFormatting>}
   * @memberof RowSetRequest
   */
  columnFormatting?: Array<ColumnFormatting>;
}

export const RowSetRequestColumnDetailEnum = {
  Names: "names",
  Detail: "detail",
  Summary: "summary",
} as const;

export type RowSetRequestColumnDetailEnum =
  (typeof RowSetRequestColumnDetailEnum)[keyof typeof RowSetRequestColumnDetailEnum];

/**
 * Provides a request that you can use to obtain rows from a table or data set.
 * @export
 * @interface RowsRequest
 */
export interface RowsRequest {
  /**
   * Specifies the version number of this representation schema. This is version 3.
   * @type {number}
   * @memberof RowsRequest
   */
  version?: number;
  /**
   * Specifies that a standard SAS WHERE clause was used to return the rows for this request.
   * @type {string}
   * @memberof RowsRequest
   */
  where?: string;
  /**
   *
   * @type {FileProtection}
   * @memberof RowsRequest
   */
  fileProtection?: FileProtection;
  /**
   * Specifies the encoding for the password values in the fileProtection structure. If the value is \"base64\", then the password values in the fileProtection structure should be encoded by converting the text to UTF-8 and base64-encoding the result. If no value is provided, then the password values of the fileProtection structure are expected to be clear text.
   * @type {string}
   * @memberof RowsRequest
   */
  fileProtectionEncoding?: string;
  /**
   * Specifies the formatting to be used for specified columns.
   * @type {Array<ColumnFormatting>}
   * @memberof RowsRequest
   */
  columnFormatting?: Array<ColumnFormatting>;
}
/**
 * Provides a running SAS Compute Server process.
 * @export
 * @interface Server
 */
export interface Server {
  /**
   * Specifies the version number of this representation schema. This is version 2.
   * @type {number}
   * @memberof Server
   */
  version?: number;
  /**
   * Specifies an optional name that is associated with this server.
   * @type {string}
   * @memberof Server
   */
  name?: string;
  /**
   * Specifies an optional description for this server.
   * @type {string}
   * @memberof Server
   */
  description?: string;
  /**
   * Specifies the timestamp when the server was created.
   * @type {string}
   * @memberof Server
   */
  creationTimeStamp?: string;
  /**
   * Specifies the user ID that created the server.
   * @type {string}
   * @memberof Server
   */
  createdBy?: string;
  /**
   * Specifies the identifier for this server.
   * @type {string}
   * @memberof Server
   */
  id?: string;
  /**
   * Specifies the current state of this server. The current value is running.
   * @type {string}
   * @memberof Server
   */
  state?: string;
  /**
   * Specifies the links that apply to this server.
   * @type {Array<Link>}
   * @memberof Server
   */
  links?: Array<Link>;
}
/**
 * Provides a summary of a SAS Compute Server process that is currently running.
 * @export
 * @interface ServerSummary
 */
export interface ServerSummary {
  /**
   * Specifies the version number of this representation schema. This is version 1.
   * @type {number}
   * @memberof ServerSummary
   */
  version?: number;
  /**
   * Specifies the identifier of this server.
   * @type {string}
   * @memberof ServerSummary
   */
  id?: string;
  /**
   * Specifies the links that apply to this server.
   * @type {Array<Link>}
   * @memberof ServerSummary
   */
  links?: Array<Link>;
}
/**
 * Provides a paginated collection of server summary objects.
 * @export
 * @interface ServerSummaryCollection
 */
export interface ServerSummaryCollection {
  /**
   * The name of the collection.
   * @type {string}
   * @memberof ServerSummaryCollection
   */
  name?: string;
  /**
   * The zero-based index of the first item in the collection.
   * @type {number}
   * @memberof ServerSummaryCollection
   */
  start?: number;
  /**
   * The number of items that were requested for the collection.
   * @type {number}
   * @memberof ServerSummaryCollection
   */
  limit?: number;
  /**
   * If populated indicates the number of items in the collection.
   * @type {number}
   * @memberof ServerSummaryCollection
   */
  count?: number;
  /**
   * A space-delimited list of media types from which an `Accept` header may be constructed.
   * @type {string}
   * @memberof ServerSummaryCollection
   */
  accept?: string;
  /**
   * The links that apply to the collection.
   * @type {Array<Link>}
   * @memberof ServerSummaryCollection
   */
  links?: Array<Link>;
  /**
   * The version number of the collection representation. This representation is version 2.
   * @type {number}
   * @memberof ServerSummaryCollection
   */
  version?: number;
  /**
   * Specifies the array that contains resource information about the server summary.
   * @type {Array<ServerSummary>}
   * @memberof ServerSummaryCollection
   */
  items: Array<ServerSummary>;
}
/**
 *
 * @export
 * @interface ServerSummaryCollectionAllOf
 */
export interface ServerSummaryCollectionAllOf {
  /**
   * Specifies the array that contains resource information about the server summary.
   * @type {Array<ServerSummary>}
   * @memberof ServerSummaryCollectionAllOf
   */
  items: Array<ServerSummary>;
}
/**
 * Provides a Compute session object.
 * @export
 * @interface Session
 */
export interface Session {
  /**
   * Specifies the version number of this representation schema. This is version 2.
   * @type {number}
   * @memberof Session
   */
  version?: number;
  /**
   * Specifies an optional name that is associated with this session.
   * @type {string}
   * @memberof Session
   */
  name?: string;
  /**
   * Specifies an optional description for this session.
   * @type {string}
   * @memberof Session
   */
  description?: string;
  /**
   * Specifies attributes that were defined when the session was requested.
   * @type {object}
   * @memberof Session
   */
  attributes?: object;
  /**
   * Specifies the timestamp when the session was created.
   * @type {string}
   * @memberof Session
   */
  creationTimeStamp?: string;
  /**
   * Specifies the user Id of the owner of this session.
   * @type {string}
   * @memberof Session
   */
  owner?: string;
  /**
   * Specifies the identifier for this session, as determined by the server.
   * @type {string}
   * @memberof Session
   */
  id?: string;
  /**
   * Specifies the identifier of the server that this session belongs to.
   * @type {string}
   * @memberof Session
   */
  serverId?: string;
  /**
   * Specifies the current state of this session. Here are the possible values: completed, failed, running, idle, pending, or stopped.
   * @type {string}
   * @memberof Session
   */
  state?: string;
  /**
   * Specifies the condition code for this session. This is set to the highest value of any jobConditionCode for jobs that executed in the session.
   * @type {number}
   * @memberof Session
   */
  sessionConditionCode?: number;
  /**
   *
   * @type {LogStatistics}
   * @memberof Session
   */
  logStatistics?: LogStatistics;
  /**
   *
   * @type {ListingStatistics}
   * @memberof Session
   */
  listingStatistics?: ListingStatistics;
  /**
   *
   * @type {SessionStatistics}
   * @memberof Session
   */
  sessionStatistics?: SessionStatistics;
  /**
   * Specifies the name of the application that requested this session.
   * @type {string}
   * @memberof Session
   */
  applicationName?: string;
  /**
   * The version of the service API that this session supports.
   * @type {number}
   * @memberof Session
   */
  serviceAPIVersion?: number;
  /**
   * Specifies links that apply to this session.
   * @type {Array<Link>}
   * @memberof Session
   */
  links?: Array<Link>;
}
/**
 * Provides a collection of line objects that comprise the output for a session.
 * @export
 * @interface SessionListingCollection
 */
export interface SessionListingCollection {
  /**
   * The name of the collection.
   * @type {string}
   * @memberof SessionListingCollection
   */
  name?: string;
  /**
   * The zero-based index of the first item in the collection.
   * @type {number}
   * @memberof SessionListingCollection
   */
  start?: number;
  /**
   * The number of items that were requested for the collection.
   * @type {number}
   * @memberof SessionListingCollection
   */
  limit?: number;
  /**
   * If populated indicates the number of items in the collection.
   * @type {number}
   * @memberof SessionListingCollection
   */
  count?: number;
  /**
   * A space-delimited list of media types from which an `Accept` header may be constructed.
   * @type {string}
   * @memberof SessionListingCollection
   */
  accept?: string;
  /**
   * The links that apply to the collection.
   * @type {Array<Link>}
   * @memberof SessionListingCollection
   */
  links?: Array<Link>;
  /**
   * The version number of the collection representation. This representation is version 2.
   * @type {number}
   * @memberof SessionListingCollection
   */
  version?: number;
  /**
   * Specifies an array that contains listing lines from a session.
   * @type {Array<LogLine>}
   * @memberof SessionListingCollection
   */
  items: Array<LogLine>;
}
/**
 *
 * @export
 * @interface SessionListingCollectionAllOf
 */
export interface SessionListingCollectionAllOf {
  /**
   * Specifies an array that contains listing lines from a session.
   * @type {Array<LogLine>}
   * @memberof SessionListingCollectionAllOf
   */
  items: Array<LogLine>;
}
/**
 * Provides a collection of line objects that comprise the log for a session.
 * @export
 * @interface SessionLogCollection
 */
export interface SessionLogCollection {
  /**
   * The name of the collection.
   * @type {string}
   * @memberof SessionLogCollection
   */
  name?: string;
  /**
   * The zero-based index of the first item in the collection.
   * @type {number}
   * @memberof SessionLogCollection
   */
  start?: number;
  /**
   * The number of items that were requested for the collection.
   * @type {number}
   * @memberof SessionLogCollection
   */
  limit?: number;
  /**
   * If populated indicates the number of items in the collection.
   * @type {number}
   * @memberof SessionLogCollection
   */
  count?: number;
  /**
   * A space-delimited list of media types from which an `Accept` header may be constructed.
   * @type {string}
   * @memberof SessionLogCollection
   */
  accept?: string;
  /**
   * The links that apply to the collection.
   * @type {Array<Link>}
   * @memberof SessionLogCollection
   */
  links?: Array<Link>;
  /**
   * The version number of the collection representation. This representation is version 2.
   * @type {number}
   * @memberof SessionLogCollection
   */
  version?: number;
  /**
   * Specifies an array that contains log lines from the session.
   * @type {Array<LogLine>}
   * @memberof SessionLogCollection
   */
  items: Array<LogLine>;
}
/**
 *
 * @export
 * @interface SessionLogCollectionAllOf
 */
export interface SessionLogCollectionAllOf {
  /**
   * Specifies an array that contains log lines from the session.
   * @type {Array<LogLine>}
   * @memberof SessionLogCollectionAllOf
   */
  items: Array<LogLine>;
}
/**
 * Specifies information about a SAS option that is used in the current session.
 * @export
 * @interface SessionOption
 */
export interface SessionOption {
  /**
   * Specifies the version number of this representation schema. This is version 1.
   * @type {number}
   * @memberof SessionOption
   */
  version?: number;
  /**
   * Specifies the name of the option.
   * @type {string}
   * @memberof SessionOption
   */
  name?: string;
  /**
   * Specifies the description of the option as defined in the system.
   * @type {string}
   * @memberof SessionOption
   */
  description?: string;
  /**
   * Specifies the current value of the option, if it is available.
   * @type {string}
   * @memberof SessionOption
   */
  value?: string;
}
/**
 * Provides an object that you use to request a new Compute session.
 * @export
 * @interface SessionRequest
 */
export interface SessionRequest {
  /**
   * Specifies the version number of this representation schema. This is version 2.
   * @type {number}
   * @memberof SessionRequest
   */
  version?: number;
  /**
   * Specifies an optional name that is associated with this session. The value of name is limited to 100 characters. The name is used for informational purposes only.
   * @type {string}
   * @memberof SessionRequest
   */
  name?: string;
  /**
   * Specifies an optional description for this session. The value of description is limited to 1000 characters.
   * @type {string}
   * @memberof SessionRequest
   */
  description?: string;
  /**
   * Specifies service-specific attributes that control the behavior of this session. See the example for details.
   * @type {object}
   * @memberof SessionRequest
   */
  attributes?: object;
  /**
   *
   * @type {Environment}
   * @memberof SessionRequest
   */
  environment?: Environment;
  /**
   * Specifies the resources that are requested for this session.
   * @type {Array<Resource>}
   * @memberof SessionRequest
   */
  resources?: Array<Resource>;
}
/**
 * Provides performance data for a session.
 * @export
 * @interface SessionStatistics
 */
export interface SessionStatistics {
  /**
   * Specifies the elapsed CPU time that is related to the system for a session.
   * @type {number}
   * @memberof SessionStatistics
   */
  systemCpuTime?: number;
  /**
   * Specifies the elapsed CPU time that is related to the user tasks for a session.
   * @type {number}
   * @memberof SessionStatistics
   */
  userCpuTime?: number;
  /**
   * Specifies the highest level of memory usage by the session.
   * @type {number}
   * @memberof SessionStatistics
   */
  memorySize?: number;
}
/**
 * Provides a Compute session summary object.
 * @export
 * @interface SessionSummary
 */
export interface SessionSummary {
  /**
   * Specifies the version number of this representation schema. This is version 2.
   * @type {number}
   * @memberof SessionSummary
   */
  version?: number;
  /**
   * Specifies an optional name that is associated with this session.
   * @type {string}
   * @memberof SessionSummary
   */
  name?: string;
  /**
   * Specifies an identifier for this session, as determined by the server.
   * @type {string}
   * @memberof SessionSummary
   */
  id?: string;
  /**
   * Specifies the user ID of the owner of this session.
   * @type {string}
   * @memberof SessionSummary
   */
  owner?: string;
  /**
   * Specifies links that apply to this session.
   * @type {Array<Link>}
   * @memberof SessionSummary
   */
  links?: Array<Link>;
}
/**
 * Provides a paginated collection of Compute session summaries.
 * @export
 * @interface SessionSummaryCollection
 */
export interface SessionSummaryCollection {
  /**
   * The name of the collection.
   * @type {string}
   * @memberof SessionSummaryCollection
   */
  name?: string;
  /**
   * The zero-based index of the first item in the collection.
   * @type {number}
   * @memberof SessionSummaryCollection
   */
  start?: number;
  /**
   * The number of items that were requested for the collection.
   * @type {number}
   * @memberof SessionSummaryCollection
   */
  limit?: number;
  /**
   * If populated indicates the number of items in the collection.
   * @type {number}
   * @memberof SessionSummaryCollection
   */
  count?: number;
  /**
   * A space-delimited list of media types from which an `Accept` header may be constructed.
   * @type {string}
   * @memberof SessionSummaryCollection
   */
  accept?: string;
  /**
   * The links that apply to the collection.
   * @type {Array<Link>}
   * @memberof SessionSummaryCollection
   */
  links?: Array<Link>;
  /**
   * The version number of the collection representation. This representation is version 2.
   * @type {number}
   * @memberof SessionSummaryCollection
   */
  version?: number;
  /**
   * Specifies an array that contains session summary resources.
   * @type {Array<SessionSummary>}
   * @memberof SessionSummaryCollection
   */
  items: Array<SessionSummary>;
}
/**
 *
 * @export
 * @interface SessionSummaryCollectionAllOf
 */
export interface SessionSummaryCollectionAllOf {
  /**
   * Specifies an array that contains session summary resources.
   * @type {Array<SessionSummary>}
   * @memberof SessionSummaryCollectionAllOf
   */
  items: Array<SessionSummary>;
}
/**
 * Provides a paginated collection of SAS macro variables.
 * @export
 * @interface SessionVariableCollection
 */
export interface SessionVariableCollection {
  /**
   * The name of the collection.
   * @type {string}
   * @memberof SessionVariableCollection
   */
  name?: string;
  /**
   * The zero-based index of the first item in the collection.
   * @type {number}
   * @memberof SessionVariableCollection
   */
  start?: number;
  /**
   * The number of items that were requested for the collection.
   * @type {number}
   * @memberof SessionVariableCollection
   */
  limit?: number;
  /**
   * If populated indicates the number of items in the collection.
   * @type {number}
   * @memberof SessionVariableCollection
   */
  count?: number;
  /**
   * A space-delimited list of media types from which an `Accept` header may be constructed.
   * @type {string}
   * @memberof SessionVariableCollection
   */
  accept?: string;
  /**
   * The links that apply to the collection.
   * @type {Array<Link>}
   * @memberof SessionVariableCollection
   */
  links?: Array<Link>;
  /**
   * The version number of the collection representation. This representation is version 2.
   * @type {number}
   * @memberof SessionVariableCollection
   */
  version?: number;
  /**
   * Specifies an array that contains a listing of current session variables.
   * @type {Array<Variable>}
   * @memberof SessionVariableCollection
   */
  items: Array<Variable>;
}
/**
 *
 * @export
 * @interface SessionVariableCollectionAllOf
 */
export interface SessionVariableCollectionAllOf {
  /**
   * Specifies an array that contains a listing of current session variables.
   * @type {Array<Variable>}
   * @memberof SessionVariableCollectionAllOf
   */
  items: Array<Variable>;
}
/**
 * Provides sorting options to use with a table or data set.
 * @export
 * @interface SortByRequest
 */
export interface SortByRequest {
  /**
   * Specifies the key to use in this sortBy request.
   * @type {string}
   * @memberof SortByRequest
   */
  key?: string;
  /**
   * Specifies the sort order for this sortBy request.
   * @type {string}
   * @memberof SortByRequest
   */
  direction?: SortByRequestDirectionEnum;
}

export const SortByRequestDirectionEnum = {
  Ascending: "ascending",
  Descending: "descending",
} as const;

export type SortByRequestDirectionEnum =
  (typeof SortByRequestDirectionEnum)[keyof typeof SortByRequestDirectionEnum];

/**
 * Provides information about a SAS table or data set.
 * @export
 * @interface TableInfo
 */
export interface TableInfo {
  /**
   * Specifies the version number of this representation schema. This is version 1.
   * @type {number}
   * @memberof TableInfo
   */
  version?: number;
  /**
   * Specifies the identifier for this data set.
   * @type {string}
   * @memberof TableInfo
   */
  id?: string;
  /**
   * Specifies the name of this data set.
   * @type {string}
   * @memberof TableInfo
   */
  name?: string;
  /**
   * Specifies the table type as DATA or VIEW.
   * @type {string}
   * @memberof TableInfo
   */
  type?: string;
  /**
   * Specifies that this is a special type of table. Most tables do not have an extended type, but the ones that do typically have special columns, rows, or both that are used by some SAS/STAT procedures.
   * @type {string}
   * @memberof TableInfo
   */
  extendedType?: string;
  /**
   * Specifies the length of the bookmark in this data set.
   * @type {number}
   * @memberof TableInfo
   */
  bookmarkLength?: number;
  /**
   * Specifies the compression routine for this data set.
   * @type {string}
   * @memberof TableInfo
   */
  compressionRoutine?: string;
  /**
   * Specifies the creation timestamp for this data set.
   * @type {string}
   * @memberof TableInfo
   */
  creationTimeStamp?: string;
  /**
   * Specifies the modification timestamp for this data set.
   * @type {string}
   * @memberof TableInfo
   */
  modifiedTimeStamp?: string;
  /**
   * Specifies the name of the engine that handles this data set.
   * @type {string}
   * @memberof TableInfo
   */
  engine?: string;
  /**
   * Specifies the label for this data set. This label describes the data set.
   * @type {string}
   * @memberof TableInfo
   */
  label?: string;
  /**
   * Specifies the name of the library that owns this data set.
   * @type {string}
   * @memberof TableInfo
   */
  libref?: string;
  /**
   * Specifies the logical record count for this data set.
   * @type {number}
   * @memberof TableInfo
   */
  logicalRecordCount?: number;
  /**
   * Specifies the number of columns that are defined in this data set.
   * @type {number}
   * @memberof TableInfo
   */
  columnCount?: number;
  /**
   * Specifies the number of rows that are defined in this data set.
   * @type {number}
   * @memberof TableInfo
   */
  rowCount?: number;
  /**
   * Specifies the physical record count for this data set.
   * @type {number}
   * @memberof TableInfo
   */
  physicalRecordCount?: number;
  /**
   * Specifies the length of a record in this data set.
   * @type {number}
   * @memberof TableInfo
   */
  recordLength?: number;
  /**
   * Specifies the character encoding that is used to store the table.
   * @type {string}
   * @memberof TableInfo
   */
  encoding?: string;
  /**
   * Specifies links that apply to this data set.
   * @type {Array<Link>}
   * @memberof TableInfo
   */
  links?: Array<Link>;
}
/**
 * Summarizes a SAS table or data set.
 * @export
 * @interface TableSummary
 */
export interface TableSummary {
  /**
   * Specifies the version number of this representation schema. This is version 1.
   * @type {number}
   * @memberof TableSummary
   */
  version?: number;
  /**
   * Specifies the identifier for this table object.
   * @type {string}
   * @memberof TableSummary
   */
  id?: string;
  /**
   * Specifies the name of the table.
   * @type {string}
   * @memberof TableSummary
   */
  name?: string;
  /**
   * Specifies links that apply to this table summary.
   * @type {Array<Link>}
   * @memberof TableSummary
   */
  links?: Array<Link>;
}
/**
 * Provides a paginated collection of SAS table or data set summaries.
 * @export
 * @interface TableSummaryCollection
 */
export interface TableSummaryCollection {
  /**
   * The name of the collection.
   * @type {string}
   * @memberof TableSummaryCollection
   */
  name?: string;
  /**
   * The zero-based index of the first item in the collection.
   * @type {number}
   * @memberof TableSummaryCollection
   */
  start?: number;
  /**
   * The number of items that were requested for the collection.
   * @type {number}
   * @memberof TableSummaryCollection
   */
  limit?: number;
  /**
   * If populated indicates the number of items in the collection.
   * @type {number}
   * @memberof TableSummaryCollection
   */
  count?: number;
  /**
   * A space-delimited list of media types from which an `Accept` header may be constructed.
   * @type {string}
   * @memberof TableSummaryCollection
   */
  accept?: string;
  /**
   * The links that apply to the collection.
   * @type {Array<Link>}
   * @memberof TableSummaryCollection
   */
  links?: Array<Link>;
  /**
   * The version number of the collection representation. This representation is version 2.
   * @type {number}
   * @memberof TableSummaryCollection
   */
  version?: number;
  /**
   * Specifies an array that contains table summary resources.
   * @type {Array<TableSummary>}
   * @memberof TableSummaryCollection
   */
  items: Array<TableSummary>;
}
/**
 *
 * @export
 * @interface TableSummaryCollectionAllOf
 */
export interface TableSummaryCollectionAllOf {
  /**
   * Specifies an array that contains table summary resources.
   * @type {Array<TableSummary>}
   * @memberof TableSummaryCollectionAllOf
   */
  items: Array<TableSummary>;
}
/**
 * This class is used to provide common attributes and behaviors around tracking who and when objects were created and modified to representation objects.
 * @export
 * @interface TrackedResource
 */
export interface TrackedResource {
  /**
   * The username of whoever created the resource.
   * @type {string}
   * @memberof TrackedResource
   */
  createdBy?: string;
  /**
   * The username of whoever last modified the resource.
   * @type {string}
   * @memberof TrackedResource
   */
  modifiedBy?: string;
  /**
   * The timestamp for when the resource was created.
   * @type {string}
   * @memberof TrackedResource
   */
  creationTimeStamp?: string;
  /**
   * The timestamp for when the resource was last modified.
   * @type {string}
   * @memberof TrackedResource
   */
  modifiedTimeStamp?: string;
}
/**
 * Describes a SAS macro variable that is available from the current session.
 * @export
 * @interface Variable
 */
export interface Variable {
  /**
   * Specifies the version number of this representation schema. This is version 1.
   * @type {number}
   * @memberof Variable
   */
  version?: number;
  /**
   * Specifies the scope of the variable as determined by SAS.
   * @type {string}
   * @memberof Variable
   */
  scope?: string;
  /**
   * Specifies the name of the variable.
   * @type {string}
   * @memberof Variable
   */
  name?: string;
  /**
   * Specifies the value of the variable.
   * @type {string}
   * @memberof Variable
   */
  value?: string;
}
/**
 * Provides a request that you can use to create a view on a table or data set.
 * @export
 * @interface ViewRequest
 */
export interface ViewRequest {
  /**
   * Specifies the version number of this representation schema. This is version 2.
   * @type {number}
   * @memberof ViewRequest
   */
  version?: number;
  /**
   * Specifies that a standard SAS WHERE clause was used to select the data for this view.
   * @type {string}
   * @memberof ViewRequest
   */
  where?: string;
  /**
   *
   * @type {FileProtection}
   * @memberof ViewRequest
   */
  fileProtection?: FileProtection;
  /**
   * Specifies the encoding for the password values in the fileProtection structure. If the value is \"base64\", then the password values in the fileProtection structure should be encoded by converting the text to UTF-8 and base64-encoding the result. If no value is provided, then the password values of the fileProtection structure are expected to be clear text.
   * @type {string}
   * @memberof ViewRequest
   */
  fileProtectionEncoding?: string;
  /**
   * Specifies an array of strings that indicate the columns to include in the row set. If no value is specified, then all columns are returned.
   * @type {Array<string>}
   * @memberof ViewRequest
   */
  includeColumns?: Array<string>;
  /**
   * When includeColumns is specified, a value of true for columnNatrualOrder specifies that the cells of the row set are returned in the order in which they occur in the data set instead of in the order that is specified by includeColumns.
   * @type {boolean}
   * @memberof ViewRequest
   */
  columnNaturalOrder?: boolean;
  /**
   * Specifies an array of objects that describe the sort definitions to use for this row set.
   * @type {Array<SortByRequest>}
   * @memberof ViewRequest
   */
  sortBy?: Array<SortByRequest>;
  /**
   * Specifies whether to select only distinct values for the view.
   * @type {boolean}
   * @memberof ViewRequest
   */
  distinct?: boolean;
}

/**
 * ContextsApi - axios parameter creator
 * @export
 */
export const ContextsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Creates a context definition. The new context is assigned a unique ID. The contextName namespace is managed by you, and the contextName must be unique. You can update contexts by performing a PUT on the corresponding URL.
     * @summary Create a context definition
     * @param {ContextRequest} contextRequest Specifies a context request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContext: async (
      contextRequest: ContextRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contextRequest' is not null or undefined
      assertParamExists("createContext", "contextRequest", contextRequest);
      const localVarPath = `/contexts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] =
        "application/vnd.sas.compute.context.request+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        contextRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new session that is based on the Compute context definition that corresponds to the contextId path variable. If a reusable SAS Compute Server is available to handle this session, a new session is created on that SAS Compute Server. Otherwise, a new SAS Compute Server is created and the new session is created on that SAS Compute Server. The new session is associated with the identity of the requester. URLs that define how to access the session are returned. The contextId matches the ID member of a known context entry. The Location header contains the URI of the created session resource.
     * @summary Request new session
     * @param {string} contextId Specifies the context definition ID.
     * @param {SessionRequest} [sessionRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSession: async (
      contextId: string,
      sessionRequest?: SessionRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contextId' is not null or undefined
      assertParamExists("createSession", "contextId", contextId);
      const localVarPath = `/contexts/{contextId}/sessions`.replace(
        `{${"contextId"}}`,
        encodeURIComponent(String(contextId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] =
        "application/vnd.sas.compute.session.request+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        sessionRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes the context definition that has the specified contextId.
     * @summary Delete a context definition
     * @param {string} contextId Deletes the context definition with the specified ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteContext: async (
      contextId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contextId' is not null or undefined
      assertParamExists("deleteContext", "contextId", contextId);
      const localVarPath = `/contexts/{contextId}`.replace(
        `{${"contextId"}}`,
        encodeURIComponent(String(contextId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns the context definition that has the specified contextId.
     * @summary Get a context definition
     * @param {string} contextId Returns the context definition with the specified ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContext: async (
      contextId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contextId' is not null or undefined
      assertParamExists("getContext", "contextId", contextId);
      const localVarPath = `/contexts/{contextId}`.replace(
        `{${"contextId"}}`,
        encodeURIComponent(String(contextId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of Compute context definitions. Standard paging, filtering, and sorting options are provided. By default, this endpoint returns a summary of the available information about the contexts. Specify an Accept-Item header with the value application/vnd.sas.compute.context+json to get all available information for each context.
     * @summary Get context definitions
     * @param {'application/vnd.sas.compute.context+json' | 'application/vnd.sas.compute.context.summary+json'} [acceptItem] Specifies the desired context representation.&lt;br&gt; The Accept-Item options are: &lt;ul&gt; &lt;li&gt;application/vnd.sas.compute.context+json &lt;li&gt;application/vnd.sas.compute.context.summary+json &lt;li&gt;blank &lt;/ul&gt; If the application/vnd.sas.compute.context.summary+json type is specified or no Accept-Item header is specified, then the contexts are returned as summary representation context objects.
     * @param {number} [start] Specifies the offset of the first context definition to return. The default value is \&quot;0\&quot;.
     * @param {number} [limit] Specifies the maximum number of context definitions to return. The default value is \&quot;10\&quot;.
     * @param {string} [filter] Specifies the filter criteria for returned context definitions.
     * @param {string} [sortBy] Sorts returned context definitions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContexts: async (
      acceptItem?:
        | "application/vnd.sas.compute.context+json"
        | "application/vnd.sas.compute.context.summary+json",
      start?: number,
      limit?: number,
      filter?: string,
      sortBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/contexts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (filter !== undefined) {
        localVarQueryParameter["filter"] = filter;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter["sortBy"] = sortBy;
      }

      if (acceptItem != null) {
        localVarHeaderParameter["Accept-Item"] = String(acceptItem);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether the specified context exists.
     * @summary Verify that a context exists
     * @param {string} contextId Specifies the context to check.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForContext: async (
      contextId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contextId' is not null or undefined
      assertParamExists("headersForContext", "contextId", contextId);
      const localVarPath = `/contexts/{contextId}`.replace(
        `{${"contextId"}}`,
        encodeURIComponent(String(contextId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether an endpoint is currently available.
     * @summary Check endpoint availability
     * @param {number} [start] Returns the offset of first context definition to return. The default value is \&quot;0\&quot;.
     * @param {number} [limit] Returns the maximum number of context definitions to return. The default value is \&quot;10\&quot;.
     * @param {string} [filter] Specifies the filter criteria for returned context definitions.
     * @param {string} [sortBy] Sorts returned context definitions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForContexts: async (
      start?: number,
      limit?: number,
      filter?: string,
      sortBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/contexts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (filter !== undefined) {
        localVarQueryParameter["filter"] = filter;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter["sortBy"] = sortBy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates a context definition. Changing a context does not affect any sessions that are currently running on the server that is instantiated by that context. Servers that are created after updating the context use the current definition. If the contextId matches the ID of an existing context, that context is updated. Otherwise, an error is returned. The request must include the current ETag of the context as the value of the If-Match request header to prevent concurrent updates. The current ETag of the context is provided in the value of the ETag response header of any endpoint that produces application/vnd.sas.compute.context.
     * @summary Update a context definition
     * @param {string} contextId Specifies the ID of the context definition.
     * @param {string} ifMatch Specifies the current ETag of the context that you are updating.
     * @param {Context} context context definition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateContext: async (
      contextId: string,
      ifMatch: string,
      context: Context,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contextId' is not null or undefined
      assertParamExists("updateContext", "contextId", contextId);
      // verify required parameter 'ifMatch' is not null or undefined
      assertParamExists("updateContext", "ifMatch", ifMatch);
      // verify required parameter 'context' is not null or undefined
      assertParamExists("updateContext", "context", context);
      const localVarPath = `/contexts/{contextId}`.replace(
        `{${"contextId"}}`,
        encodeURIComponent(String(contextId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (ifMatch != null) {
        localVarHeaderParameter["If-Match"] = String(ifMatch);
      }

      localVarHeaderParameter["Content-Type"] =
        "application/vnd.sas.compute.context+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        context,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ContextsApi - functional programming interface
 * @export
 */
export const ContextsApi = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ContextsApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a context definition. The new context is assigned a unique ID. The contextName namespace is managed by you, and the contextName must be unique. You can update contexts by performing a PUT on the corresponding URL.
     * @summary Create a context definition
     * @param {ContextsApiCreateContextRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createContext(
      requestParameters: ContextsApiCreateContextRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<Context>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createContext(
        requestParameters.contextRequest,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Creates a new session that is based on the Compute context definition that corresponds to the contextId path variable. If a reusable SAS Compute Server is available to handle this session, a new session is created on that SAS Compute Server. Otherwise, a new SAS Compute Server is created and the new session is created on that SAS Compute Server. The new session is associated with the identity of the requester. URLs that define how to access the session are returned. The contextId matches the ID member of a known context entry. The Location header contains the URI of the created session resource.
     * @summary Request new session
     * @param {ContextsApiCreateSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSession(
      requestParameters: ContextsApiCreateSessionRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<Session>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createSession(
        requestParameters.contextId,
        requestParameters.sessionRequest,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Deletes the context definition that has the specified contextId.
     * @summary Delete a context definition
     * @param {ContextsApiDeleteContextRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteContext(
      requestParameters: ContextsApiDeleteContextRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContext(
        requestParameters.contextId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns the context definition that has the specified contextId.
     * @summary Get a context definition
     * @param {ContextsApiGetContextRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getContext(
      requestParameters: ContextsApiGetContextRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<Context>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getContext(
        requestParameters.contextId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns a list of Compute context definitions. Standard paging, filtering, and sorting options are provided. By default, this endpoint returns a summary of the available information about the contexts. Specify an Accept-Item header with the value application/vnd.sas.compute.context+json to get all available information for each context.
     * @summary Get context definitions
     * @param {ContextsApiGetContextsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getContexts(
      requestParameters: ContextsApiGetContextsRequest = {},
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<ContextSummaryCollection>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getContexts(
        requestParameters.acceptItem,
        requestParameters.start,
        requestParameters.limit,
        requestParameters.filter,
        requestParameters.sortBy,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether the specified context exists.
     * @summary Verify that a context exists
     * @param {ContextsApiHeadersForContextRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForContext(
      requestParameters: ContextsApiHeadersForContextRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForContext(
          requestParameters.contextId,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether an endpoint is currently available.
     * @summary Check endpoint availability
     * @param {ContextsApiHeadersForContextsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForContexts(
      requestParameters: ContextsApiHeadersForContextsRequest = {},
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForContexts(
          requestParameters.start,
          requestParameters.limit,
          requestParameters.filter,
          requestParameters.sortBy,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Updates a context definition. Changing a context does not affect any sessions that are currently running on the server that is instantiated by that context. Servers that are created after updating the context use the current definition. If the contextId matches the ID of an existing context, that context is updated. Otherwise, an error is returned. The request must include the current ETag of the context as the value of the If-Match request header to prevent concurrent updates. The current ETag of the context is provided in the value of the ETag response header of any endpoint that produces application/vnd.sas.compute.context.
     * @summary Update a context definition
     * @param {ContextsApiUpdateContextRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateContext(
      requestParameters: ContextsApiUpdateContextRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<Context>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateContext(
        requestParameters.contextId,
        requestParameters.ifMatch,
        requestParameters.context,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },
  };
};

/**
 * Request parameters for createContext operation in ContextsApi.
 * @export
 * @interface ContextsApiCreateContextRequest
 */
export interface ContextsApiCreateContextRequest {
  /**
   * Specifies a context request.
   * @type {ContextRequest}
   * @memberof ContextsApiCreateContext
   */
  readonly contextRequest: ContextRequest;
}

/**
 * Request parameters for createSession operation in ContextsApi.
 * @export
 * @interface ContextsApiCreateSessionRequest
 */
export interface ContextsApiCreateSessionRequest {
  /**
   * Specifies the context definition ID.
   * @type {string}
   * @memberof ContextsApiCreateSession
   */
  readonly contextId: string;

  /**
   *
   * @type {SessionRequest}
   * @memberof ContextsApiCreateSession
   */
  readonly sessionRequest?: SessionRequest;
}

/**
 * Request parameters for deleteContext operation in ContextsApi.
 * @export
 * @interface ContextsApiDeleteContextRequest
 */
export interface ContextsApiDeleteContextRequest {
  /**
   * Deletes the context definition with the specified ID.
   * @type {string}
   * @memberof ContextsApiDeleteContext
   */
  readonly contextId: string;
}

/**
 * Request parameters for getContext operation in ContextsApi.
 * @export
 * @interface ContextsApiGetContextRequest
 */
export interface ContextsApiGetContextRequest {
  /**
   * Returns the context definition with the specified ID.
   * @type {string}
   * @memberof ContextsApiGetContext
   */
  readonly contextId: string;
}

/**
 * Request parameters for getContexts operation in ContextsApi.
 * @export
 * @interface ContextsApiGetContextsRequest
 */
export interface ContextsApiGetContextsRequest {
  /**
   * Specifies the desired context representation.&lt;br&gt; The Accept-Item options are: &lt;ul&gt; &lt;li&gt;application/vnd.sas.compute.context+json &lt;li&gt;application/vnd.sas.compute.context.summary+json &lt;li&gt;blank &lt;/ul&gt; If the application/vnd.sas.compute.context.summary+json type is specified or no Accept-Item header is specified, then the contexts are returned as summary representation context objects.
   * @type {'application/vnd.sas.compute.context+json' | 'application/vnd.sas.compute.context.summary+json'}
   * @memberof ContextsApiGetContexts
   */
  readonly acceptItem?:
    | "application/vnd.sas.compute.context+json"
    | "application/vnd.sas.compute.context.summary+json";

  /**
   * Specifies the offset of the first context definition to return. The default value is \&quot;0\&quot;.
   * @type {number}
   * @memberof ContextsApiGetContexts
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of context definitions to return. The default value is \&quot;10\&quot;.
   * @type {number}
   * @memberof ContextsApiGetContexts
   */
  readonly limit?: number;

  /**
   * Specifies the filter criteria for returned context definitions.
   * @type {string}
   * @memberof ContextsApiGetContexts
   */
  readonly filter?: string;

  /**
   * Sorts returned context definitions.
   * @type {string}
   * @memberof ContextsApiGetContexts
   */
  readonly sortBy?: string;
}

/**
 * Request parameters for headersForContext operation in ContextsApi.
 * @export
 * @interface ContextsApiHeadersForContextRequest
 */
export interface ContextsApiHeadersForContextRequest {
  /**
   * Specifies the context to check.
   * @type {string}
   * @memberof ContextsApiHeadersForContext
   */
  readonly contextId: string;
}

/**
 * Request parameters for headersForContexts operation in ContextsApi.
 * @export
 * @interface ContextsApiHeadersForContextsRequest
 */
export interface ContextsApiHeadersForContextsRequest {
  /**
   * Returns the offset of first context definition to return. The default value is \&quot;0\&quot;.
   * @type {number}
   * @memberof ContextsApiHeadersForContexts
   */
  readonly start?: number;

  /**
   * Returns the maximum number of context definitions to return. The default value is \&quot;10\&quot;.
   * @type {number}
   * @memberof ContextsApiHeadersForContexts
   */
  readonly limit?: number;

  /**
   * Specifies the filter criteria for returned context definitions.
   * @type {string}
   * @memberof ContextsApiHeadersForContexts
   */
  readonly filter?: string;

  /**
   * Sorts returned context definitions.
   * @type {string}
   * @memberof ContextsApiHeadersForContexts
   */
  readonly sortBy?: string;
}

/**
 * Request parameters for updateContext operation in ContextsApi.
 * @export
 * @interface ContextsApiUpdateContextRequest
 */
export interface ContextsApiUpdateContextRequest {
  /**
   * Specifies the ID of the context definition.
   * @type {string}
   * @memberof ContextsApiUpdateContext
   */
  readonly contextId: string;

  /**
   * Specifies the current ETag of the context that you are updating.
   * @type {string}
   * @memberof ContextsApiUpdateContext
   */
  readonly ifMatch: string;

  /**
   * context definition
   * @type {Context}
   * @memberof ContextsApiUpdateContext
   */
  readonly context: Context;
}

/**
 * DataAccessApi - axios parameter creator
 * @export
 */
export const DataAccessApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Assigns a libref that is based on the request body for a session. The Location header contains the URI of the libref resource.
     * @summary Assign a libref
     * @param {string} sessionId Specifies the ID of the session.
     * @param {LibraryRequest} libraryRequest Specifies a libref assignment request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLibrary: async (
      sessionId: string,
      libraryRequest: LibraryRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("createLibrary", "sessionId", sessionId);
      // verify required parameter 'libraryRequest' is not null or undefined
      assertParamExists("createLibrary", "libraryRequest", libraryRequest);
      const localVarPath = `/sessions/{sessionId}/data`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] =
        "application/vnd.sas.compute.library.request+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        libraryRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a view of the specified data set. The request body that you provide controls the view that is created. You can then access the returned view as a table.
     * @summary Create a data set view
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} libref Specifies the libref for the request.
     * @param {string} tableName Specifies the table or data set to query.
     * @param {ViewRequest} viewRequest Specifies a view creation request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createView: async (
      sessionId: string,
      libref: string,
      tableName: string,
      viewRequest: ViewRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("createView", "sessionId", sessionId);
      // verify required parameter 'libref' is not null or undefined
      assertParamExists("createView", "libref", libref);
      // verify required parameter 'tableName' is not null or undefined
      assertParamExists("createView", "tableName", tableName);
      // verify required parameter 'viewRequest' is not null or undefined
      assertParamExists("createView", "viewRequest", viewRequest);
      const localVarPath =
        `/sessions/{sessionId}/data/{libref}/{tableName}/views`
          .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
          .replace(`{${"libref"}}`, encodeURIComponent(String(libref)))
          .replace(`{${"tableName"}}`, encodeURIComponent(String(tableName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] =
        "application/vnd.sas.compute.data.table.view.request+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        viewRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Removes the libref from the session.
     * @summary Deassign libref
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} libref Specifies the libref to deassign.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLibrary: async (
      sessionId: string,
      libref: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("deleteLibrary", "sessionId", sessionId);
      // verify required parameter 'libref' is not null or undefined
      assertParamExists("deleteLibrary", "libref", libref);
      const localVarPath = `/sessions/{sessionId}/data/{libref}`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"libref"}}`, encodeURIComponent(String(libref)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes a table or view. If you request to delete a table and you have proper permissions, then the data set is deleted. If you request to delete a view, then the view is destroyed.
     * @summary Delete a table or view
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} libref Specifies the libref for the request.
     * @param {string} tableName Specifies the table or data set to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTable: async (
      sessionId: string,
      libref: string,
      tableName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("deleteTable", "sessionId", sessionId);
      // verify required parameter 'libref' is not null or undefined
      assertParamExists("deleteTable", "libref", libref);
      // verify required parameter 'tableName' is not null or undefined
      assertParamExists("deleteTable", "tableName", tableName);
      const localVarPath = `/sessions/{sessionId}/data/{libref}/{tableName}`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"libref"}}`, encodeURIComponent(String(libref)))
        .replace(`{${"tableName"}}`, encodeURIComponent(String(tableName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets a specific column from a data set.
     * @summary Get a column
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} libref Specifies the libref for the request.
     * @param {string} tableName Specifies the table or data set to query.
     * @param {string} columnName Specifies the name of the column to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getColumn: async (
      sessionId: string,
      libref: string,
      tableName: string,
      columnName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getColumn", "sessionId", sessionId);
      // verify required parameter 'libref' is not null or undefined
      assertParamExists("getColumn", "libref", libref);
      // verify required parameter 'tableName' is not null or undefined
      assertParamExists("getColumn", "tableName", tableName);
      // verify required parameter 'columnName' is not null or undefined
      assertParamExists("getColumn", "columnName", columnName);
      const localVarPath =
        `/sessions/{sessionId}/data/{libref}/{tableName}/columns/{columnName}`
          .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
          .replace(`{${"libref"}}`, encodeURIComponent(String(libref)))
          .replace(`{${"tableName"}}`, encodeURIComponent(String(tableName)))
          .replace(`{${"columnName"}}`, encodeURIComponent(String(columnName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns the column information for a specified data set. By default, a collection is returned, and standard paging options are available.
     * @summary Get column information
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} libref Specifies the libref for the request.
     * @param {string} tableName Specifies the table or data set to query.
     * @param {number} [start] Specifies the offset of the first column entry to return.
     * @param {number} [limit] Specifies the maximum number of columns to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getColumns: async (
      sessionId: string,
      libref: string,
      tableName: string,
      start?: number,
      limit?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getColumns", "sessionId", sessionId);
      // verify required parameter 'libref' is not null or undefined
      assertParamExists("getColumns", "libref", libref);
      // verify required parameter 'tableName' is not null or undefined
      assertParamExists("getColumns", "tableName", tableName);
      const localVarPath =
        `/sessions/{sessionId}/data/{libref}/{tableName}/columns`
          .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
          .replace(`{${"libref"}}`, encodeURIComponent(String(libref)))
          .replace(`{${"tableName"}}`, encodeURIComponent(String(tableName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns the column information for a specified data set based on the submitted request body. By default, a collection is returned, and standard paging options are available.
     * @summary Retrieve column information
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} libref Specifies the libref for the request.
     * @param {string} tableName Specifies the table or data set to query.
     * @param {number} [start] Specifies the offset of the first column entry to return.
     * @param {number} [limit] Specifies the maximum number of columns to return.
     * @param {ColumnsRequest} [columnsRequest] Optional body that is used to refine a request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getColumnsWithRequest: async (
      sessionId: string,
      libref: string,
      tableName: string,
      start?: number,
      limit?: number,
      columnsRequest?: ColumnsRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getColumnsWithRequest", "sessionId", sessionId);
      // verify required parameter 'libref' is not null or undefined
      assertParamExists("getColumnsWithRequest", "libref", libref);
      // verify required parameter 'tableName' is not null or undefined
      assertParamExists("getColumnsWithRequest", "tableName", tableName);
      const localVarPath =
        `/sessions/{sessionId}/data/{libref}/{tableName}/columns`
          .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
          .replace(`{${"libref"}}`, encodeURIComponent(String(libref)))
          .replace(`{${"tableName"}}`, encodeURIComponent(String(tableName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      localVarHeaderParameter["Content-Type"] =
        "application/vnd.sas.compute.data.table.columns.request+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        columnsRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Provides a listing that contains summaries of the libraries that are defined in the current session.
     * @summary Return libraries in a session
     * @param {string} sessionId Specifies the ID of the session.
     * @param {'application/vnd.sas.compute.library+json' | 'application/vnd.sas.compute.library.summary+json'} [acceptItem] Specifies the desired library representation.&lt;br&gt; The Accept-Item options are: &lt;ul&gt; &lt;li&gt;application/vnd.sas.compute.library+json &lt;li&gt;application/vnd.sas.compute.library.summary+json &lt;li&gt;blank &lt;/ul&gt; If the application/vnd.sas.compute.library.summary+json type is specified or no Accept-Item header is specified, then the libraries are returned as summary representation library objects.
     * @param {number} [start] Specifies the offset of the first library to return.
     * @param {number} [limit] Specifies the maximum number of libraries to return.
     * @param {boolean} [noCache] Specifies whether to force the library collection to be refreshed before it is returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLibraries: async (
      sessionId: string,
      acceptItem?:
        | "application/vnd.sas.compute.library+json"
        | "application/vnd.sas.compute.library.summary+json",
      start?: number,
      limit?: number,
      noCache?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getLibraries", "sessionId", sessionId);
      const localVarPath = `/sessions/{sessionId}/data`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (noCache !== undefined) {
        localVarQueryParameter["noCache"] = noCache;
      }

      if (acceptItem != null) {
        localVarHeaderParameter["Accept-Item"] = String(acceptItem);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves information about a specified libref, including links to tables.
     * @summary Get libref information
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} libref Specifies the libref to query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLibrary: async (
      sessionId: string,
      libref: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getLibrary", "sessionId", sessionId);
      // verify required parameter 'libref' is not null or undefined
      assertParamExists("getLibrary", "libref", libref);
      const localVarPath = `/sessions/{sessionId}/data/{libref}`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"libref"}}`, encodeURIComponent(String(libref)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns summary information about a specified libref.
     * @summary Get libref summary
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} libref Specifies the libref to query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLibrarySummary: async (
      sessionId: string,
      libref: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getLibrarySummary", "sessionId", sessionId);
      // verify required parameter 'libref' is not null or undefined
      assertParamExists("getLibrarySummary", "libref", libref);
      const localVarPath = `/sessions/{sessionId}/data/{libref}#summary`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"libref"}}`, encodeURIComponent(String(libref)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns content useful for populating prompts more effectively.
     * @summary Get prompt content from a data set
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} libref Specifies the libref for the request.
     * @param {string} tableName Specifies the table or data set to query.
     * @param {string} [where] Specifies that a standard SAS WHERE clause was used to build the content for this request.
     * @param {'names' | 'detail' | 'summary'} [columnDetail] Specifies the level of column information to return.
     * @param {string} [includeColumns] Specifies a comma-separated list of columns to include in the returned content . If you do not specify a list, all columns are returned. The order of the column names in the list determines the order of cells of the return prompt content.
     * @param {boolean} [columnNaturalOrder] When includeColumns is specified, a value of true for columnNatrualOrder specifies that the cells of the content are returned in the order in which they occur in the data set instead of in the order that is specified by includeColumns.
     * @param {number} [start] Specifies the offset of the first row to return.
     * @param {number} [limit] Specifies the maximum number of rows to return.
     * @param {string} [sortBy] Sets the sort order for the returned row set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPromptContent: async (
      sessionId: string,
      libref: string,
      tableName: string,
      where?: string,
      columnDetail?: "names" | "detail" | "summary",
      includeColumns?: string,
      columnNaturalOrder?: boolean,
      start?: number,
      limit?: number,
      sortBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getPromptContent", "sessionId", sessionId);
      // verify required parameter 'libref' is not null or undefined
      assertParamExists("getPromptContent", "libref", libref);
      // verify required parameter 'tableName' is not null or undefined
      assertParamExists("getPromptContent", "tableName", tableName);
      const localVarPath =
        `/sessions/{sessionId}/data/{libref}/{tableName}/promptContent`
          .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
          .replace(`{${"libref"}}`, encodeURIComponent(String(libref)))
          .replace(`{${"tableName"}}`, encodeURIComponent(String(tableName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (where !== undefined) {
        localVarQueryParameter["where"] = where;
      }

      if (columnDetail !== undefined) {
        localVarQueryParameter["columnDetail"] = columnDetail;
      }

      if (includeColumns !== undefined) {
        localVarQueryParameter["includeColumns"] = includeColumns;
      }

      if (columnNaturalOrder !== undefined) {
        localVarQueryParameter["columnNaturalOrder"] = columnNaturalOrder;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter["sortBy"] = sortBy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns content useful for populating prompts more effectively.
     * @summary Get prompt content from a data set
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} libref Specifies the libref for the request.
     * @param {string} tableName Specifies the table or data set to query.
     * @param {PromptContentRequest} promptContentRequest Specifies a prompt content creation request.
     * @param {number} [start] Specifies the offset of the first row to return.
     * @param {number} [limit] Specifies the maximum number of rows to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPromptContentWithRequest: async (
      sessionId: string,
      libref: string,
      tableName: string,
      promptContentRequest: PromptContentRequest,
      start?: number,
      limit?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getPromptContentWithRequest", "sessionId", sessionId);
      // verify required parameter 'libref' is not null or undefined
      assertParamExists("getPromptContentWithRequest", "libref", libref);
      // verify required parameter 'tableName' is not null or undefined
      assertParamExists("getPromptContentWithRequest", "tableName", tableName);
      // verify required parameter 'promptContentRequest' is not null or undefined
      assertParamExists(
        "getPromptContentWithRequest",
        "promptContentRequest",
        promptContentRequest
      );
      const localVarPath =
        `/sessions/{sessionId}/data/{libref}/{tableName}/promptContent`
          .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
          .replace(`{${"libref"}}`, encodeURIComponent(String(libref)))
          .replace(`{${"tableName"}}`, encodeURIComponent(String(tableName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      localVarHeaderParameter["Content-Type"] =
        "application/vnd.sas.compute.data.table.prompt.content.request+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        promptContentRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a row set that is based on the specified table and an optional WHERE clause.
     * @summary Get a row set from a data set
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} libref Specifies the libref for the request.
     * @param {string} tableName Specifies the table or data set to query.
     * @param {string} [where] Specifies that a standard SAS WHERE clause was used to build the row set for this request.
     * @param {boolean} [format] Specifies whether to format the data in the cells.
     * @param {'names' | 'detail' | 'summary'} [columnDetail] Specifies the level of column information to return.
     * @param {string} [includeColumns] Specifies a comma-separated list of columns to include in a row set. If you do not specify a list, all columns are returned. The order of the column names in the list determines the order of cells of the row set.
     * @param {boolean} [columnNaturalOrder] When includeColumns is specified, a value of true for columnNatrualOrder specifies that the cells of the row set are returned in the order in which they occur in the data set instead of in the order that is specified by includeColumns.
     * @param {number} [start] Specifies the offset of the first row to return.
     * @param {number} [limit] Specifies the maximum number of rows to return.
     * @param {string} [sortBy] Sets the sort order for the returned row set.
     * @param {boolean} [formatMissingValues] If set to true, SAS missing values found in the data will be formatted based on the setting of the SAS Option MISSING.   Otherwise, a NULL value will be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRowSet: async (
      sessionId: string,
      libref: string,
      tableName: string,
      where?: string,
      format?: boolean,
      columnDetail?: "names" | "detail" | "summary",
      includeColumns?: string,
      columnNaturalOrder?: boolean,
      start?: number,
      limit?: number,
      sortBy?: string,
      formatMissingValues?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getRowSet", "sessionId", sessionId);
      // verify required parameter 'libref' is not null or undefined
      assertParamExists("getRowSet", "libref", libref);
      // verify required parameter 'tableName' is not null or undefined
      assertParamExists("getRowSet", "tableName", tableName);
      const localVarPath =
        `/sessions/{sessionId}/data/{libref}/{tableName}/rowSet`
          .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
          .replace(`{${"libref"}}`, encodeURIComponent(String(libref)))
          .replace(`{${"tableName"}}`, encodeURIComponent(String(tableName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (where !== undefined) {
        localVarQueryParameter["where"] = where;
      }

      if (format !== undefined) {
        localVarQueryParameter["format"] = format;
      }

      if (columnDetail !== undefined) {
        localVarQueryParameter["columnDetail"] = columnDetail;
      }

      if (includeColumns !== undefined) {
        localVarQueryParameter["includeColumns"] = includeColumns;
      }

      if (columnNaturalOrder !== undefined) {
        localVarQueryParameter["columnNaturalOrder"] = columnNaturalOrder;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter["sortBy"] = sortBy;
      }

      if (formatMissingValues !== undefined) {
        localVarQueryParameter["formatMissingValues"] = formatMissingValues;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a row set that is based on the specified request body.
     * @summary Get a row set from a data set
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} libref Specifies the libref for the request.
     * @param {string} tableName Specifies the table or data set to query.
     * @param {RowSetRequest} rowSetRequest Specifies a row set creation request.
     * @param {boolean} [format] Specifies whether to format the data in the cells.
     * @param {number} [start] Specifies the offset of the first row to return.
     * @param {number} [limit] Specifies the maximum number of rows to return.
     * @param {boolean} [formatMissingValues] If set to true, SAS missing values found in the data will be formatted based on the setting of the SAS Option MISSING.   Otherwise, a NULL value will be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRowSetWithRequest: async (
      sessionId: string,
      libref: string,
      tableName: string,
      rowSetRequest: RowSetRequest,
      format?: boolean,
      start?: number,
      limit?: number,
      formatMissingValues?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getRowSetWithRequest", "sessionId", sessionId);
      // verify required parameter 'libref' is not null or undefined
      assertParamExists("getRowSetWithRequest", "libref", libref);
      // verify required parameter 'tableName' is not null or undefined
      assertParamExists("getRowSetWithRequest", "tableName", tableName);
      // verify required parameter 'rowSetRequest' is not null or undefined
      assertParamExists("getRowSetWithRequest", "rowSetRequest", rowSetRequest);
      const localVarPath =
        `/sessions/{sessionId}/data/{libref}/{tableName}/rowSet`
          .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
          .replace(`{${"libref"}}`, encodeURIComponent(String(libref)))
          .replace(`{${"tableName"}}`, encodeURIComponent(String(tableName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (format !== undefined) {
        localVarQueryParameter["format"] = format;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (formatMissingValues !== undefined) {
        localVarQueryParameter["formatMissingValues"] = formatMissingValues;
      }

      localVarHeaderParameter["Content-Type"] =
        "application/vnd.sas.compute.data.table.row.set.request+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        rowSetRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns the rows for a specified data set. By default, a collection is returned, and standard paging options are available.
     * @summary Get row information
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} libref Specifies the libref for the request.
     * @param {string} tableName Specifies the table or data set to query.
     * @param {number} [start] Specifies the offset of the first row to return.
     * @param {number} [limit] Specifies the maximum number of rows to return.
     * @param {boolean} [format] Specifies whether to format the data in the cells.
     * @param {boolean} [includeIndex] Specifies whether the first value in the cell is the index of the requested row. Support for this parameter was added in version 2.
     * @param {string} [where] Specifies that a standard SAS WHERE clause was used to return the rows for this request.
     * @param {boolean} [includeColumnNames] Specifies whether the first row that is returned consists of column names.
     * @param {boolean} [formatMissingValues] If set to true, SAS missing values found in the data will be formatted based on the setting of the SAS Option MISSING.   Otherwise, a NULL value will be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRows: async (
      sessionId: string,
      libref: string,
      tableName: string,
      start?: number,
      limit?: number,
      format?: boolean,
      includeIndex?: boolean,
      where?: string,
      includeColumnNames?: boolean,
      formatMissingValues?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getRows", "sessionId", sessionId);
      // verify required parameter 'libref' is not null or undefined
      assertParamExists("getRows", "libref", libref);
      // verify required parameter 'tableName' is not null or undefined
      assertParamExists("getRows", "tableName", tableName);
      const localVarPath =
        `/sessions/{sessionId}/data/{libref}/{tableName}/rows`
          .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
          .replace(`{${"libref"}}`, encodeURIComponent(String(libref)))
          .replace(`{${"tableName"}}`, encodeURIComponent(String(tableName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (format !== undefined) {
        localVarQueryParameter["format"] = format;
      }

      if (includeIndex !== undefined) {
        localVarQueryParameter["includeIndex"] = includeIndex;
      }

      if (where !== undefined) {
        localVarQueryParameter["where"] = where;
      }

      if (includeColumnNames !== undefined) {
        localVarQueryParameter["includeColumnNames"] = includeColumnNames;
      }

      if (formatMissingValues !== undefined) {
        localVarQueryParameter["formatMissingValues"] = formatMissingValues;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns rows in CSV format for a specified data set.
     * @summary Get row information as comma-separated values
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} libref Specifies the libref for the request.
     * @param {string} tableName Specifies the table or data set to query.
     * @param {number} [start] Specifies the offset of the first row to return.
     * @param {number} [limit] (Optional) Specifies the maximum number of rows to return. If not set, all rows are returned.
     * @param {boolean} [format] Specifies whether to format the data in the cells.
     * @param {boolean} [includeIndex] Specifies whether the first value in the cell is the index of the requested row. Support for this parameter was added in version 2.
     * @param {string} [where] Specifies that a standard SAS WHERE clause has been used to return the rows for this request.
     * @param {boolean} [includeColumnNames] Specifies whether the first row that is returned consists of column names.
     * @param {string} [columnSeparator] Specifies the character to use as the column separator. If no character is specified, a comma is used as the separator.
     * @param {string} [rowSeparator] Specifies the characters to use as the row separator. If no characters are specified, a line feed character (\\n) is used.
     * @param {boolean} [enableQuoting] Specifies whether values that contain special characters are quoted.
     * @param {boolean} [enableEscaping] Specifies whether special characters in values are escaped if the value is not quoted.
     * @param {boolean} [formatMissingValues] If set to true, SAS missing values found in the data will be formatted based on the setting of the SAS Option MISSING.   Otherwise, a NULL value will be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRowsAsCSV: async (
      sessionId: string,
      libref: string,
      tableName: string,
      start?: number,
      limit?: number,
      format?: boolean,
      includeIndex?: boolean,
      where?: string,
      includeColumnNames?: boolean,
      columnSeparator?: string,
      rowSeparator?: string,
      enableQuoting?: boolean,
      enableEscaping?: boolean,
      formatMissingValues?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getRowsAsCSV", "sessionId", sessionId);
      // verify required parameter 'libref' is not null or undefined
      assertParamExists("getRowsAsCSV", "libref", libref);
      // verify required parameter 'tableName' is not null or undefined
      assertParamExists("getRowsAsCSV", "tableName", tableName);
      const localVarPath =
        `/sessions/{sessionId}/data/{libref}/{tableName}/rows#CSV`
          .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
          .replace(`{${"libref"}}`, encodeURIComponent(String(libref)))
          .replace(`{${"tableName"}}`, encodeURIComponent(String(tableName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (format !== undefined) {
        localVarQueryParameter["format"] = format;
      }

      if (includeIndex !== undefined) {
        localVarQueryParameter["includeIndex"] = includeIndex;
      }

      if (where !== undefined) {
        localVarQueryParameter["where"] = where;
      }

      if (includeColumnNames !== undefined) {
        localVarQueryParameter["includeColumnNames"] = includeColumnNames;
      }

      if (columnSeparator !== undefined) {
        localVarQueryParameter["columnSeparator"] = columnSeparator;
      }

      if (rowSeparator !== undefined) {
        localVarQueryParameter["rowSeparator"] = rowSeparator;
      }

      if (enableQuoting !== undefined) {
        localVarQueryParameter["enableQuoting"] = enableQuoting;
      }

      if (enableEscaping !== undefined) {
        localVarQueryParameter["enableEscaping"] = enableEscaping;
      }

      if (formatMissingValues !== undefined) {
        localVarQueryParameter["formatMissingValues"] = formatMissingValues;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns the rows for a specified data set based on the submitted request body. By default, a collection is returned, and standard paging options are available.
     * @summary Obtain rows from a data set
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} libref Specifies the libref for the request.
     * @param {string} tableName Specifies the table or data set to query.
     * @param {RowsRequest} rowsRequest Specifies a row-generation request.
     * @param {number} [start] Specifies the offset of the first row to return.
     * @param {number} [limit] Specifies the maximum number of rows to return.
     * @param {boolean} [format] Specifies whether to format the data in the cells.
     * @param {boolean} [includeIndex] Specifies whether the first value in the cell is the index of a specific row. Support for this parameter was added in version 2.
     * @param {boolean} [formatMissingValues] If set to true, SAS missing values found in the data will be formatted based on the setting of the SAS Option MISSING.   Otherwise, a NULL value will be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRowsWithRequest: async (
      sessionId: string,
      libref: string,
      tableName: string,
      rowsRequest: RowsRequest,
      start?: number,
      limit?: number,
      format?: boolean,
      includeIndex?: boolean,
      formatMissingValues?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getRowsWithRequest", "sessionId", sessionId);
      // verify required parameter 'libref' is not null or undefined
      assertParamExists("getRowsWithRequest", "libref", libref);
      // verify required parameter 'tableName' is not null or undefined
      assertParamExists("getRowsWithRequest", "tableName", tableName);
      // verify required parameter 'rowsRequest' is not null or undefined
      assertParamExists("getRowsWithRequest", "rowsRequest", rowsRequest);
      const localVarPath =
        `/sessions/{sessionId}/data/{libref}/{tableName}/rows`
          .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
          .replace(`{${"libref"}}`, encodeURIComponent(String(libref)))
          .replace(`{${"tableName"}}`, encodeURIComponent(String(tableName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (format !== undefined) {
        localVarQueryParameter["format"] = format;
      }

      if (includeIndex !== undefined) {
        localVarQueryParameter["includeIndex"] = includeIndex;
      }

      if (formatMissingValues !== undefined) {
        localVarQueryParameter["formatMissingValues"] = formatMissingValues;
      }

      localVarHeaderParameter["Content-Type"] =
        "application/vnd.sas.compute.data.table.rows.request+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        rowsRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns information about a data set.
     * @summary Get a data set
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} libref Specifies the libref for the request.
     * @param {string} tableName Specifies the table or data set to query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTable: async (
      sessionId: string,
      libref: string,
      tableName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getTable", "sessionId", sessionId);
      // verify required parameter 'libref' is not null or undefined
      assertParamExists("getTable", "libref", libref);
      // verify required parameter 'tableName' is not null or undefined
      assertParamExists("getTable", "tableName", tableName);
      const localVarPath = `/sessions/{sessionId}/data/{libref}/{tableName}`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"libref"}}`, encodeURIComponent(String(libref)))
        .replace(`{${"tableName"}}`, encodeURIComponent(String(tableName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns summary information about a data set.
     * @summary Get a summary of a data set
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} libref Specifies the libref for the request.
     * @param {string} tableName Specifies the table or data set to query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTableSummary: async (
      sessionId: string,
      libref: string,
      tableName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getTableSummary", "sessionId", sessionId);
      // verify required parameter 'libref' is not null or undefined
      assertParamExists("getTableSummary", "libref", libref);
      // verify required parameter 'tableName' is not null or undefined
      assertParamExists("getTableSummary", "tableName", tableName);
      const localVarPath =
        `/sessions/{sessionId}/data/{libref}/{tableName}#summary`
          .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
          .replace(`{${"libref"}}`, encodeURIComponent(String(libref)))
          .replace(`{${"tableName"}}`, encodeURIComponent(String(tableName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a collection of data sets that are associated with a specified libref. Set the Accept header on this method to application/vnd.sas.collection+json. The collection contains application/vnd.sas.compute.data.table.summary items.  Standard paging options are provided.
     * @summary Get data sets in a libref
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} libref Specifies the libref to query.
     * @param {'application/vnd.sas.compute.data.table+json'} [acceptItem] Specifies the desired data table representation.&lt;br&gt; The Accept-Item options are: &lt;ul&gt; &lt;li&gt;application/vnd.sas.compute.data.table+json &lt;li&gt;application/vnd.sas.compute.data.table.summary+json &lt;li&gt;blank &lt;/ul&gt; If the application/vnd.sas.compute.data.table.summary+json type is specified or no Accept-Item header is specified, then the data tables are returned as summary representation data table objects.
     * @param {number} [start] Specifies the offset of the first table summary to return.
     * @param {number} [limit] Specifies the maximum number of table summaries to return.
     * @param {boolean} [noCache] Specifies whether to force the table collection to be refreshed before it is returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTables: async (
      sessionId: string,
      libref: string,
      acceptItem?: "application/vnd.sas.compute.data.table+json",
      start?: number,
      limit?: number,
      noCache?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getTables", "sessionId", sessionId);
      // verify required parameter 'libref' is not null or undefined
      assertParamExists("getTables", "libref", libref);
      const localVarPath = `/sessions/{sessionId}/data/{libref}#tables`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"libref"}}`, encodeURIComponent(String(libref)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (noCache !== undefined) {
        localVarQueryParameter["noCache"] = noCache;
      }

      if (acceptItem != null) {
        localVarHeaderParameter["Accept-Item"] = String(acceptItem);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether a specified data set has access to a column.
     * @summary Check for a column in a table
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} libref Specifies the libref for the request.
     * @param {string} tableName Specifies the table or data set to query.
     * @param {string} columnName Specifies the column name to check.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForColumn: async (
      sessionId: string,
      libref: string,
      tableName: string,
      columnName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForColumn", "sessionId", sessionId);
      // verify required parameter 'libref' is not null or undefined
      assertParamExists("headersForColumn", "libref", libref);
      // verify required parameter 'tableName' is not null or undefined
      assertParamExists("headersForColumn", "tableName", tableName);
      // verify required parameter 'columnName' is not null or undefined
      assertParamExists("headersForColumn", "columnName", columnName);
      const localVarPath =
        `/sessions/{sessionId}/data/{libref}/{tableName}/columns/{columnName}`
          .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
          .replace(`{${"libref"}}`, encodeURIComponent(String(libref)))
          .replace(`{${"tableName"}}`, encodeURIComponent(String(tableName)))
          .replace(`{${"columnName"}}`, encodeURIComponent(String(columnName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether the specified data set has access to columns.
     * @summary Check for available columns in a table
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} libref Specifies the libref for the request.
     * @param {string} tableName Specifies the table or data set to query.
     * @param {number} [start] Specifies the offset of the first column entry to return.
     * @param {number} [limit] Specifies the maximum number of columns to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForColumns: async (
      sessionId: string,
      libref: string,
      tableName: string,
      start?: number,
      limit?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForColumns", "sessionId", sessionId);
      // verify required parameter 'libref' is not null or undefined
      assertParamExists("headersForColumns", "libref", libref);
      // verify required parameter 'tableName' is not null or undefined
      assertParamExists("headersForColumns", "tableName", tableName);
      const localVarPath =
        `/sessions/{sessionId}/data/{libref}/{tableName}/columns`
          .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
          .replace(`{${"libref"}}`, encodeURIComponent(String(libref)))
          .replace(`{${"tableName"}}`, encodeURIComponent(String(tableName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether the specified libref exists in a session.
     * @summary Verify that a libref exists
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} libref Specifies the libref to query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForLibrary: async (
      sessionId: string,
      libref: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForLibrary", "sessionId", sessionId);
      // verify required parameter 'libref' is not null or undefined
      assertParamExists("headersForLibrary", "libref", libref);
      const localVarPath = `/sessions/{sessionId}/data/{libref}`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"libref"}}`, encodeURIComponent(String(libref)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines headers for prompt content for a given data set.
     * @summary Check prompt content availability
     * @param {string} sessionId Specifies the ID of the session
     * @param {string} libref Specifies the libref for the request.
     * @param {string} tableName Specifies the table or data set to query.
     * @param {string} [where] Specifies that a standard SAS WHERE clause was used to build the content for this request.
     * @param {'names' | 'detail' | 'summary'} [columnDetail] Specifies the level of column information to return.
     * @param {string} [includeColumns] Specifies a comma separated list of columns to include in the returned content. If you do not specify a list, all columns are returned. The order of the column names in the list is the order in which the cells of the content are in as well.
     * @param {boolean} [columnNaturalOrder] When includeColumns is specified, a value of true for columnNatrualOrder specifies that the cells of the returned content are returned in the order in which they occur in the data set instead of in the order that is specified by includeColumns.
     * @param {number} [start] Specifies the offset of the first row to return. The default value is \&quot;0\&quot;.
     * @param {number} [limit] Specifies the maximum number of rows to return. The default value is \&quot;10\&quot;.
     * @param {string} [sortBy] Sets the sort order for the returned prompt content.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForPromptContent: async (
      sessionId: string,
      libref: string,
      tableName: string,
      where?: string,
      columnDetail?: "names" | "detail" | "summary",
      includeColumns?: string,
      columnNaturalOrder?: boolean,
      start?: number,
      limit?: number,
      sortBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForPromptContent", "sessionId", sessionId);
      // verify required parameter 'libref' is not null or undefined
      assertParamExists("headersForPromptContent", "libref", libref);
      // verify required parameter 'tableName' is not null or undefined
      assertParamExists("headersForPromptContent", "tableName", tableName);
      const localVarPath =
        `/sessions/{sessionId}/data/{libref}/{tableName}/promptContent`
          .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
          .replace(`{${"libref"}}`, encodeURIComponent(String(libref)))
          .replace(`{${"tableName"}}`, encodeURIComponent(String(tableName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (where !== undefined) {
        localVarQueryParameter["where"] = where;
      }

      if (columnDetail !== undefined) {
        localVarQueryParameter["columnDetail"] = columnDetail;
      }

      if (includeColumns !== undefined) {
        localVarQueryParameter["includeColumns"] = includeColumns;
      }

      if (columnNaturalOrder !== undefined) {
        localVarQueryParameter["columnNaturalOrder"] = columnNaturalOrder;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter["sortBy"] = sortBy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether a data set has access to a specific row.
     * @summary Check row availability
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} libref Specifies the libref for the request.
     * @param {string} tableName Specifies the table or data set to query.
     * @param {number} [start] Specifies the offset of the first row to return.
     * @param {number} [limit] Specifies the maximum number of rows to return.
     * @param {boolean} [format] Specifies whether to format the data in the cells.
     * @param {boolean} [includeIndex] Specifies whether the first value in the cell is the index of the requested row. Support for this parameter was added in version 2.
     * @param {string} [where] Specifies that a standard SAS WHERE clause was used to return the rows for this request.
     * @param {boolean} [includeColumnNames] Specifies whether the first row that is returned consists of column names.
     * @param {boolean} [formatMissingValues] If set to true, SAS missing values found in the data will be formatted based on the setting of the SAS Option MISSING.   Otherwise, a NULL value will be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForRow: async (
      sessionId: string,
      libref: string,
      tableName: string,
      start?: number,
      limit?: number,
      format?: boolean,
      includeIndex?: boolean,
      where?: string,
      includeColumnNames?: boolean,
      formatMissingValues?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForRow", "sessionId", sessionId);
      // verify required parameter 'libref' is not null or undefined
      assertParamExists("headersForRow", "libref", libref);
      // verify required parameter 'tableName' is not null or undefined
      assertParamExists("headersForRow", "tableName", tableName);
      const localVarPath =
        `/sessions/{sessionId}/data/{libref}/{tableName}/rows`
          .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
          .replace(`{${"libref"}}`, encodeURIComponent(String(libref)))
          .replace(`{${"tableName"}}`, encodeURIComponent(String(tableName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (format !== undefined) {
        localVarQueryParameter["format"] = format;
      }

      if (includeIndex !== undefined) {
        localVarQueryParameter["includeIndex"] = includeIndex;
      }

      if (where !== undefined) {
        localVarQueryParameter["where"] = where;
      }

      if (includeColumnNames !== undefined) {
        localVarQueryParameter["includeColumnNames"] = includeColumnNames;
      }

      if (formatMissingValues !== undefined) {
        localVarQueryParameter["formatMissingValues"] = formatMissingValues;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether a row set is available on for a data set.
     * @summary Check row set availability
     * @param {string} sessionId Specifies the ID of the session
     * @param {string} libref Specifies the libref for the request.
     * @param {string} tableName Specifies the table or data set to query.
     * @param {string} [where] Specifies that a standard SAS WHERE clause was used to build the row set for this request.
     * @param {boolean} [format] Specifies whether to format the data in the cells.
     * @param {'names' | 'detail' | 'summary'} [columnDetail] Specifies the level of column information to return.
     * @param {string} [includeColumns] Specifies a comma separated list of columns to include in the row set. If you do not specify a list, all columns are returned. The order of the column names in the list is the order in which the cells of the row set are in as well.
     * @param {boolean} [columnNaturalOrder] When includeColumns is specified, a value of true for columnNatrualOrder specifies that the cells of the row set are returned in the order in which they occur in the data set instead of in the order that is specified by includeColumns.
     * @param {number} [start] Specifies the offset of the first row to return. The default value is \&quot;0\&quot;.
     * @param {number} [limit] Specifies the maximum number of rows to return. The default value is \&quot;10\&quot;.
     * @param {string} [sortBy] Sets the sort order for the returned row set.
     * @param {boolean} [formatMissingValues] If set to true, SAS missing values found in the data will be formatted based on the setting of the SAS Option MISSING.   Otherwise, a NULL value will be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForRowSet: async (
      sessionId: string,
      libref: string,
      tableName: string,
      where?: string,
      format?: boolean,
      columnDetail?: "names" | "detail" | "summary",
      includeColumns?: string,
      columnNaturalOrder?: boolean,
      start?: number,
      limit?: number,
      sortBy?: string,
      formatMissingValues?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForRowSet", "sessionId", sessionId);
      // verify required parameter 'libref' is not null or undefined
      assertParamExists("headersForRowSet", "libref", libref);
      // verify required parameter 'tableName' is not null or undefined
      assertParamExists("headersForRowSet", "tableName", tableName);
      const localVarPath =
        `/sessions/{sessionId}/data/{libref}/{tableName}/rowSet`
          .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
          .replace(`{${"libref"}}`, encodeURIComponent(String(libref)))
          .replace(`{${"tableName"}}`, encodeURIComponent(String(tableName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (where !== undefined) {
        localVarQueryParameter["where"] = where;
      }

      if (format !== undefined) {
        localVarQueryParameter["format"] = format;
      }

      if (columnDetail !== undefined) {
        localVarQueryParameter["columnDetail"] = columnDetail;
      }

      if (includeColumns !== undefined) {
        localVarQueryParameter["includeColumns"] = includeColumns;
      }

      if (columnNaturalOrder !== undefined) {
        localVarQueryParameter["columnNaturalOrder"] = columnNaturalOrder;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter["sortBy"] = sortBy;
      }

      if (formatMissingValues !== undefined) {
        localVarQueryParameter["formatMissingValues"] = formatMissingValues;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns the headers for rows in CSV format for a specified data set.
     * @summary Get headers for rows represented as comma-separated values
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} libref Specifies the libref for the request.
     * @param {string} tableName Specifies the table or data set to query.
     * @param {number} [start] Specifies the offset of the first row to return.
     * @param {number} [limit] (Optional) Specifies the maximum number of rows to return. If not set, all rows are returned.
     * @param {boolean} [format] Specifies whether to format the data in the cells.
     * @param {boolean} [includeIndex] Specifies whether the first value in the cell is the index of the requested row. Support for this parameter was added in version 2.
     * @param {string} [where] Specifies that a standard SAS WHERE clause was used to return the rows for this request.
     * @param {boolean} [includeColumnNames] Specifies whether the first row that is returned consists of column names.
     * @param {string} [columnSeparator] Specifies the character to use as the column separator. If no character is specified, a comma is used as the separator.
     * @param {string} [rowSeparator] Specifies the characters to use as the row separator. If no characters are specified, a line feed character (\\n) is used.
     * @param {boolean} [enableQuoting] Specifies whether values that contain special characters are quoted.
     * @param {boolean} [enableEscaping] Specifies whether special characters in values are escaped if the values are not quoted.
     * @param {boolean} [formatMissingValues] If set to true, SAS missing values found in the data will be formatted based on the setting of the SAS Option MISSING.   Otherwise, a NULL value will be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForRowsAsCSV: async (
      sessionId: string,
      libref: string,
      tableName: string,
      start?: number,
      limit?: number,
      format?: boolean,
      includeIndex?: boolean,
      where?: string,
      includeColumnNames?: boolean,
      columnSeparator?: string,
      rowSeparator?: string,
      enableQuoting?: boolean,
      enableEscaping?: boolean,
      formatMissingValues?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForRowsAsCSV", "sessionId", sessionId);
      // verify required parameter 'libref' is not null or undefined
      assertParamExists("headersForRowsAsCSV", "libref", libref);
      // verify required parameter 'tableName' is not null or undefined
      assertParamExists("headersForRowsAsCSV", "tableName", tableName);
      const localVarPath =
        `/sessions/{sessionId}/data/{libref}/{tableName}/rows#CSV`
          .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
          .replace(`{${"libref"}}`, encodeURIComponent(String(libref)))
          .replace(`{${"tableName"}}`, encodeURIComponent(String(tableName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (format !== undefined) {
        localVarQueryParameter["format"] = format;
      }

      if (includeIndex !== undefined) {
        localVarQueryParameter["includeIndex"] = includeIndex;
      }

      if (where !== undefined) {
        localVarQueryParameter["where"] = where;
      }

      if (includeColumnNames !== undefined) {
        localVarQueryParameter["includeColumnNames"] = includeColumnNames;
      }

      if (columnSeparator !== undefined) {
        localVarQueryParameter["columnSeparator"] = columnSeparator;
      }

      if (rowSeparator !== undefined) {
        localVarQueryParameter["rowSeparator"] = rowSeparator;
      }

      if (enableQuoting !== undefined) {
        localVarQueryParameter["enableQuoting"] = enableQuoting;
      }

      if (enableEscaping !== undefined) {
        localVarQueryParameter["enableEscaping"] = enableEscaping;
      }

      if (formatMissingValues !== undefined) {
        localVarQueryParameter["formatMissingValues"] = formatMissingValues;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether a session has a data endpoint available.
     * @summary Check access to data for a session
     * @param {string} sessionId Specifies the ID of the session.
     * @param {number} [start] Specifies the offset of the first library to return.
     * @param {number} [limit] Specifies the maximum number of libraries to return.
     * @param {boolean} [noCache] Specifies whether to force the library collection to be refreshed before it is returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForSessionLibraries: async (
      sessionId: string,
      start?: number,
      limit?: number,
      noCache?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForSessionLibraries", "sessionId", sessionId);
      const localVarPath = `/sessions/{sessionId}/data`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (noCache !== undefined) {
        localVarQueryParameter["noCache"] = noCache;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether the specified data set exists in a libref.
     * @summary Check for a data set in a libref
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} libref Specifies the libref for the request.
     * @param {string} tableName Specifies the table or data set to query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForTable: async (
      sessionId: string,
      libref: string,
      tableName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForTable", "sessionId", sessionId);
      // verify required parameter 'libref' is not null or undefined
      assertParamExists("headersForTable", "libref", libref);
      // verify required parameter 'tableName' is not null or undefined
      assertParamExists("headersForTable", "tableName", tableName);
      const localVarPath = `/sessions/{sessionId}/data/{libref}/{tableName}`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"libref"}}`, encodeURIComponent(String(libref)))
        .replace(`{${"tableName"}}`, encodeURIComponent(String(tableName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates the name, label, format, or informat information for a specified column.
     * @summary Update column information
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} libref Specifies the libref for the request.
     * @param {string} tableName Specifies the table that contains the column to update.
     * @param {string} columnName Specifies the column name to update.
     * @param {string} ifMatch Specifies the ETag of the column that you are updating.
     * @param {Column} column Specifies the information to update for the column.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateColumn: async (
      sessionId: string,
      libref: string,
      tableName: string,
      columnName: string,
      ifMatch: string,
      column: Column,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("updateColumn", "sessionId", sessionId);
      // verify required parameter 'libref' is not null or undefined
      assertParamExists("updateColumn", "libref", libref);
      // verify required parameter 'tableName' is not null or undefined
      assertParamExists("updateColumn", "tableName", tableName);
      // verify required parameter 'columnName' is not null or undefined
      assertParamExists("updateColumn", "columnName", columnName);
      // verify required parameter 'ifMatch' is not null or undefined
      assertParamExists("updateColumn", "ifMatch", ifMatch);
      // verify required parameter 'column' is not null or undefined
      assertParamExists("updateColumn", "column", column);
      const localVarPath =
        `/sessions/{sessionId}/data/{libref}/{tableName}/columns/{columnName}`
          .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
          .replace(`{${"libref"}}`, encodeURIComponent(String(libref)))
          .replace(`{${"tableName"}}`, encodeURIComponent(String(tableName)))
          .replace(`{${"columnName"}}`, encodeURIComponent(String(columnName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (ifMatch != null) {
        localVarHeaderParameter["If-Match"] = String(ifMatch);
      }

      localVarHeaderParameter["Content-Type"] =
        "application/vnd.sas.compute.data.table.column+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        column,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates the name or label of the specified table.
     * @summary Update table information
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} libref Specifies the libref for the request.
     * @param {string} tableName Specifies the table or data set to update.
     * @param {string} ifMatch Specifies the ETag of the table that you are updating.
     * @param {TableInfo} tableInfo Specifies the information to update for the table.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTable: async (
      sessionId: string,
      libref: string,
      tableName: string,
      ifMatch: string,
      tableInfo: TableInfo,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("updateTable", "sessionId", sessionId);
      // verify required parameter 'libref' is not null or undefined
      assertParamExists("updateTable", "libref", libref);
      // verify required parameter 'tableName' is not null or undefined
      assertParamExists("updateTable", "tableName", tableName);
      // verify required parameter 'ifMatch' is not null or undefined
      assertParamExists("updateTable", "ifMatch", ifMatch);
      // verify required parameter 'tableInfo' is not null or undefined
      assertParamExists("updateTable", "tableInfo", tableInfo);
      const localVarPath = `/sessions/{sessionId}/data/{libref}/{tableName}`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"libref"}}`, encodeURIComponent(String(libref)))
        .replace(`{${"tableName"}}`, encodeURIComponent(String(tableName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (ifMatch != null) {
        localVarHeaderParameter["If-Match"] = String(ifMatch);
      }

      localVarHeaderParameter["Content-Type"] =
        "application/vnd.sas.compute.data.table+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        tableInfo,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DataAccessApi - functional programming interface
 * @export
 */
export const DataAccessApi = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    DataAccessApiAxiosParamCreator(configuration);
  return {
    /**
     * Assigns a libref that is based on the request body for a session. The Location header contains the URI of the libref resource.
     * @summary Assign a libref
     * @param {DataAccessApiCreateLibraryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createLibrary(
      requestParameters: DataAccessApiCreateLibraryRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createLibrary(
        requestParameters.sessionId,
        requestParameters.libraryRequest,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns a view of the specified data set. The request body that you provide controls the view that is created. You can then access the returned view as a table.
     * @summary Create a data set view
     * @param {DataAccessApiCreateViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createView(
      requestParameters: DataAccessApiCreateViewRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<TableInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createView(
        requestParameters.sessionId,
        requestParameters.libref,
        requestParameters.tableName,
        requestParameters.viewRequest,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Removes the libref from the session.
     * @summary Deassign libref
     * @param {DataAccessApiDeleteLibraryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteLibrary(
      requestParameters: DataAccessApiDeleteLibraryRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLibrary(
        requestParameters.sessionId,
        requestParameters.libref,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Deletes a table or view. If you request to delete a table and you have proper permissions, then the data set is deleted. If you request to delete a view, then the view is destroyed.
     * @summary Delete a table or view
     * @param {DataAccessApiDeleteTableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTable(
      requestParameters: DataAccessApiDeleteTableRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTable(
        requestParameters.sessionId,
        requestParameters.libref,
        requestParameters.tableName,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Gets a specific column from a data set.
     * @summary Get a column
     * @param {DataAccessApiGetColumnRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getColumn(
      requestParameters: DataAccessApiGetColumnRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<Column>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getColumn(
        requestParameters.sessionId,
        requestParameters.libref,
        requestParameters.tableName,
        requestParameters.columnName,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns the column information for a specified data set. By default, a collection is returned, and standard paging options are available.
     * @summary Get column information
     * @param {DataAccessApiGetColumnsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getColumns(
      requestParameters: DataAccessApiGetColumnsRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<ColumnCollection>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getColumns(
        requestParameters.sessionId,
        requestParameters.libref,
        requestParameters.tableName,
        requestParameters.start,
        requestParameters.limit,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns the column information for a specified data set based on the submitted request body. By default, a collection is returned, and standard paging options are available.
     * @summary Retrieve column information
     * @param {DataAccessApiGetColumnsWithRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getColumnsWithRequest(
      requestParameters: DataAccessApiGetColumnsWithRequestRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<ColumnCollection>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getColumnsWithRequest(
          requestParameters.sessionId,
          requestParameters.libref,
          requestParameters.tableName,
          requestParameters.start,
          requestParameters.limit,
          requestParameters.columnsRequest,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Provides a listing that contains summaries of the libraries that are defined in the current session.
     * @summary Return libraries in a session
     * @param {DataAccessApiGetLibrariesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLibraries(
      requestParameters: DataAccessApiGetLibrariesRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<LibrarySummaryCollection>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLibraries(
        requestParameters.sessionId,
        requestParameters.acceptItem,
        requestParameters.start,
        requestParameters.limit,
        requestParameters.noCache,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Retrieves information about a specified libref, including links to tables.
     * @summary Get libref information
     * @param {DataAccessApiGetLibraryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLibrary(
      requestParameters: DataAccessApiGetLibraryRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<Library>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLibrary(
        requestParameters.sessionId,
        requestParameters.libref,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns summary information about a specified libref.
     * @summary Get libref summary
     * @param {DataAccessApiGetLibrarySummaryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLibrarySummary(
      requestParameters: DataAccessApiGetLibrarySummaryRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<LibrarySummary>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getLibrarySummary(
          requestParameters.sessionId,
          requestParameters.libref,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns content useful for populating prompts more effectively.
     * @summary Get prompt content from a data set
     * @param {DataAccessApiGetPromptContentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPromptContent(
      requestParameters: DataAccessApiGetPromptContentRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<PromptContent>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPromptContent(
          requestParameters.sessionId,
          requestParameters.libref,
          requestParameters.tableName,
          requestParameters.where,
          requestParameters.columnDetail,
          requestParameters.includeColumns,
          requestParameters.columnNaturalOrder,
          requestParameters.start,
          requestParameters.limit,
          requestParameters.sortBy,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns content useful for populating prompts more effectively.
     * @summary Get prompt content from a data set
     * @param {DataAccessApiGetPromptContentWithRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPromptContentWithRequest(
      requestParameters: DataAccessApiGetPromptContentWithRequestRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<PromptContent>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPromptContentWithRequest(
          requestParameters.sessionId,
          requestParameters.libref,
          requestParameters.tableName,
          requestParameters.promptContentRequest,
          requestParameters.start,
          requestParameters.limit,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns a row set that is based on the specified table and an optional WHERE clause.
     * @summary Get a row set from a data set
     * @param {DataAccessApiGetRowSetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRowSet(
      requestParameters: DataAccessApiGetRowSetRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<RowSet>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRowSet(
        requestParameters.sessionId,
        requestParameters.libref,
        requestParameters.tableName,
        requestParameters.where,
        requestParameters.format,
        requestParameters.columnDetail,
        requestParameters.includeColumns,
        requestParameters.columnNaturalOrder,
        requestParameters.start,
        requestParameters.limit,
        requestParameters.sortBy,
        requestParameters.formatMissingValues,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns a row set that is based on the specified request body.
     * @summary Get a row set from a data set
     * @param {DataAccessApiGetRowSetWithRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRowSetWithRequest(
      requestParameters: DataAccessApiGetRowSetWithRequestRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<RowSet>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRowSetWithRequest(
          requestParameters.sessionId,
          requestParameters.libref,
          requestParameters.tableName,
          requestParameters.rowSetRequest,
          requestParameters.format,
          requestParameters.start,
          requestParameters.limit,
          requestParameters.formatMissingValues,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns the rows for a specified data set. By default, a collection is returned, and standard paging options are available.
     * @summary Get row information
     * @param {DataAccessApiGetRowsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRows(
      requestParameters: DataAccessApiGetRowsRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<RowCollection>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRows(
        requestParameters.sessionId,
        requestParameters.libref,
        requestParameters.tableName,
        requestParameters.start,
        requestParameters.limit,
        requestParameters.format,
        requestParameters.includeIndex,
        requestParameters.where,
        requestParameters.includeColumnNames,
        requestParameters.formatMissingValues,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns rows in CSV format for a specified data set.
     * @summary Get row information as comma-separated values
     * @param {DataAccessApiGetRowsAsCSVRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRowsAsCSV(
      requestParameters: DataAccessApiGetRowsAsCSVRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRowsAsCSV(
        requestParameters.sessionId,
        requestParameters.libref,
        requestParameters.tableName,
        requestParameters.start,
        requestParameters.limit,
        requestParameters.format,
        requestParameters.includeIndex,
        requestParameters.where,
        requestParameters.includeColumnNames,
        requestParameters.columnSeparator,
        requestParameters.rowSeparator,
        requestParameters.enableQuoting,
        requestParameters.enableEscaping,
        requestParameters.formatMissingValues,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns the rows for a specified data set based on the submitted request body. By default, a collection is returned, and standard paging options are available.
     * @summary Obtain rows from a data set
     * @param {DataAccessApiGetRowsWithRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRowsWithRequest(
      requestParameters: DataAccessApiGetRowsWithRequestRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<RowCollection>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRowsWithRequest(
          requestParameters.sessionId,
          requestParameters.libref,
          requestParameters.tableName,
          requestParameters.rowsRequest,
          requestParameters.start,
          requestParameters.limit,
          requestParameters.format,
          requestParameters.includeIndex,
          requestParameters.formatMissingValues,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns information about a data set.
     * @summary Get a data set
     * @param {DataAccessApiGetTableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTable(
      requestParameters: DataAccessApiGetTableRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<TableInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTable(
        requestParameters.sessionId,
        requestParameters.libref,
        requestParameters.tableName,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns summary information about a data set.
     * @summary Get a summary of a data set
     * @param {DataAccessApiGetTableSummaryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTableSummary(
      requestParameters: DataAccessApiGetTableSummaryRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<TableSummary>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTableSummary(
        requestParameters.sessionId,
        requestParameters.libref,
        requestParameters.tableName,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns a collection of data sets that are associated with a specified libref. Set the Accept header on this method to application/vnd.sas.collection+json. The collection contains application/vnd.sas.compute.data.table.summary items.  Standard paging options are provided.
     * @summary Get data sets in a libref
     * @param {DataAccessApiGetTablesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTables(
      requestParameters: DataAccessApiGetTablesRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<TableSummaryCollection>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTables(
        requestParameters.sessionId,
        requestParameters.libref,
        requestParameters.acceptItem,
        requestParameters.start,
        requestParameters.limit,
        requestParameters.noCache,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether a specified data set has access to a column.
     * @summary Check for a column in a table
     * @param {DataAccessApiHeadersForColumnRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForColumn(
      requestParameters: DataAccessApiHeadersForColumnRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForColumn(
          requestParameters.sessionId,
          requestParameters.libref,
          requestParameters.tableName,
          requestParameters.columnName,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether the specified data set has access to columns.
     * @summary Check for available columns in a table
     * @param {DataAccessApiHeadersForColumnsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForColumns(
      requestParameters: DataAccessApiHeadersForColumnsRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForColumns(
          requestParameters.sessionId,
          requestParameters.libref,
          requestParameters.tableName,
          requestParameters.start,
          requestParameters.limit,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether the specified libref exists in a session.
     * @summary Verify that a libref exists
     * @param {DataAccessApiHeadersForLibraryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForLibrary(
      requestParameters: DataAccessApiHeadersForLibraryRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForLibrary(
          requestParameters.sessionId,
          requestParameters.libref,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines headers for prompt content for a given data set.
     * @summary Check prompt content availability
     * @param {DataAccessApiHeadersForPromptContentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForPromptContent(
      requestParameters: DataAccessApiHeadersForPromptContentRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForPromptContent(
          requestParameters.sessionId,
          requestParameters.libref,
          requestParameters.tableName,
          requestParameters.where,
          requestParameters.columnDetail,
          requestParameters.includeColumns,
          requestParameters.columnNaturalOrder,
          requestParameters.start,
          requestParameters.limit,
          requestParameters.sortBy,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether a data set has access to a specific row.
     * @summary Check row availability
     * @param {DataAccessApiHeadersForRowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForRow(
      requestParameters: DataAccessApiHeadersForRowRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.headersForRow(
        requestParameters.sessionId,
        requestParameters.libref,
        requestParameters.tableName,
        requestParameters.start,
        requestParameters.limit,
        requestParameters.format,
        requestParameters.includeIndex,
        requestParameters.where,
        requestParameters.includeColumnNames,
        requestParameters.formatMissingValues,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether a row set is available on for a data set.
     * @summary Check row set availability
     * @param {DataAccessApiHeadersForRowSetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForRowSet(
      requestParameters: DataAccessApiHeadersForRowSetRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForRowSet(
          requestParameters.sessionId,
          requestParameters.libref,
          requestParameters.tableName,
          requestParameters.where,
          requestParameters.format,
          requestParameters.columnDetail,
          requestParameters.includeColumns,
          requestParameters.columnNaturalOrder,
          requestParameters.start,
          requestParameters.limit,
          requestParameters.sortBy,
          requestParameters.formatMissingValues,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns the headers for rows in CSV format for a specified data set.
     * @summary Get headers for rows represented as comma-separated values
     * @param {DataAccessApiHeadersForRowsAsCSVRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForRowsAsCSV(
      requestParameters: DataAccessApiHeadersForRowsAsCSVRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForRowsAsCSV(
          requestParameters.sessionId,
          requestParameters.libref,
          requestParameters.tableName,
          requestParameters.start,
          requestParameters.limit,
          requestParameters.format,
          requestParameters.includeIndex,
          requestParameters.where,
          requestParameters.includeColumnNames,
          requestParameters.columnSeparator,
          requestParameters.rowSeparator,
          requestParameters.enableQuoting,
          requestParameters.enableEscaping,
          requestParameters.formatMissingValues,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether a session has a data endpoint available.
     * @summary Check access to data for a session
     * @param {DataAccessApiHeadersForSessionLibrariesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForSessionLibraries(
      requestParameters: DataAccessApiHeadersForSessionLibrariesRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForSessionLibraries(
          requestParameters.sessionId,
          requestParameters.start,
          requestParameters.limit,
          requestParameters.noCache,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether the specified data set exists in a libref.
     * @summary Check for a data set in a libref
     * @param {DataAccessApiHeadersForTableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForTable(
      requestParameters: DataAccessApiHeadersForTableRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.headersForTable(
        requestParameters.sessionId,
        requestParameters.libref,
        requestParameters.tableName,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Updates the name, label, format, or informat information for a specified column.
     * @summary Update column information
     * @param {DataAccessApiUpdateColumnRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateColumn(
      requestParameters: DataAccessApiUpdateColumnRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<Column>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateColumn(
        requestParameters.sessionId,
        requestParameters.libref,
        requestParameters.tableName,
        requestParameters.columnName,
        requestParameters.ifMatch,
        requestParameters.column,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Updates the name or label of the specified table.
     * @summary Update table information
     * @param {DataAccessApiUpdateTableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateTable(
      requestParameters: DataAccessApiUpdateTableRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<TableInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateTable(
        requestParameters.sessionId,
        requestParameters.libref,
        requestParameters.tableName,
        requestParameters.ifMatch,
        requestParameters.tableInfo,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },
  };
};

/**
 * Request parameters for createLibrary operation in DataAccessApi.
 * @export
 * @interface DataAccessApiCreateLibraryRequest
 */
export interface DataAccessApiCreateLibraryRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof DataAccessApiCreateLibrary
   */
  readonly sessionId: string;

  /**
   * Specifies a libref assignment request.
   * @type {LibraryRequest}
   * @memberof DataAccessApiCreateLibrary
   */
  readonly libraryRequest: LibraryRequest;
}

/**
 * Request parameters for createView operation in DataAccessApi.
 * @export
 * @interface DataAccessApiCreateViewRequest
 */
export interface DataAccessApiCreateViewRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof DataAccessApiCreateView
   */
  readonly sessionId: string;

  /**
   * Specifies the libref for the request.
   * @type {string}
   * @memberof DataAccessApiCreateView
   */
  readonly libref: string;

  /**
   * Specifies the table or data set to query.
   * @type {string}
   * @memberof DataAccessApiCreateView
   */
  readonly tableName: string;

  /**
   * Specifies a view creation request.
   * @type {ViewRequest}
   * @memberof DataAccessApiCreateView
   */
  readonly viewRequest: ViewRequest;
}

/**
 * Request parameters for deleteLibrary operation in DataAccessApi.
 * @export
 * @interface DataAccessApiDeleteLibraryRequest
 */
export interface DataAccessApiDeleteLibraryRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof DataAccessApiDeleteLibrary
   */
  readonly sessionId: string;

  /**
   * Specifies the libref to deassign.
   * @type {string}
   * @memberof DataAccessApiDeleteLibrary
   */
  readonly libref: string;
}

/**
 * Request parameters for deleteTable operation in DataAccessApi.
 * @export
 * @interface DataAccessApiDeleteTableRequest
 */
export interface DataAccessApiDeleteTableRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof DataAccessApiDeleteTable
   */
  readonly sessionId: string;

  /**
   * Specifies the libref for the request.
   * @type {string}
   * @memberof DataAccessApiDeleteTable
   */
  readonly libref: string;

  /**
   * Specifies the table or data set to update.
   * @type {string}
   * @memberof DataAccessApiDeleteTable
   */
  readonly tableName: string;
}

/**
 * Request parameters for getColumn operation in DataAccessApi.
 * @export
 * @interface DataAccessApiGetColumnRequest
 */
export interface DataAccessApiGetColumnRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof DataAccessApiGetColumn
   */
  readonly sessionId: string;

  /**
   * Specifies the libref for the request.
   * @type {string}
   * @memberof DataAccessApiGetColumn
   */
  readonly libref: string;

  /**
   * Specifies the table or data set to query.
   * @type {string}
   * @memberof DataAccessApiGetColumn
   */
  readonly tableName: string;

  /**
   * Specifies the name of the column to retrieve.
   * @type {string}
   * @memberof DataAccessApiGetColumn
   */
  readonly columnName: string;
}

/**
 * Request parameters for getColumns operation in DataAccessApi.
 * @export
 * @interface DataAccessApiGetColumnsRequest
 */
export interface DataAccessApiGetColumnsRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof DataAccessApiGetColumns
   */
  readonly sessionId: string;

  /**
   * Specifies the libref for the request.
   * @type {string}
   * @memberof DataAccessApiGetColumns
   */
  readonly libref: string;

  /**
   * Specifies the table or data set to query.
   * @type {string}
   * @memberof DataAccessApiGetColumns
   */
  readonly tableName: string;

  /**
   * Specifies the offset of the first column entry to return.
   * @type {number}
   * @memberof DataAccessApiGetColumns
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of columns to return.
   * @type {number}
   * @memberof DataAccessApiGetColumns
   */
  readonly limit?: number;
}

/**
 * Request parameters for getColumnsWithRequest operation in DataAccessApi.
 * @export
 * @interface DataAccessApiGetColumnsWithRequestRequest
 */
export interface DataAccessApiGetColumnsWithRequestRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof DataAccessApiGetColumnsWithRequest
   */
  readonly sessionId: string;

  /**
   * Specifies the libref for the request.
   * @type {string}
   * @memberof DataAccessApiGetColumnsWithRequest
   */
  readonly libref: string;

  /**
   * Specifies the table or data set to query.
   * @type {string}
   * @memberof DataAccessApiGetColumnsWithRequest
   */
  readonly tableName: string;

  /**
   * Specifies the offset of the first column entry to return.
   * @type {number}
   * @memberof DataAccessApiGetColumnsWithRequest
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of columns to return.
   * @type {number}
   * @memberof DataAccessApiGetColumnsWithRequest
   */
  readonly limit?: number;

  /**
   * Optional body that is used to refine a request.
   * @type {ColumnsRequest}
   * @memberof DataAccessApiGetColumnsWithRequest
   */
  readonly columnsRequest?: ColumnsRequest;
}

/**
 * Request parameters for getLibraries operation in DataAccessApi.
 * @export
 * @interface DataAccessApiGetLibrariesRequest
 */
export interface DataAccessApiGetLibrariesRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof DataAccessApiGetLibraries
   */
  readonly sessionId: string;

  /**
   * Specifies the desired library representation.&lt;br&gt; The Accept-Item options are: &lt;ul&gt; &lt;li&gt;application/vnd.sas.compute.library+json &lt;li&gt;application/vnd.sas.compute.library.summary+json &lt;li&gt;blank &lt;/ul&gt; If the application/vnd.sas.compute.library.summary+json type is specified or no Accept-Item header is specified, then the libraries are returned as summary representation library objects.
   * @type {'application/vnd.sas.compute.library+json' | 'application/vnd.sas.compute.library.summary+json'}
   * @memberof DataAccessApiGetLibraries
   */
  readonly acceptItem?:
    | "application/vnd.sas.compute.library+json"
    | "application/vnd.sas.compute.library.summary+json";

  /**
   * Specifies the offset of the first library to return.
   * @type {number}
   * @memberof DataAccessApiGetLibraries
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of libraries to return.
   * @type {number}
   * @memberof DataAccessApiGetLibraries
   */
  readonly limit?: number;

  /**
   * Specifies whether to force the library collection to be refreshed before it is returned.
   * @type {boolean}
   * @memberof DataAccessApiGetLibraries
   */
  readonly noCache?: boolean;
}

/**
 * Request parameters for getLibrary operation in DataAccessApi.
 * @export
 * @interface DataAccessApiGetLibraryRequest
 */
export interface DataAccessApiGetLibraryRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof DataAccessApiGetLibrary
   */
  readonly sessionId: string;

  /**
   * Specifies the libref to query.
   * @type {string}
   * @memberof DataAccessApiGetLibrary
   */
  readonly libref: string;
}

/**
 * Request parameters for getLibrarySummary operation in DataAccessApi.
 * @export
 * @interface DataAccessApiGetLibrarySummaryRequest
 */
export interface DataAccessApiGetLibrarySummaryRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof DataAccessApiGetLibrarySummary
   */
  readonly sessionId: string;

  /**
   * Specifies the libref to query.
   * @type {string}
   * @memberof DataAccessApiGetLibrarySummary
   */
  readonly libref: string;
}

/**
 * Request parameters for getPromptContent operation in DataAccessApi.
 * @export
 * @interface DataAccessApiGetPromptContentRequest
 */
export interface DataAccessApiGetPromptContentRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof DataAccessApiGetPromptContent
   */
  readonly sessionId: string;

  /**
   * Specifies the libref for the request.
   * @type {string}
   * @memberof DataAccessApiGetPromptContent
   */
  readonly libref: string;

  /**
   * Specifies the table or data set to query.
   * @type {string}
   * @memberof DataAccessApiGetPromptContent
   */
  readonly tableName: string;

  /**
   * Specifies that a standard SAS WHERE clause was used to build the content for this request.
   * @type {string}
   * @memberof DataAccessApiGetPromptContent
   */
  readonly where?: string;

  /**
   * Specifies the level of column information to return.
   * @type {'names' | 'detail' | 'summary'}
   * @memberof DataAccessApiGetPromptContent
   */
  readonly columnDetail?: "names" | "detail" | "summary";

  /**
   * Specifies a comma-separated list of columns to include in the returned content . If you do not specify a list, all columns are returned. The order of the column names in the list determines the order of cells of the return prompt content.
   * @type {string}
   * @memberof DataAccessApiGetPromptContent
   */
  readonly includeColumns?: string;

  /**
   * When includeColumns is specified, a value of true for columnNatrualOrder specifies that the cells of the content are returned in the order in which they occur in the data set instead of in the order that is specified by includeColumns.
   * @type {boolean}
   * @memberof DataAccessApiGetPromptContent
   */
  readonly columnNaturalOrder?: boolean;

  /**
   * Specifies the offset of the first row to return.
   * @type {number}
   * @memberof DataAccessApiGetPromptContent
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of rows to return.
   * @type {number}
   * @memberof DataAccessApiGetPromptContent
   */
  readonly limit?: number;

  /**
   * Sets the sort order for the returned row set.
   * @type {string}
   * @memberof DataAccessApiGetPromptContent
   */
  readonly sortBy?: string;
}

/**
 * Request parameters for getPromptContentWithRequest operation in DataAccessApi.
 * @export
 * @interface DataAccessApiGetPromptContentWithRequestRequest
 */
export interface DataAccessApiGetPromptContentWithRequestRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof DataAccessApiGetPromptContentWithRequest
   */
  readonly sessionId: string;

  /**
   * Specifies the libref for the request.
   * @type {string}
   * @memberof DataAccessApiGetPromptContentWithRequest
   */
  readonly libref: string;

  /**
   * Specifies the table or data set to query.
   * @type {string}
   * @memberof DataAccessApiGetPromptContentWithRequest
   */
  readonly tableName: string;

  /**
   * Specifies a prompt content creation request.
   * @type {PromptContentRequest}
   * @memberof DataAccessApiGetPromptContentWithRequest
   */
  readonly promptContentRequest: PromptContentRequest;

  /**
   * Specifies the offset of the first row to return.
   * @type {number}
   * @memberof DataAccessApiGetPromptContentWithRequest
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of rows to return.
   * @type {number}
   * @memberof DataAccessApiGetPromptContentWithRequest
   */
  readonly limit?: number;
}

/**
 * Request parameters for getRowSet operation in DataAccessApi.
 * @export
 * @interface DataAccessApiGetRowSetRequest
 */
export interface DataAccessApiGetRowSetRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof DataAccessApiGetRowSet
   */
  readonly sessionId: string;

  /**
   * Specifies the libref for the request.
   * @type {string}
   * @memberof DataAccessApiGetRowSet
   */
  readonly libref: string;

  /**
   * Specifies the table or data set to query.
   * @type {string}
   * @memberof DataAccessApiGetRowSet
   */
  readonly tableName: string;

  /**
   * Specifies that a standard SAS WHERE clause was used to build the row set for this request.
   * @type {string}
   * @memberof DataAccessApiGetRowSet
   */
  readonly where?: string;

  /**
   * Specifies whether to format the data in the cells.
   * @type {boolean}
   * @memberof DataAccessApiGetRowSet
   */
  readonly format?: boolean;

  /**
   * Specifies the level of column information to return.
   * @type {'names' | 'detail' | 'summary'}
   * @memberof DataAccessApiGetRowSet
   */
  readonly columnDetail?: "names" | "detail" | "summary";

  /**
   * Specifies a comma-separated list of columns to include in a row set. If you do not specify a list, all columns are returned. The order of the column names in the list determines the order of cells of the row set.
   * @type {string}
   * @memberof DataAccessApiGetRowSet
   */
  readonly includeColumns?: string;

  /**
   * When includeColumns is specified, a value of true for columnNatrualOrder specifies that the cells of the row set are returned in the order in which they occur in the data set instead of in the order that is specified by includeColumns.
   * @type {boolean}
   * @memberof DataAccessApiGetRowSet
   */
  readonly columnNaturalOrder?: boolean;

  /**
   * Specifies the offset of the first row to return.
   * @type {number}
   * @memberof DataAccessApiGetRowSet
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of rows to return.
   * @type {number}
   * @memberof DataAccessApiGetRowSet
   */
  readonly limit?: number;

  /**
   * Sets the sort order for the returned row set.
   * @type {string}
   * @memberof DataAccessApiGetRowSet
   */
  readonly sortBy?: string;

  /**
   * If set to true, SAS missing values found in the data will be formatted based on the setting of the SAS Option MISSING.   Otherwise, a NULL value will be returned.
   * @type {boolean}
   * @memberof DataAccessApiGetRowSet
   */
  readonly formatMissingValues?: boolean;
}

/**
 * Request parameters for getRowSetWithRequest operation in DataAccessApi.
 * @export
 * @interface DataAccessApiGetRowSetWithRequestRequest
 */
export interface DataAccessApiGetRowSetWithRequestRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof DataAccessApiGetRowSetWithRequest
   */
  readonly sessionId: string;

  /**
   * Specifies the libref for the request.
   * @type {string}
   * @memberof DataAccessApiGetRowSetWithRequest
   */
  readonly libref: string;

  /**
   * Specifies the table or data set to query.
   * @type {string}
   * @memberof DataAccessApiGetRowSetWithRequest
   */
  readonly tableName: string;

  /**
   * Specifies a row set creation request.
   * @type {RowSetRequest}
   * @memberof DataAccessApiGetRowSetWithRequest
   */
  readonly rowSetRequest: RowSetRequest;

  /**
   * Specifies whether to format the data in the cells.
   * @type {boolean}
   * @memberof DataAccessApiGetRowSetWithRequest
   */
  readonly format?: boolean;

  /**
   * Specifies the offset of the first row to return.
   * @type {number}
   * @memberof DataAccessApiGetRowSetWithRequest
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of rows to return.
   * @type {number}
   * @memberof DataAccessApiGetRowSetWithRequest
   */
  readonly limit?: number;

  /**
   * If set to true, SAS missing values found in the data will be formatted based on the setting of the SAS Option MISSING.   Otherwise, a NULL value will be returned.
   * @type {boolean}
   * @memberof DataAccessApiGetRowSetWithRequest
   */
  readonly formatMissingValues?: boolean;
}

/**
 * Request parameters for getRows operation in DataAccessApi.
 * @export
 * @interface DataAccessApiGetRowsRequest
 */
export interface DataAccessApiGetRowsRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof DataAccessApiGetRows
   */
  readonly sessionId: string;

  /**
   * Specifies the libref for the request.
   * @type {string}
   * @memberof DataAccessApiGetRows
   */
  readonly libref: string;

  /**
   * Specifies the table or data set to query.
   * @type {string}
   * @memberof DataAccessApiGetRows
   */
  readonly tableName: string;

  /**
   * Specifies the offset of the first row to return.
   * @type {number}
   * @memberof DataAccessApiGetRows
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of rows to return.
   * @type {number}
   * @memberof DataAccessApiGetRows
   */
  readonly limit?: number;

  /**
   * Specifies whether to format the data in the cells.
   * @type {boolean}
   * @memberof DataAccessApiGetRows
   */
  readonly format?: boolean;

  /**
   * Specifies whether the first value in the cell is the index of the requested row. Support for this parameter was added in version 2.
   * @type {boolean}
   * @memberof DataAccessApiGetRows
   */
  readonly includeIndex?: boolean;

  /**
   * Specifies that a standard SAS WHERE clause was used to return the rows for this request.
   * @type {string}
   * @memberof DataAccessApiGetRows
   */
  readonly where?: string;

  /**
   * Specifies whether the first row that is returned consists of column names.
   * @type {boolean}
   * @memberof DataAccessApiGetRows
   */
  readonly includeColumnNames?: boolean;

  /**
   * If set to true, SAS missing values found in the data will be formatted based on the setting of the SAS Option MISSING.   Otherwise, a NULL value will be returned.
   * @type {boolean}
   * @memberof DataAccessApiGetRows
   */
  readonly formatMissingValues?: boolean;
}

/**
 * Request parameters for getRowsAsCSV operation in DataAccessApi.
 * @export
 * @interface DataAccessApiGetRowsAsCSVRequest
 */
export interface DataAccessApiGetRowsAsCSVRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof DataAccessApiGetRowsAsCSV
   */
  readonly sessionId: string;

  /**
   * Specifies the libref for the request.
   * @type {string}
   * @memberof DataAccessApiGetRowsAsCSV
   */
  readonly libref: string;

  /**
   * Specifies the table or data set to query.
   * @type {string}
   * @memberof DataAccessApiGetRowsAsCSV
   */
  readonly tableName: string;

  /**
   * Specifies the offset of the first row to return.
   * @type {number}
   * @memberof DataAccessApiGetRowsAsCSV
   */
  readonly start?: number;

  /**
   * (Optional) Specifies the maximum number of rows to return. If not set, all rows are returned.
   * @type {number}
   * @memberof DataAccessApiGetRowsAsCSV
   */
  readonly limit?: number;

  /**
   * Specifies whether to format the data in the cells.
   * @type {boolean}
   * @memberof DataAccessApiGetRowsAsCSV
   */
  readonly format?: boolean;

  /**
   * Specifies whether the first value in the cell is the index of the requested row. Support for this parameter was added in version 2.
   * @type {boolean}
   * @memberof DataAccessApiGetRowsAsCSV
   */
  readonly includeIndex?: boolean;

  /**
   * Specifies that a standard SAS WHERE clause has been used to return the rows for this request.
   * @type {string}
   * @memberof DataAccessApiGetRowsAsCSV
   */
  readonly where?: string;

  /**
   * Specifies whether the first row that is returned consists of column names.
   * @type {boolean}
   * @memberof DataAccessApiGetRowsAsCSV
   */
  readonly includeColumnNames?: boolean;

  /**
   * Specifies the character to use as the column separator. If no character is specified, a comma is used as the separator.
   * @type {string}
   * @memberof DataAccessApiGetRowsAsCSV
   */
  readonly columnSeparator?: string;

  /**
   * Specifies the characters to use as the row separator. If no characters are specified, a line feed character (\\n) is used.
   * @type {string}
   * @memberof DataAccessApiGetRowsAsCSV
   */
  readonly rowSeparator?: string;

  /**
   * Specifies whether values that contain special characters are quoted.
   * @type {boolean}
   * @memberof DataAccessApiGetRowsAsCSV
   */
  readonly enableQuoting?: boolean;

  /**
   * Specifies whether special characters in values are escaped if the value is not quoted.
   * @type {boolean}
   * @memberof DataAccessApiGetRowsAsCSV
   */
  readonly enableEscaping?: boolean;

  /**
   * If set to true, SAS missing values found in the data will be formatted based on the setting of the SAS Option MISSING.   Otherwise, a NULL value will be returned.
   * @type {boolean}
   * @memberof DataAccessApiGetRowsAsCSV
   */
  readonly formatMissingValues?: boolean;
}

/**
 * Request parameters for getRowsWithRequest operation in DataAccessApi.
 * @export
 * @interface DataAccessApiGetRowsWithRequestRequest
 */
export interface DataAccessApiGetRowsWithRequestRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof DataAccessApiGetRowsWithRequest
   */
  readonly sessionId: string;

  /**
   * Specifies the libref for the request.
   * @type {string}
   * @memberof DataAccessApiGetRowsWithRequest
   */
  readonly libref: string;

  /**
   * Specifies the table or data set to query.
   * @type {string}
   * @memberof DataAccessApiGetRowsWithRequest
   */
  readonly tableName: string;

  /**
   * Specifies a row-generation request.
   * @type {RowsRequest}
   * @memberof DataAccessApiGetRowsWithRequest
   */
  readonly rowsRequest: RowsRequest;

  /**
   * Specifies the offset of the first row to return.
   * @type {number}
   * @memberof DataAccessApiGetRowsWithRequest
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of rows to return.
   * @type {number}
   * @memberof DataAccessApiGetRowsWithRequest
   */
  readonly limit?: number;

  /**
   * Specifies whether to format the data in the cells.
   * @type {boolean}
   * @memberof DataAccessApiGetRowsWithRequest
   */
  readonly format?: boolean;

  /**
   * Specifies whether the first value in the cell is the index of a specific row. Support for this parameter was added in version 2.
   * @type {boolean}
   * @memberof DataAccessApiGetRowsWithRequest
   */
  readonly includeIndex?: boolean;

  /**
   * If set to true, SAS missing values found in the data will be formatted based on the setting of the SAS Option MISSING.   Otherwise, a NULL value will be returned.
   * @type {boolean}
   * @memberof DataAccessApiGetRowsWithRequest
   */
  readonly formatMissingValues?: boolean;
}

/**
 * Request parameters for getTable operation in DataAccessApi.
 * @export
 * @interface DataAccessApiGetTableRequest
 */
export interface DataAccessApiGetTableRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof DataAccessApiGetTable
   */
  readonly sessionId: string;

  /**
   * Specifies the libref for the request.
   * @type {string}
   * @memberof DataAccessApiGetTable
   */
  readonly libref: string;

  /**
   * Specifies the table or data set to query.
   * @type {string}
   * @memberof DataAccessApiGetTable
   */
  readonly tableName: string;
}

/**
 * Request parameters for getTableSummary operation in DataAccessApi.
 * @export
 * @interface DataAccessApiGetTableSummaryRequest
 */
export interface DataAccessApiGetTableSummaryRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof DataAccessApiGetTableSummary
   */
  readonly sessionId: string;

  /**
   * Specifies the libref for the request.
   * @type {string}
   * @memberof DataAccessApiGetTableSummary
   */
  readonly libref: string;

  /**
   * Specifies the table or data set to query.
   * @type {string}
   * @memberof DataAccessApiGetTableSummary
   */
  readonly tableName: string;
}

/**
 * Request parameters for getTables operation in DataAccessApi.
 * @export
 * @interface DataAccessApiGetTablesRequest
 */
export interface DataAccessApiGetTablesRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof DataAccessApiGetTables
   */
  readonly sessionId: string;

  /**
   * Specifies the libref to query.
   * @type {string}
   * @memberof DataAccessApiGetTables
   */
  readonly libref: string;

  /**
   * Specifies the desired data table representation.&lt;br&gt; The Accept-Item options are: &lt;ul&gt; &lt;li&gt;application/vnd.sas.compute.data.table+json &lt;li&gt;application/vnd.sas.compute.data.table.summary+json &lt;li&gt;blank &lt;/ul&gt; If the application/vnd.sas.compute.data.table.summary+json type is specified or no Accept-Item header is specified, then the data tables are returned as summary representation data table objects.
   * @type {'application/vnd.sas.compute.data.table+json'}
   * @memberof DataAccessApiGetTables
   */
  readonly acceptItem?: "application/vnd.sas.compute.data.table+json";

  /**
   * Specifies the offset of the first table summary to return.
   * @type {number}
   * @memberof DataAccessApiGetTables
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of table summaries to return.
   * @type {number}
   * @memberof DataAccessApiGetTables
   */
  readonly limit?: number;

  /**
   * Specifies whether to force the table collection to be refreshed before it is returned.
   * @type {boolean}
   * @memberof DataAccessApiGetTables
   */
  readonly noCache?: boolean;
}

/**
 * Request parameters for headersForColumn operation in DataAccessApi.
 * @export
 * @interface DataAccessApiHeadersForColumnRequest
 */
export interface DataAccessApiHeadersForColumnRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof DataAccessApiHeadersForColumn
   */
  readonly sessionId: string;

  /**
   * Specifies the libref for the request.
   * @type {string}
   * @memberof DataAccessApiHeadersForColumn
   */
  readonly libref: string;

  /**
   * Specifies the table or data set to query.
   * @type {string}
   * @memberof DataAccessApiHeadersForColumn
   */
  readonly tableName: string;

  /**
   * Specifies the column name to check.
   * @type {string}
   * @memberof DataAccessApiHeadersForColumn
   */
  readonly columnName: string;
}

/**
 * Request parameters for headersForColumns operation in DataAccessApi.
 * @export
 * @interface DataAccessApiHeadersForColumnsRequest
 */
export interface DataAccessApiHeadersForColumnsRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof DataAccessApiHeadersForColumns
   */
  readonly sessionId: string;

  /**
   * Specifies the libref for the request.
   * @type {string}
   * @memberof DataAccessApiHeadersForColumns
   */
  readonly libref: string;

  /**
   * Specifies the table or data set to query.
   * @type {string}
   * @memberof DataAccessApiHeadersForColumns
   */
  readonly tableName: string;

  /**
   * Specifies the offset of the first column entry to return.
   * @type {number}
   * @memberof DataAccessApiHeadersForColumns
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of columns to return.
   * @type {number}
   * @memberof DataAccessApiHeadersForColumns
   */
  readonly limit?: number;
}

/**
 * Request parameters for headersForLibrary operation in DataAccessApi.
 * @export
 * @interface DataAccessApiHeadersForLibraryRequest
 */
export interface DataAccessApiHeadersForLibraryRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof DataAccessApiHeadersForLibrary
   */
  readonly sessionId: string;

  /**
   * Specifies the libref to query.
   * @type {string}
   * @memberof DataAccessApiHeadersForLibrary
   */
  readonly libref: string;
}

/**
 * Request parameters for headersForPromptContent operation in DataAccessApi.
 * @export
 * @interface DataAccessApiHeadersForPromptContentRequest
 */
export interface DataAccessApiHeadersForPromptContentRequest {
  /**
   * Specifies the ID of the session
   * @type {string}
   * @memberof DataAccessApiHeadersForPromptContent
   */
  readonly sessionId: string;

  /**
   * Specifies the libref for the request.
   * @type {string}
   * @memberof DataAccessApiHeadersForPromptContent
   */
  readonly libref: string;

  /**
   * Specifies the table or data set to query.
   * @type {string}
   * @memberof DataAccessApiHeadersForPromptContent
   */
  readonly tableName: string;

  /**
   * Specifies that a standard SAS WHERE clause was used to build the content for this request.
   * @type {string}
   * @memberof DataAccessApiHeadersForPromptContent
   */
  readonly where?: string;

  /**
   * Specifies the level of column information to return.
   * @type {'names' | 'detail' | 'summary'}
   * @memberof DataAccessApiHeadersForPromptContent
   */
  readonly columnDetail?: "names" | "detail" | "summary";

  /**
   * Specifies a comma separated list of columns to include in the returned content. If you do not specify a list, all columns are returned. The order of the column names in the list is the order in which the cells of the content are in as well.
   * @type {string}
   * @memberof DataAccessApiHeadersForPromptContent
   */
  readonly includeColumns?: string;

  /**
   * When includeColumns is specified, a value of true for columnNatrualOrder specifies that the cells of the returned content are returned in the order in which they occur in the data set instead of in the order that is specified by includeColumns.
   * @type {boolean}
   * @memberof DataAccessApiHeadersForPromptContent
   */
  readonly columnNaturalOrder?: boolean;

  /**
   * Specifies the offset of the first row to return. The default value is \&quot;0\&quot;.
   * @type {number}
   * @memberof DataAccessApiHeadersForPromptContent
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of rows to return. The default value is \&quot;10\&quot;.
   * @type {number}
   * @memberof DataAccessApiHeadersForPromptContent
   */
  readonly limit?: number;

  /**
   * Sets the sort order for the returned prompt content.
   * @type {string}
   * @memberof DataAccessApiHeadersForPromptContent
   */
  readonly sortBy?: string;
}

/**
 * Request parameters for headersForRow operation in DataAccessApi.
 * @export
 * @interface DataAccessApiHeadersForRowRequest
 */
export interface DataAccessApiHeadersForRowRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof DataAccessApiHeadersForRow
   */
  readonly sessionId: string;

  /**
   * Specifies the libref for the request.
   * @type {string}
   * @memberof DataAccessApiHeadersForRow
   */
  readonly libref: string;

  /**
   * Specifies the table or data set to query.
   * @type {string}
   * @memberof DataAccessApiHeadersForRow
   */
  readonly tableName: string;

  /**
   * Specifies the offset of the first row to return.
   * @type {number}
   * @memberof DataAccessApiHeadersForRow
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of rows to return.
   * @type {number}
   * @memberof DataAccessApiHeadersForRow
   */
  readonly limit?: number;

  /**
   * Specifies whether to format the data in the cells.
   * @type {boolean}
   * @memberof DataAccessApiHeadersForRow
   */
  readonly format?: boolean;

  /**
   * Specifies whether the first value in the cell is the index of the requested row. Support for this parameter was added in version 2.
   * @type {boolean}
   * @memberof DataAccessApiHeadersForRow
   */
  readonly includeIndex?: boolean;

  /**
   * Specifies that a standard SAS WHERE clause was used to return the rows for this request.
   * @type {string}
   * @memberof DataAccessApiHeadersForRow
   */
  readonly where?: string;

  /**
   * Specifies whether the first row that is returned consists of column names.
   * @type {boolean}
   * @memberof DataAccessApiHeadersForRow
   */
  readonly includeColumnNames?: boolean;

  /**
   * If set to true, SAS missing values found in the data will be formatted based on the setting of the SAS Option MISSING.   Otherwise, a NULL value will be returned.
   * @type {boolean}
   * @memberof DataAccessApiHeadersForRow
   */
  readonly formatMissingValues?: boolean;
}

/**
 * Request parameters for headersForRowSet operation in DataAccessApi.
 * @export
 * @interface DataAccessApiHeadersForRowSetRequest
 */
export interface DataAccessApiHeadersForRowSetRequest {
  /**
   * Specifies the ID of the session
   * @type {string}
   * @memberof DataAccessApiHeadersForRowSet
   */
  readonly sessionId: string;

  /**
   * Specifies the libref for the request.
   * @type {string}
   * @memberof DataAccessApiHeadersForRowSet
   */
  readonly libref: string;

  /**
   * Specifies the table or data set to query.
   * @type {string}
   * @memberof DataAccessApiHeadersForRowSet
   */
  readonly tableName: string;

  /**
   * Specifies that a standard SAS WHERE clause was used to build the row set for this request.
   * @type {string}
   * @memberof DataAccessApiHeadersForRowSet
   */
  readonly where?: string;

  /**
   * Specifies whether to format the data in the cells.
   * @type {boolean}
   * @memberof DataAccessApiHeadersForRowSet
   */
  readonly format?: boolean;

  /**
   * Specifies the level of column information to return.
   * @type {'names' | 'detail' | 'summary'}
   * @memberof DataAccessApiHeadersForRowSet
   */
  readonly columnDetail?: "names" | "detail" | "summary";

  /**
   * Specifies a comma separated list of columns to include in the row set. If you do not specify a list, all columns are returned. The order of the column names in the list is the order in which the cells of the row set are in as well.
   * @type {string}
   * @memberof DataAccessApiHeadersForRowSet
   */
  readonly includeColumns?: string;

  /**
   * When includeColumns is specified, a value of true for columnNatrualOrder specifies that the cells of the row set are returned in the order in which they occur in the data set instead of in the order that is specified by includeColumns.
   * @type {boolean}
   * @memberof DataAccessApiHeadersForRowSet
   */
  readonly columnNaturalOrder?: boolean;

  /**
   * Specifies the offset of the first row to return. The default value is \&quot;0\&quot;.
   * @type {number}
   * @memberof DataAccessApiHeadersForRowSet
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of rows to return. The default value is \&quot;10\&quot;.
   * @type {number}
   * @memberof DataAccessApiHeadersForRowSet
   */
  readonly limit?: number;

  /**
   * Sets the sort order for the returned row set.
   * @type {string}
   * @memberof DataAccessApiHeadersForRowSet
   */
  readonly sortBy?: string;

  /**
   * If set to true, SAS missing values found in the data will be formatted based on the setting of the SAS Option MISSING.   Otherwise, a NULL value will be returned.
   * @type {boolean}
   * @memberof DataAccessApiHeadersForRowSet
   */
  readonly formatMissingValues?: boolean;
}

/**
 * Request parameters for headersForRowsAsCSV operation in DataAccessApi.
 * @export
 * @interface DataAccessApiHeadersForRowsAsCSVRequest
 */
export interface DataAccessApiHeadersForRowsAsCSVRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof DataAccessApiHeadersForRowsAsCSV
   */
  readonly sessionId: string;

  /**
   * Specifies the libref for the request.
   * @type {string}
   * @memberof DataAccessApiHeadersForRowsAsCSV
   */
  readonly libref: string;

  /**
   * Specifies the table or data set to query.
   * @type {string}
   * @memberof DataAccessApiHeadersForRowsAsCSV
   */
  readonly tableName: string;

  /**
   * Specifies the offset of the first row to return.
   * @type {number}
   * @memberof DataAccessApiHeadersForRowsAsCSV
   */
  readonly start?: number;

  /**
   * (Optional) Specifies the maximum number of rows to return. If not set, all rows are returned.
   * @type {number}
   * @memberof DataAccessApiHeadersForRowsAsCSV
   */
  readonly limit?: number;

  /**
   * Specifies whether to format the data in the cells.
   * @type {boolean}
   * @memberof DataAccessApiHeadersForRowsAsCSV
   */
  readonly format?: boolean;

  /**
   * Specifies whether the first value in the cell is the index of the requested row. Support for this parameter was added in version 2.
   * @type {boolean}
   * @memberof DataAccessApiHeadersForRowsAsCSV
   */
  readonly includeIndex?: boolean;

  /**
   * Specifies that a standard SAS WHERE clause was used to return the rows for this request.
   * @type {string}
   * @memberof DataAccessApiHeadersForRowsAsCSV
   */
  readonly where?: string;

  /**
   * Specifies whether the first row that is returned consists of column names.
   * @type {boolean}
   * @memberof DataAccessApiHeadersForRowsAsCSV
   */
  readonly includeColumnNames?: boolean;

  /**
   * Specifies the character to use as the column separator. If no character is specified, a comma is used as the separator.
   * @type {string}
   * @memberof DataAccessApiHeadersForRowsAsCSV
   */
  readonly columnSeparator?: string;

  /**
   * Specifies the characters to use as the row separator. If no characters are specified, a line feed character (\\n) is used.
   * @type {string}
   * @memberof DataAccessApiHeadersForRowsAsCSV
   */
  readonly rowSeparator?: string;

  /**
   * Specifies whether values that contain special characters are quoted.
   * @type {boolean}
   * @memberof DataAccessApiHeadersForRowsAsCSV
   */
  readonly enableQuoting?: boolean;

  /**
   * Specifies whether special characters in values are escaped if the values are not quoted.
   * @type {boolean}
   * @memberof DataAccessApiHeadersForRowsAsCSV
   */
  readonly enableEscaping?: boolean;

  /**
   * If set to true, SAS missing values found in the data will be formatted based on the setting of the SAS Option MISSING.   Otherwise, a NULL value will be returned.
   * @type {boolean}
   * @memberof DataAccessApiHeadersForRowsAsCSV
   */
  readonly formatMissingValues?: boolean;
}

/**
 * Request parameters for headersForSessionLibraries operation in DataAccessApi.
 * @export
 * @interface DataAccessApiHeadersForSessionLibrariesRequest
 */
export interface DataAccessApiHeadersForSessionLibrariesRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof DataAccessApiHeadersForSessionLibraries
   */
  readonly sessionId: string;

  /**
   * Specifies the offset of the first library to return.
   * @type {number}
   * @memberof DataAccessApiHeadersForSessionLibraries
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of libraries to return.
   * @type {number}
   * @memberof DataAccessApiHeadersForSessionLibraries
   */
  readonly limit?: number;

  /**
   * Specifies whether to force the library collection to be refreshed before it is returned.
   * @type {boolean}
   * @memberof DataAccessApiHeadersForSessionLibraries
   */
  readonly noCache?: boolean;
}

/**
 * Request parameters for headersForTable operation in DataAccessApi.
 * @export
 * @interface DataAccessApiHeadersForTableRequest
 */
export interface DataAccessApiHeadersForTableRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof DataAccessApiHeadersForTable
   */
  readonly sessionId: string;

  /**
   * Specifies the libref for the request.
   * @type {string}
   * @memberof DataAccessApiHeadersForTable
   */
  readonly libref: string;

  /**
   * Specifies the table or data set to query.
   * @type {string}
   * @memberof DataAccessApiHeadersForTable
   */
  readonly tableName: string;
}

/**
 * Request parameters for updateColumn operation in DataAccessApi.
 * @export
 * @interface DataAccessApiUpdateColumnRequest
 */
export interface DataAccessApiUpdateColumnRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof DataAccessApiUpdateColumn
   */
  readonly sessionId: string;

  /**
   * Specifies the libref for the request.
   * @type {string}
   * @memberof DataAccessApiUpdateColumn
   */
  readonly libref: string;

  /**
   * Specifies the table that contains the column to update.
   * @type {string}
   * @memberof DataAccessApiUpdateColumn
   */
  readonly tableName: string;

  /**
   * Specifies the column name to update.
   * @type {string}
   * @memberof DataAccessApiUpdateColumn
   */
  readonly columnName: string;

  /**
   * Specifies the ETag of the column that you are updating.
   * @type {string}
   * @memberof DataAccessApiUpdateColumn
   */
  readonly ifMatch: string;

  /**
   * Specifies the information to update for the column.
   * @type {Column}
   * @memberof DataAccessApiUpdateColumn
   */
  readonly column: Column;
}

/**
 * Request parameters for updateTable operation in DataAccessApi.
 * @export
 * @interface DataAccessApiUpdateTableRequest
 */
export interface DataAccessApiUpdateTableRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof DataAccessApiUpdateTable
   */
  readonly sessionId: string;

  /**
   * Specifies the libref for the request.
   * @type {string}
   * @memberof DataAccessApiUpdateTable
   */
  readonly libref: string;

  /**
   * Specifies the table or data set to update.
   * @type {string}
   * @memberof DataAccessApiUpdateTable
   */
  readonly tableName: string;

  /**
   * Specifies the ETag of the table that you are updating.
   * @type {string}
   * @memberof DataAccessApiUpdateTable
   */
  readonly ifMatch: string;

  /**
   * Specifies the information to update for the table.
   * @type {TableInfo}
   * @memberof DataAccessApiUpdateTable
   */
  readonly tableInfo: TableInfo;
}

/**
 * EnginesApi - axios parameter creator
 * @export
 */
export const EnginesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Returns information about a specific engine.
     * @summary Get engine information for a session
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} engineName Specifies the name or nickname of the specified engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEngine: async (
      sessionId: string,
      engineName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getEngine", "sessionId", sessionId);
      // verify required parameter 'engineName' is not null or undefined
      assertParamExists("getEngine", "engineName", engineName);
      const localVarPath = `/sessions/{sessionId}/engines/{engineName}`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"engineName"}}`, encodeURIComponent(String(engineName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns the options schema for a specific engine.
     * @summary Get options schema for an engine
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} engineName Specifies the name or nickname of the requested engine.
     * @param {number} [start] Specifies the offset of the first resource to return. The default value is \&quot;0\&quot;.
     * @param {number} [limit] Specifies the maximum number of resources to return. The default value is \&quot;50\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEngineDefinition: async (
      sessionId: string,
      engineName: string,
      start?: number,
      limit?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getEngineDefinition", "sessionId", sessionId);
      // verify required parameter 'engineName' is not null or undefined
      assertParamExists("getEngineDefinition", "engineName", engineName);
      const localVarPath =
        `/sessions/{sessionId}/engines/{engineName}/definition`
          .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
          .replace(`{${"engineName"}}`, encodeURIComponent(String(engineName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns engine information for a session. An engine enables you to access data from different storage locations. Each engine might have different requirements for usage. This endpoint returns a collection of engine information that enables you to determine what engines can be used in a session. A collection of application/vnd.sas.data.engine items is returned. Standard pagination rules apply, and simple filtering is allowed.
     * @summary Get an engine list for a session
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} [filter] Specifies filter criteria for returned context definitions.
     * @param {number} [start] Specifies the offset of the first engine to return. The default value is 0.
     * @param {number} [limit] Specifies the maximum number of engines to return on a page. The default value is 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEngines: async (
      sessionId: string,
      filter?: string,
      start?: number,
      limit?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getEngines", "sessionId", sessionId);
      const localVarPath = `/sessions/{sessionId}/engines`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (filter !== undefined) {
        localVarQueryParameter["filter"] = filter;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether information for a specific engine is available.
     * @summary Get engine information
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} engineName Specifies the name or nickname of the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForEngine: async (
      sessionId: string,
      engineName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForEngine", "sessionId", sessionId);
      // verify required parameter 'engineName' is not null or undefined
      assertParamExists("headersForEngine", "engineName", engineName);
      const localVarPath = `/sessions/{sessionId}/engines/{engineName}`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"engineName"}}`, encodeURIComponent(String(engineName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether information for the specified engine is available.
     * @summary Get engine information for a session
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} engineName Specifies the name or nickname of the requested engine.
     * @param {number} [start] Specifies the offset of the first resource to return. The default value is \&quot;0\&quot;.
     * @param {number} [limit] Specifies the maximum number of resources to return. The default value is \&quot;50\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForEngineDefinition: async (
      sessionId: string,
      engineName: string,
      start?: number,
      limit?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForEngineDefinition", "sessionId", sessionId);
      // verify required parameter 'engineName' is not null or undefined
      assertParamExists("headersForEngineDefinition", "engineName", engineName);
      const localVarPath =
        `/sessions/{sessionId}/engines/{engineName}/definition`
          .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
          .replace(`{${"engineName"}}`, encodeURIComponent(String(engineName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether it is possible to get engine information for a session.
     * @summary Check engine list availability for a session
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} [filter] Specifies filter criteria for returned context definitions.
     * @param {number} [start] Specifies the offset of the first engine to return. The default value is \&quot;0\&quot;.
     * @param {number} [limit] Specifies the maximum number of engines to return in a page. The default value is \&quot;10\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForEngines: async (
      sessionId: string,
      filter?: string,
      start?: number,
      limit?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForEngines", "sessionId", sessionId);
      const localVarPath = `/sessions/{sessionId}/engines`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (filter !== undefined) {
        localVarQueryParameter["filter"] = filter;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * EnginesApi - functional programming interface
 * @export
 */
export const EnginesApi = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = EnginesApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns information about a specific engine.
     * @summary Get engine information for a session
     * @param {EnginesApiGetEngineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEngine(
      requestParameters: EnginesApiGetEngineRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<Engine>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEngine(
        requestParameters.sessionId,
        requestParameters.engineName,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns the options schema for a specific engine.
     * @summary Get options schema for an engine
     * @param {EnginesApiGetEngineDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEngineDefinition(
      requestParameters: EnginesApiGetEngineDefinitionRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getEngineDefinition(
          requestParameters.sessionId,
          requestParameters.engineName,
          requestParameters.start,
          requestParameters.limit,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns engine information for a session. An engine enables you to access data from different storage locations. Each engine might have different requirements for usage. This endpoint returns a collection of engine information that enables you to determine what engines can be used in a session. A collection of application/vnd.sas.data.engine items is returned. Standard pagination rules apply, and simple filtering is allowed.
     * @summary Get an engine list for a session
     * @param {EnginesApiGetEnginesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEngines(
      requestParameters: EnginesApiGetEnginesRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<EngineCollection>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEngines(
        requestParameters.sessionId,
        requestParameters.filter,
        requestParameters.start,
        requestParameters.limit,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether information for a specific engine is available.
     * @summary Get engine information
     * @param {EnginesApiHeadersForEngineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForEngine(
      requestParameters: EnginesApiHeadersForEngineRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForEngine(
          requestParameters.sessionId,
          requestParameters.engineName,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether information for the specified engine is available.
     * @summary Get engine information for a session
     * @param {EnginesApiHeadersForEngineDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForEngineDefinition(
      requestParameters: EnginesApiHeadersForEngineDefinitionRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForEngineDefinition(
          requestParameters.sessionId,
          requestParameters.engineName,
          requestParameters.start,
          requestParameters.limit,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether it is possible to get engine information for a session.
     * @summary Check engine list availability for a session
     * @param {EnginesApiHeadersForEnginesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForEngines(
      requestParameters: EnginesApiHeadersForEnginesRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForEngines(
          requestParameters.sessionId,
          requestParameters.filter,
          requestParameters.start,
          requestParameters.limit,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },
  };
};

/**
 * Request parameters for getEngine operation in EnginesApi.
 * @export
 * @interface EnginesApiGetEngineRequest
 */
export interface EnginesApiGetEngineRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof EnginesApiGetEngine
   */
  readonly sessionId: string;

  /**
   * Specifies the name or nickname of the specified engine.
   * @type {string}
   * @memberof EnginesApiGetEngine
   */
  readonly engineName: string;
}

/**
 * Request parameters for getEngineDefinition operation in EnginesApi.
 * @export
 * @interface EnginesApiGetEngineDefinitionRequest
 */
export interface EnginesApiGetEngineDefinitionRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof EnginesApiGetEngineDefinition
   */
  readonly sessionId: string;

  /**
   * Specifies the name or nickname of the requested engine.
   * @type {string}
   * @memberof EnginesApiGetEngineDefinition
   */
  readonly engineName: string;

  /**
   * Specifies the offset of the first resource to return. The default value is \&quot;0\&quot;.
   * @type {number}
   * @memberof EnginesApiGetEngineDefinition
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of resources to return. The default value is \&quot;50\&quot;.
   * @type {number}
   * @memberof EnginesApiGetEngineDefinition
   */
  readonly limit?: number;
}

/**
 * Request parameters for getEngines operation in EnginesApi.
 * @export
 * @interface EnginesApiGetEnginesRequest
 */
export interface EnginesApiGetEnginesRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof EnginesApiGetEngines
   */
  readonly sessionId: string;

  /**
   * Specifies filter criteria for returned context definitions.
   * @type {string}
   * @memberof EnginesApiGetEngines
   */
  readonly filter?: string;

  /**
   * Specifies the offset of the first engine to return. The default value is 0.
   * @type {number}
   * @memberof EnginesApiGetEngines
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of engines to return on a page. The default value is 10.
   * @type {number}
   * @memberof EnginesApiGetEngines
   */
  readonly limit?: number;
}

/**
 * Request parameters for headersForEngine operation in EnginesApi.
 * @export
 * @interface EnginesApiHeadersForEngineRequest
 */
export interface EnginesApiHeadersForEngineRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof EnginesApiHeadersForEngine
   */
  readonly sessionId: string;

  /**
   * Specifies the name or nickname of the engine.
   * @type {string}
   * @memberof EnginesApiHeadersForEngine
   */
  readonly engineName: string;
}

/**
 * Request parameters for headersForEngineDefinition operation in EnginesApi.
 * @export
 * @interface EnginesApiHeadersForEngineDefinitionRequest
 */
export interface EnginesApiHeadersForEngineDefinitionRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof EnginesApiHeadersForEngineDefinition
   */
  readonly sessionId: string;

  /**
   * Specifies the name or nickname of the requested engine.
   * @type {string}
   * @memberof EnginesApiHeadersForEngineDefinition
   */
  readonly engineName: string;

  /**
   * Specifies the offset of the first resource to return. The default value is \&quot;0\&quot;.
   * @type {number}
   * @memberof EnginesApiHeadersForEngineDefinition
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of resources to return. The default value is \&quot;50\&quot;.
   * @type {number}
   * @memberof EnginesApiHeadersForEngineDefinition
   */
  readonly limit?: number;
}

/**
 * Request parameters for headersForEngines operation in EnginesApi.
 * @export
 * @interface EnginesApiHeadersForEnginesRequest
 */
export interface EnginesApiHeadersForEnginesRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof EnginesApiHeadersForEngines
   */
  readonly sessionId: string;

  /**
   * Specifies filter criteria for returned context definitions.
   * @type {string}
   * @memberof EnginesApiHeadersForEngines
   */
  readonly filter?: string;

  /**
   * Specifies the offset of the first engine to return. The default value is \&quot;0\&quot;.
   * @type {number}
   * @memberof EnginesApiHeadersForEngines
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of engines to return in a page. The default value is \&quot;10\&quot;.
   * @type {number}
   * @memberof EnginesApiHeadersForEngines
   */
  readonly limit?: number;
}

/**
 * FileSystemApi - axios parameter creator
 * @export
 */
export const FileSystemApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Copies a file or directory. Provide the path of the destination file or directory in the URI. Provide the path of the source file or directory in the request body. If you do not provide a path in the request body, then the current working directory is assumed.
     * @summary Copy a file or directory
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} destinationFileOrDirectoryPath Specifies the destination file or directory path. In the path value, replace each forward slash with ~fs~.
     * @param {FileRequest} fileRequest Specifies the source file or directory &#x60;name&#x60; and &#x60;path&#x60; elements. The &#x60;name&#x60; element is required, and the &#x60;path&#x60; element is optional.
     * @param {boolean} [overwrite] Specifies whether to force an overwrite of an existing file or directory if one of the same name exists at the destination path. If you specify true, the request replaces the existing file or directory.
     * @param {boolean} [expandPath] Specifies whether to return fully qualified paths in response links.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    copyFileOrDirectory: async (
      sessionId: string,
      destinationFileOrDirectoryPath: string,
      fileRequest: FileRequest,
      overwrite?: boolean,
      expandPath?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("copyFileOrDirectory", "sessionId", sessionId);
      // verify required parameter 'destinationFileOrDirectoryPath' is not null or undefined
      assertParamExists(
        "copyFileOrDirectory",
        "destinationFileOrDirectoryPath",
        destinationFileOrDirectoryPath
      );
      // verify required parameter 'fileRequest' is not null or undefined
      assertParamExists("copyFileOrDirectory", "fileRequest", fileRequest);
      const localVarPath =
        `/sessions/{sessionId}/files/{destinationFileOrDirectoryPath}#copyFileOrDirectory`
          .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
          .replace(
            `{${"destinationFileOrDirectoryPath"}}`,
            encodeURIComponent(String(destinationFileOrDirectoryPath))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (overwrite !== undefined) {
        localVarQueryParameter["overwrite"] = overwrite;
      }

      if (expandPath !== undefined) {
        localVarQueryParameter["expandPath"] = expandPath;
      }

      localVarHeaderParameter["Content-Type"] =
        "application/vnd.sas.compute.file.request+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        fileRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates an empty file or directory. In the request body, set the `isDirectory` attribute to \'false\' for files and to \'true\' for a directory. The `name` attribute specifies the name of the new file or directory. Provide the path of the new file or directory either in the URI or in the `path` attribute in the request body. If you do not provide a path, then the new file or directory is created under the current working directory.
     * @summary Create an empty file or directory
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} fileOrDirectoryPath Specifies the file or directory path. In the path value, replace each forward slash with ~fs~.
     * @param {FileProperties} fileProperties Specifies the file or directory &#x60;name&#x60; and &#x60;path&#x60; elements. The &#x60;name&#x60; element is required and the &#x60;path&#x60; element is optional.
     * @param {boolean} [expandPath] Specifies whether to return fully qualified paths in response links.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFileOrDirectory: async (
      sessionId: string,
      fileOrDirectoryPath: string,
      fileProperties: FileProperties,
      expandPath?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("createFileOrDirectory", "sessionId", sessionId);
      // verify required parameter 'fileOrDirectoryPath' is not null or undefined
      assertParamExists(
        "createFileOrDirectory",
        "fileOrDirectoryPath",
        fileOrDirectoryPath
      );
      // verify required parameter 'fileProperties' is not null or undefined
      assertParamExists(
        "createFileOrDirectory",
        "fileProperties",
        fileProperties
      );
      const localVarPath =
        `/sessions/{sessionId}/files/{fileOrDirectoryPath}#touchFileOrDirectory`
          .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
          .replace(
            `{${"fileOrDirectoryPath"}}`,
            encodeURIComponent(String(fileOrDirectoryPath))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (expandPath !== undefined) {
        localVarQueryParameter["expandPath"] = expandPath;
      }

      localVarHeaderParameter["Content-Type"] =
        "application/vnd.sas.compute.file.properties+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        fileProperties,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes a file or directory.
     * @summary Delete a file or directory
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} fileOrDirectoryPath Specifies the file or directory path. In the path value, replace each forward slash with ~fs~.
     * @param {string} ifMatch Specifies the current ETag of the file or directory resource that you are deleting.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFileOrDirectoryFromSystem: async (
      sessionId: string,
      fileOrDirectoryPath: string,
      ifMatch: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists(
        "deleteFileOrDirectoryFromSystem",
        "sessionId",
        sessionId
      );
      // verify required parameter 'fileOrDirectoryPath' is not null or undefined
      assertParamExists(
        "deleteFileOrDirectoryFromSystem",
        "fileOrDirectoryPath",
        fileOrDirectoryPath
      );
      // verify required parameter 'ifMatch' is not null or undefined
      assertParamExists("deleteFileOrDirectoryFromSystem", "ifMatch", ifMatch);
      const localVarPath = `/sessions/{sessionId}/files/{fileOrDirectoryPath}`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(
          `{${"fileOrDirectoryPath"}}`,
          encodeURIComponent(String(fileOrDirectoryPath))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (ifMatch != null) {
        localVarHeaderParameter["If-Match"] = String(ifMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a collection of directory members from a specified directory path.
     * @summary Get directory members
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} directoryPath Specifies the directory path. In the directory path, replace each forward slash with ~fs~.
     * @param {boolean} [showAll] Specifies whether to return hidden members in the directory.
     * @param {boolean} [expandPath] Specifies whether to return fully qualified paths in response links.
     * @param {number} [start] Specifies the offset of the first directory member to return. The default value is 0.
     * @param {number} [limit] Specifies the maximum number of members to return. The default value is 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDirectoryMembers: async (
      sessionId: string,
      directoryPath: string,
      showAll?: boolean,
      expandPath?: boolean,
      start?: number,
      limit?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getDirectoryMembers", "sessionId", sessionId);
      // verify required parameter 'directoryPath' is not null or undefined
      assertParamExists("getDirectoryMembers", "directoryPath", directoryPath);
      const localVarPath = `/sessions/{sessionId}/files/{directoryPath}/members`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(
          `{${"directoryPath"}}`,
          encodeURIComponent(String(directoryPath))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (showAll !== undefined) {
        localVarQueryParameter["showAll"] = showAll;
      }

      if (expandPath !== undefined) {
        localVarQueryParameter["expandPath"] = expandPath;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets contents of a file that is specified by the file path. If the server can determine the type of file that is returned, then the `Content-type` header returns the appropriate media type information. Otherwise, application/octet-stream data is returned for the `Content-type` header.
     * @summary Download file contents
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} filePath Specifies the file path. In the file path, replace each forward slash with ~fs~.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileContentFromSystem: async (
      sessionId: string,
      filePath: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getFileContentFromSystem", "sessionId", sessionId);
      // verify required parameter 'filePath' is not null or undefined
      assertParamExists("getFileContentFromSystem", "filePath", filePath);
      const localVarPath = `/sessions/{sessionId}/files/{filePath}/content`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"filePath"}}`, encodeURIComponent(String(filePath)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets file or directory properties at a specified path.
     * @summary Get file or directory properties
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} fileOrDirectoryPath Specifies the file or directory path. In the path value, replace each forward slash with ~fs~.
     * @param {boolean} [expandPath] Specifies whether to return fully qualified paths in response links.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileorDirectoryProperties: async (
      sessionId: string,
      fileOrDirectoryPath: string,
      expandPath?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getFileorDirectoryProperties", "sessionId", sessionId);
      // verify required parameter 'fileOrDirectoryPath' is not null or undefined
      assertParamExists(
        "getFileorDirectoryProperties",
        "fileOrDirectoryPath",
        fileOrDirectoryPath
      );
      const localVarPath = `/sessions/{sessionId}/files/{fileOrDirectoryPath}`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(
          `{${"fileOrDirectoryPath"}}`,
          encodeURIComponent(String(fileOrDirectoryPath))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (expandPath !== undefined) {
        localVarQueryParameter["expandPath"] = expandPath;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether the specified file or directory exists.
     * @summary Check for file or directory properties
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} fileOrDirectoryPath Specifies the file or directory path. In the path value, replace each forward slash with ~fs~.
     * @param {boolean} [expandPath] Specifies whether to return fully qualified paths in response links.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForFileorDirectoryProperties: async (
      sessionId: string,
      fileOrDirectoryPath: string,
      expandPath?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists(
        "headersForFileorDirectoryProperties",
        "sessionId",
        sessionId
      );
      // verify required parameter 'fileOrDirectoryPath' is not null or undefined
      assertParamExists(
        "headersForFileorDirectoryProperties",
        "fileOrDirectoryPath",
        fileOrDirectoryPath
      );
      const localVarPath = `/sessions/{sessionId}/files/{fileOrDirectoryPath}`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(
          `{${"fileOrDirectoryPath"}}`,
          encodeURIComponent(String(fileOrDirectoryPath))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (expandPath !== undefined) {
        localVarQueryParameter["expandPath"] = expandPath;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a file or replaces an existing file. An ETag is required when you replace an existing file.
     * @summary Upload file content
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} filePath Specifies the file path. In the file path, replace each forward slash with ~fs~.
     * @param {File} body Specifies the content to upload to the file.
     * @param {string} [ifMatch] Specifies the current ETag of the file resource that you are deleting.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFileContentOnSystem: async (
      sessionId: string,
      filePath: string,
      body: File,
      ifMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("updateFileContentOnSystem", "sessionId", sessionId);
      // verify required parameter 'filePath' is not null or undefined
      assertParamExists("updateFileContentOnSystem", "filePath", filePath);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("updateFileContentOnSystem", "body", body);
      const localVarPath = `/sessions/{sessionId}/files/{filePath}/content`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"filePath"}}`, encodeURIComponent(String(filePath)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (ifMatch != null) {
        localVarHeaderParameter["If-Match"] = String(ifMatch);
      }

      localVarHeaderParameter["Content-Type"] = "application/octet-stream";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Renames a file or directory at the specified location. Can also be used to move a file or directory to a location that you specify in the `path` element of the application/vnd.sas.compute.file.properties body. If no `path` is provided, the file is moved to the current working directory. The `move` action causes the path for the new file or directory to change.
     * @summary Rename a file or directory
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} fileOrDirectoryPath Specifies the file or directory path. In the path value, replace each forward slash with ~fs~.
     * @param {string} ifMatch Specifies the current ETag of the file or directory resource that you are renaming.
     * @param {FileProperties} fileProperties Specifies the file or directory &#x60;name&#x60; and &#x60;path&#x60; elements. The &#x60;name&#x60; element is required and the &#x60;path&#x60; element is optional. If specified, the \&#39;path\&#39; value can contain an absolute path or a path that is relative to the current working directory. Do not replace forward slash characters with ~fs~ for the &#x60;path&#x60; element.
     * @param {boolean} [overwrite] Specifies whether to force an overwrite of an existing file or directory if one of the same name exists at the destination path. If you specify true, the request replaces the existing file or directory.
     * @param {boolean} [expandPath] Specifies whether to return fully qualified paths in response links.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFileOrDirectoryOnSystem: async (
      sessionId: string,
      fileOrDirectoryPath: string,
      ifMatch: string,
      fileProperties: FileProperties,
      overwrite?: boolean,
      expandPath?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists(
        "updateFileOrDirectoryOnSystem",
        "sessionId",
        sessionId
      );
      // verify required parameter 'fileOrDirectoryPath' is not null or undefined
      assertParamExists(
        "updateFileOrDirectoryOnSystem",
        "fileOrDirectoryPath",
        fileOrDirectoryPath
      );
      // verify required parameter 'ifMatch' is not null or undefined
      assertParamExists("updateFileOrDirectoryOnSystem", "ifMatch", ifMatch);
      // verify required parameter 'fileProperties' is not null or undefined
      assertParamExists(
        "updateFileOrDirectoryOnSystem",
        "fileProperties",
        fileProperties
      );
      const localVarPath = `/sessions/{sessionId}/files/{fileOrDirectoryPath}`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(
          `{${"fileOrDirectoryPath"}}`,
          encodeURIComponent(String(fileOrDirectoryPath))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (overwrite !== undefined) {
        localVarQueryParameter["overwrite"] = overwrite;
      }

      if (expandPath !== undefined) {
        localVarQueryParameter["expandPath"] = expandPath;
      }

      if (ifMatch != null) {
        localVarHeaderParameter["If-Match"] = String(ifMatch);
      }

      localVarHeaderParameter["Content-Type"] =
        "application/vnd.sas.compute.file.properties+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        fileProperties,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FileSystemApi - functional programming interface
 * @export
 */
export const FileSystemApi = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    FileSystemApiAxiosParamCreator(configuration);
  return {
    /**
     * Copies a file or directory. Provide the path of the destination file or directory in the URI. Provide the path of the source file or directory in the request body. If you do not provide a path in the request body, then the current working directory is assumed.
     * @summary Copy a file or directory
     * @param {FileSystemApiCopyFileOrDirectoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async copyFileOrDirectory(
      requestParameters: FileSystemApiCopyFileOrDirectoryRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<FileProperties>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.copyFileOrDirectory(
          requestParameters.sessionId,
          requestParameters.destinationFileOrDirectoryPath,
          requestParameters.fileRequest,
          requestParameters.overwrite,
          requestParameters.expandPath,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Creates an empty file or directory. In the request body, set the `isDirectory` attribute to \'false\' for files and to \'true\' for a directory. The `name` attribute specifies the name of the new file or directory. Provide the path of the new file or directory either in the URI or in the `path` attribute in the request body. If you do not provide a path, then the new file or directory is created under the current working directory.
     * @summary Create an empty file or directory
     * @param {FileSystemApiCreateFileOrDirectoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createFileOrDirectory(
      requestParameters: FileSystemApiCreateFileOrDirectoryRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<FileProperties>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createFileOrDirectory(
          requestParameters.sessionId,
          requestParameters.fileOrDirectoryPath,
          requestParameters.fileProperties,
          requestParameters.expandPath,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Deletes a file or directory.
     * @summary Delete a file or directory
     * @param {FileSystemApiDeleteFileOrDirectoryFromSystemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFileOrDirectoryFromSystem(
      requestParameters: FileSystemApiDeleteFileOrDirectoryFromSystemRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteFileOrDirectoryFromSystem(
          requestParameters.sessionId,
          requestParameters.fileOrDirectoryPath,
          requestParameters.ifMatch,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns a collection of directory members from a specified directory path.
     * @summary Get directory members
     * @param {FileSystemApiGetDirectoryMembersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDirectoryMembers(
      requestParameters: FileSystemApiGetDirectoryMembersRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<FilePropertiesCollection>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDirectoryMembers(
          requestParameters.sessionId,
          requestParameters.directoryPath,
          requestParameters.showAll,
          requestParameters.expandPath,
          requestParameters.start,
          requestParameters.limit,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Gets contents of a file that is specified by the file path. If the server can determine the type of file that is returned, then the `Content-type` header returns the appropriate media type information. Otherwise, application/octet-stream data is returned for the `Content-type` header.
     * @summary Download file contents
     * @param {FileSystemApiGetFileContentFromSystemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFileContentFromSystem(
      requestParameters: FileSystemApiGetFileContentFromSystemRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getFileContentFromSystem(
          requestParameters.sessionId,
          requestParameters.filePath,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Gets file or directory properties at a specified path.
     * @summary Get file or directory properties
     * @param {FileSystemApiGetFileorDirectoryPropertiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFileorDirectoryProperties(
      requestParameters: FileSystemApiGetFileorDirectoryPropertiesRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<FileProperties>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getFileorDirectoryProperties(
          requestParameters.sessionId,
          requestParameters.fileOrDirectoryPath,
          requestParameters.expandPath,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether the specified file or directory exists.
     * @summary Check for file or directory properties
     * @param {FileSystemApiHeadersForFileorDirectoryPropertiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForFileorDirectoryProperties(
      requestParameters: FileSystemApiHeadersForFileorDirectoryPropertiesRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForFileorDirectoryProperties(
          requestParameters.sessionId,
          requestParameters.fileOrDirectoryPath,
          requestParameters.expandPath,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Creates a file or replaces an existing file. An ETag is required when you replace an existing file.
     * @summary Upload file content
     * @param {FileSystemApiUpdateFileContentOnSystemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateFileContentOnSystem(
      requestParameters: FileSystemApiUpdateFileContentOnSystemRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<FileProperties>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateFileContentOnSystem(
          requestParameters.sessionId,
          requestParameters.filePath,
          requestParameters.body,
          requestParameters.ifMatch,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Renames a file or directory at the specified location. Can also be used to move a file or directory to a location that you specify in the `path` element of the application/vnd.sas.compute.file.properties body. If no `path` is provided, the file is moved to the current working directory. The `move` action causes the path for the new file or directory to change.
     * @summary Rename a file or directory
     * @param {FileSystemApiUpdateFileOrDirectoryOnSystemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateFileOrDirectoryOnSystem(
      requestParameters: FileSystemApiUpdateFileOrDirectoryOnSystemRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<FileProperties>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateFileOrDirectoryOnSystem(
          requestParameters.sessionId,
          requestParameters.fileOrDirectoryPath,
          requestParameters.ifMatch,
          requestParameters.fileProperties,
          requestParameters.overwrite,
          requestParameters.expandPath,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },
  };
};

/**
 * Request parameters for copyFileOrDirectory operation in FileSystemApi.
 * @export
 * @interface FileSystemApiCopyFileOrDirectoryRequest
 */
export interface FileSystemApiCopyFileOrDirectoryRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof FileSystemApiCopyFileOrDirectory
   */
  readonly sessionId: string;

  /**
   * Specifies the destination file or directory path. In the path value, replace each forward slash with ~fs~.
   * @type {string}
   * @memberof FileSystemApiCopyFileOrDirectory
   */
  readonly destinationFileOrDirectoryPath: string;

  /**
   * Specifies the source file or directory &#x60;name&#x60; and &#x60;path&#x60; elements. The &#x60;name&#x60; element is required, and the &#x60;path&#x60; element is optional.
   * @type {FileRequest}
   * @memberof FileSystemApiCopyFileOrDirectory
   */
  readonly fileRequest: FileRequest;

  /**
   * Specifies whether to force an overwrite of an existing file or directory if one of the same name exists at the destination path. If you specify true, the request replaces the existing file or directory.
   * @type {boolean}
   * @memberof FileSystemApiCopyFileOrDirectory
   */
  readonly overwrite?: boolean;

  /**
   * Specifies whether to return fully qualified paths in response links.
   * @type {boolean}
   * @memberof FileSystemApiCopyFileOrDirectory
   */
  readonly expandPath?: boolean;
}

/**
 * Request parameters for createFileOrDirectory operation in FileSystemApi.
 * @export
 * @interface FileSystemApiCreateFileOrDirectoryRequest
 */
export interface FileSystemApiCreateFileOrDirectoryRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof FileSystemApiCreateFileOrDirectory
   */
  readonly sessionId: string;

  /**
   * Specifies the file or directory path. In the path value, replace each forward slash with ~fs~.
   * @type {string}
   * @memberof FileSystemApiCreateFileOrDirectory
   */
  readonly fileOrDirectoryPath: string;

  /**
   * Specifies the file or directory &#x60;name&#x60; and &#x60;path&#x60; elements. The &#x60;name&#x60; element is required and the &#x60;path&#x60; element is optional.
   * @type {FileProperties}
   * @memberof FileSystemApiCreateFileOrDirectory
   */
  readonly fileProperties: FileProperties;

  /**
   * Specifies whether to return fully qualified paths in response links.
   * @type {boolean}
   * @memberof FileSystemApiCreateFileOrDirectory
   */
  readonly expandPath?: boolean;
}

/**
 * Request parameters for deleteFileOrDirectoryFromSystem operation in FileSystemApi.
 * @export
 * @interface FileSystemApiDeleteFileOrDirectoryFromSystemRequest
 */
export interface FileSystemApiDeleteFileOrDirectoryFromSystemRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof FileSystemApiDeleteFileOrDirectoryFromSystem
   */
  readonly sessionId: string;

  /**
   * Specifies the file or directory path. In the path value, replace each forward slash with ~fs~.
   * @type {string}
   * @memberof FileSystemApiDeleteFileOrDirectoryFromSystem
   */
  readonly fileOrDirectoryPath: string;

  /**
   * Specifies the current ETag of the file or directory resource that you are deleting.
   * @type {string}
   * @memberof FileSystemApiDeleteFileOrDirectoryFromSystem
   */
  readonly ifMatch: string;
}

/**
 * Request parameters for getDirectoryMembers operation in FileSystemApi.
 * @export
 * @interface FileSystemApiGetDirectoryMembersRequest
 */
export interface FileSystemApiGetDirectoryMembersRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof FileSystemApiGetDirectoryMembers
   */
  readonly sessionId: string;

  /**
   * Specifies the directory path. In the directory path, replace each forward slash with ~fs~.
   * @type {string}
   * @memberof FileSystemApiGetDirectoryMembers
   */
  readonly directoryPath: string;

  /**
   * Specifies whether to return hidden members in the directory.
   * @type {boolean}
   * @memberof FileSystemApiGetDirectoryMembers
   */
  readonly showAll?: boolean;

  /**
   * Specifies whether to return fully qualified paths in response links.
   * @type {boolean}
   * @memberof FileSystemApiGetDirectoryMembers
   */
  readonly expandPath?: boolean;

  /**
   * Specifies the offset of the first directory member to return. The default value is 0.
   * @type {number}
   * @memberof FileSystemApiGetDirectoryMembers
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of members to return. The default value is 10.
   * @type {number}
   * @memberof FileSystemApiGetDirectoryMembers
   */
  readonly limit?: number;
}

/**
 * Request parameters for getFileContentFromSystem operation in FileSystemApi.
 * @export
 * @interface FileSystemApiGetFileContentFromSystemRequest
 */
export interface FileSystemApiGetFileContentFromSystemRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof FileSystemApiGetFileContentFromSystem
   */
  readonly sessionId: string;

  /**
   * Specifies the file path. In the file path, replace each forward slash with ~fs~.
   * @type {string}
   * @memberof FileSystemApiGetFileContentFromSystem
   */
  readonly filePath: string;
}

/**
 * Request parameters for getFileorDirectoryProperties operation in FileSystemApi.
 * @export
 * @interface FileSystemApiGetFileorDirectoryPropertiesRequest
 */
export interface FileSystemApiGetFileorDirectoryPropertiesRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof FileSystemApiGetFileorDirectoryProperties
   */
  readonly sessionId: string;

  /**
   * Specifies the file or directory path. In the path value, replace each forward slash with ~fs~.
   * @type {string}
   * @memberof FileSystemApiGetFileorDirectoryProperties
   */
  readonly fileOrDirectoryPath: string;

  /**
   * Specifies whether to return fully qualified paths in response links.
   * @type {boolean}
   * @memberof FileSystemApiGetFileorDirectoryProperties
   */
  readonly expandPath?: boolean;
}

/**
 * Request parameters for headersForFileorDirectoryProperties operation in FileSystemApi.
 * @export
 * @interface FileSystemApiHeadersForFileorDirectoryPropertiesRequest
 */
export interface FileSystemApiHeadersForFileorDirectoryPropertiesRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof FileSystemApiHeadersForFileorDirectoryProperties
   */
  readonly sessionId: string;

  /**
   * Specifies the file or directory path. In the path value, replace each forward slash with ~fs~.
   * @type {string}
   * @memberof FileSystemApiHeadersForFileorDirectoryProperties
   */
  readonly fileOrDirectoryPath: string;

  /**
   * Specifies whether to return fully qualified paths in response links.
   * @type {boolean}
   * @memberof FileSystemApiHeadersForFileorDirectoryProperties
   */
  readonly expandPath?: boolean;
}

/**
 * Request parameters for updateFileContentOnSystem operation in FileSystemApi.
 * @export
 * @interface FileSystemApiUpdateFileContentOnSystemRequest
 */
export interface FileSystemApiUpdateFileContentOnSystemRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof FileSystemApiUpdateFileContentOnSystem
   */
  readonly sessionId: string;

  /**
   * Specifies the file path. In the file path, replace each forward slash with ~fs~.
   * @type {string}
   * @memberof FileSystemApiUpdateFileContentOnSystem
   */
  readonly filePath: string;

  /**
   * Specifies the content to upload to the file.
   * @type {File}
   * @memberof FileSystemApiUpdateFileContentOnSystem
   */
  readonly body: File;

  /**
   * Specifies the current ETag of the file resource that you are deleting.
   * @type {string}
   * @memberof FileSystemApiUpdateFileContentOnSystem
   */
  readonly ifMatch?: string;
}

/**
 * Request parameters for updateFileOrDirectoryOnSystem operation in FileSystemApi.
 * @export
 * @interface FileSystemApiUpdateFileOrDirectoryOnSystemRequest
 */
export interface FileSystemApiUpdateFileOrDirectoryOnSystemRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof FileSystemApiUpdateFileOrDirectoryOnSystem
   */
  readonly sessionId: string;

  /**
   * Specifies the file or directory path. In the path value, replace each forward slash with ~fs~.
   * @type {string}
   * @memberof FileSystemApiUpdateFileOrDirectoryOnSystem
   */
  readonly fileOrDirectoryPath: string;

  /**
   * Specifies the current ETag of the file or directory resource that you are renaming.
   * @type {string}
   * @memberof FileSystemApiUpdateFileOrDirectoryOnSystem
   */
  readonly ifMatch: string;

  /**
   * Specifies the file or directory &#x60;name&#x60; and &#x60;path&#x60; elements. The &#x60;name&#x60; element is required and the &#x60;path&#x60; element is optional. If specified, the \&#39;path\&#39; value can contain an absolute path or a path that is relative to the current working directory. Do not replace forward slash characters with ~fs~ for the &#x60;path&#x60; element.
   * @type {FileProperties}
   * @memberof FileSystemApiUpdateFileOrDirectoryOnSystem
   */
  readonly fileProperties: FileProperties;

  /**
   * Specifies whether to force an overwrite of an existing file or directory if one of the same name exists at the destination path. If you specify true, the request replaces the existing file or directory.
   * @type {boolean}
   * @memberof FileSystemApiUpdateFileOrDirectoryOnSystem
   */
  readonly overwrite?: boolean;

  /**
   * Specifies whether to return fully qualified paths in response links.
   * @type {boolean}
   * @memberof FileSystemApiUpdateFileOrDirectoryOnSystem
   */
  readonly expandPath?: boolean;
}

/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Creates or assigns a fileref for a session.
     * @summary Assign a fileref
     * @param {string} sessionId Specifies the ID of the session.
     * @param {FilerefRequest} filerefRequest Specifies a fileref creation request.
     * @param {string} [parent] To create a fileref to a member of a directory fileref, specify the directory fileref as the parent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignFileref: async (
      sessionId: string,
      filerefRequest: FilerefRequest,
      parent?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("assignFileref", "sessionId", sessionId);
      // verify required parameter 'filerefRequest' is not null or undefined
      assertParamExists("assignFileref", "filerefRequest", filerefRequest);
      const localVarPath = `/sessions/{sessionId}/filerefs`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (parent !== undefined) {
        localVarQueryParameter["parent"] = parent;
      }

      localVarHeaderParameter["Content-Type"] =
        "application/vnd.sas.compute.fileref.request+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        filerefRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes the file that is referenced by the fileref.
     * @summary Delete a file
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} fileref Specifies the fileref name. The name must be eight or fewer characters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile: async (
      sessionId: string,
      fileref: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("deleteFile", "sessionId", sessionId);
      // verify required parameter 'fileref' is not null or undefined
      assertParamExists("deleteFile", "fileref", fileref);
      const localVarPath = `/sessions/{sessionId}/filerefs/{fileref}/content`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"fileref"}}`, encodeURIComponent(String(fileref)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deassigns the specified fileref in a session.
     * @summary Deassign a fileref
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} fileref Specifies the fileref name. The name must be eight or fewer characters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFileref: async (
      sessionId: string,
      fileref: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("deleteFileref", "sessionId", sessionId);
      // verify required parameter 'fileref' is not null or undefined
      assertParamExists("deleteFileref", "fileref", fileref);
      const localVarPath = `/sessions/{sessionId}/filerefs/{fileref}`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"fileref"}}`, encodeURIComponent(String(fileref)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets information about a member of a directory fileref.
     * @summary Get a directory member
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} fileref Specifies the fileref name. The name must be eight or fewer characters.
     * @param {string} member Specifies the name of the member to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDirectoryFileref: async (
      sessionId: string,
      fileref: string,
      member: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getDirectoryFileref", "sessionId", sessionId);
      // verify required parameter 'fileref' is not null or undefined
      assertParamExists("getDirectoryFileref", "fileref", fileref);
      // verify required parameter 'member' is not null or undefined
      assertParamExists("getDirectoryFileref", "member", member);
      const localVarPath = `/sessions/{sessionId}/filerefs/{fileref}#directory`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"fileref"}}`, encodeURIComponent(String(fileref)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (member !== undefined) {
        localVarQueryParameter["member"] = member;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a directory listing when a fileref refers to a directory. A collection of directory members is returned.
     * @summary Get directory contents
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} fileref Specifies the fileref name. The name must be eight or fewer characters.
     * @param {number} [start] Specifies the offset of the first directory member to return. The default value is \&quot;0\&quot;.
     * @param {number} [limit] Specifies the maximum number of members to return. The default value is \&quot;10\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDirectoryFilerefContents: async (
      sessionId: string,
      fileref: string,
      start?: number,
      limit?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getDirectoryFilerefContents", "sessionId", sessionId);
      // verify required parameter 'fileref' is not null or undefined
      assertParamExists("getDirectoryFilerefContents", "fileref", fileref);
      const localVarPath =
        `/sessions/{sessionId}/filerefs/{fileref}/content#directory`
          .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
          .replace(`{${"fileref"}}`, encodeURIComponent(String(fileref)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets contents of a file that you refer to by a fileref. If the server can determine the type of file that is returned, the Content-type header returns the appropriate media type information. Otherwise, application/octet-stream data is returned for the Content-type header.
     * @summary Download a file
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} fileref Specifies the fileref name. The name must be eight or fewer characters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFile: async (
      sessionId: string,
      fileref: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getFile", "sessionId", sessionId);
      // verify required parameter 'fileref' is not null or undefined
      assertParamExists("getFile", "fileref", fileref);
      const localVarPath = `/sessions/{sessionId}/filerefs/{fileref}/content`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"fileref"}}`, encodeURIComponent(String(fileref)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get file information from a fileref in a session.
     * @summary Get fileref information
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} fileref Specifies the fileref name. The name must be eight or fewer characters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileref: async (
      sessionId: string,
      fileref: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getFileref", "sessionId", sessionId);
      // verify required parameter 'fileref' is not null or undefined
      assertParamExists("getFileref", "fileref", fileref);
      const localVarPath = `/sessions/{sessionId}/filerefs/{fileref}`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"fileref"}}`, encodeURIComponent(String(fileref)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets fileref summary information for a fileref in a session.
     * @summary Get fileref summary information
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} fileref Specifies the fileref name. The name must be eight or fewer characters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFilerefSummary: async (
      sessionId: string,
      fileref: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getFilerefSummary", "sessionId", sessionId);
      // verify required parameter 'fileref' is not null or undefined
      assertParamExists("getFilerefSummary", "fileref", fileref);
      const localVarPath = `/sessions/{sessionId}/filerefs/{fileref}#summary`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"fileref"}}`, encodeURIComponent(String(fileref)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of all the filerefs that are defined for a session.
     * @summary List filerefs in a session
     * @param {'application/vnd.sas.compute.fileref+json'} acceptItem Specifies the desired fileref representation.&lt;br&gt; The Accept-Item options are: &lt;ul&gt; &lt;li&gt;application/vnd.sas.compute.fileref+json &lt;li&gt;application/vnd.sas.compute.fileref.summary+json &lt;li&gt;blank &lt;/ul&gt; If the application/vnd.sas.compute.fileref.summary+json type is specified or no Accept-Item header is specified, the filerefs are returned as summary representation fileref objects.
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} [filter] Specifies filter criteria for returned filerefs.
     * @param {number} [start] Specifies the offset of the first fileref to return.
     * @param {number} [limit] Specifies the maximum number of filerefs to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFilerefs: async (
      acceptItem: "application/vnd.sas.compute.fileref+json",
      sessionId: string,
      filter?: string,
      start?: number,
      limit?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'acceptItem' is not null or undefined
      assertParamExists("getFilerefs", "acceptItem", acceptItem);
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getFilerefs", "sessionId", sessionId);
      const localVarPath = `/sessions/{sessionId}/filerefs`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (filter !== undefined) {
        localVarQueryParameter["filter"] = filter;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (acceptItem != null) {
        localVarHeaderParameter["Accept-Item"] = String(acceptItem);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether the specified fileref exists in a session.
     * @summary Check for a fileref
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} fileref Specifies the fileref name. The name must be eight or fewer characters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForFileref: async (
      sessionId: string,
      fileref: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForFileref", "sessionId", sessionId);
      // verify required parameter 'fileref' is not null or undefined
      assertParamExists("headersForFileref", "fileref", fileref);
      const localVarPath = `/sessions/{sessionId}/filerefs/{fileref}`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"fileref"}}`, encodeURIComponent(String(fileref)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether the file service is available for a session.
     * @summary Check endpoint availability
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} [filter] Specifies the filter criteria for returned filerefs.
     * @param {number} [start] Specifies the offset of the first fileref to return. The default value is \&quot;0\&quot;.
     * @param {number} [limit] Specifies the maximum number of filerefs to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForFilerefs: async (
      sessionId: string,
      filter?: string,
      start?: number,
      limit?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForFilerefs", "sessionId", sessionId);
      const localVarPath = `/sessions/{sessionId}/filerefs`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (filter !== undefined) {
        localVarQueryParameter["filter"] = filter;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether a file is available for download.
     * @summary Check file availability
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} fileref Specifies the fileref name. The name must be eight or fewer characters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForGetFile: async (
      sessionId: string,
      fileref: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForGetFile", "sessionId", sessionId);
      // verify required parameter 'fileref' is not null or undefined
      assertParamExists("headersForGetFile", "fileref", fileref);
      const localVarPath = `/sessions/{sessionId}/filerefs/{fileref}/content`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"fileref"}}`, encodeURIComponent(String(fileref)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Uploads a physical file that is associated with a fileref.
     * @summary Upload a file
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} fileref Specifies the fileref name. The name must be eight or fewer characters.
     * @param {string} ifMatch Specifies the ETag of the fileref that you are updating.
     * @param {File} body Specifies the data to upload to the fileref.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFileContent: async (
      sessionId: string,
      fileref: string,
      ifMatch: string,
      body: File,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("updateFileContent", "sessionId", sessionId);
      // verify required parameter 'fileref' is not null or undefined
      assertParamExists("updateFileContent", "fileref", fileref);
      // verify required parameter 'ifMatch' is not null or undefined
      assertParamExists("updateFileContent", "ifMatch", ifMatch);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("updateFileContent", "body", body);
      const localVarPath = `/sessions/{sessionId}/filerefs/{fileref}/content`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"fileref"}}`, encodeURIComponent(String(fileref)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (ifMatch != null) {
        localVarHeaderParameter["If-Match"] = String(ifMatch);
      }

      localVarHeaderParameter["Content-Type"] = "application/octet-stream";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApi = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates or assigns a fileref for a session.
     * @summary Assign a fileref
     * @param {FilesApiAssignFilerefRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assignFileref(
      requestParameters: FilesApiAssignFilerefRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<Fileref>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.assignFileref(
        requestParameters.sessionId,
        requestParameters.filerefRequest,
        requestParameters.parent,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Deletes the file that is referenced by the fileref.
     * @summary Delete a file
     * @param {FilesApiDeleteFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFile(
      requestParameters: FilesApiDeleteFileRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFile(
        requestParameters.sessionId,
        requestParameters.fileref,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Deassigns the specified fileref in a session.
     * @summary Deassign a fileref
     * @param {FilesApiDeleteFilerefRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFileref(
      requestParameters: FilesApiDeleteFilerefRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFileref(
        requestParameters.sessionId,
        requestParameters.fileref,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Gets information about a member of a directory fileref.
     * @summary Get a directory member
     * @param {FilesApiGetDirectoryFilerefRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDirectoryFileref(
      requestParameters: FilesApiGetDirectoryFilerefRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<DirMember>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDirectoryFileref(
          requestParameters.sessionId,
          requestParameters.fileref,
          requestParameters.member,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns a directory listing when a fileref refers to a directory. A collection of directory members is returned.
     * @summary Get directory contents
     * @param {FilesApiGetDirectoryFilerefContentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDirectoryFilerefContents(
      requestParameters: FilesApiGetDirectoryFilerefContentsRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<DirectoryCollection>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDirectoryFilerefContents(
          requestParameters.sessionId,
          requestParameters.fileref,
          requestParameters.start,
          requestParameters.limit,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Gets contents of a file that you refer to by a fileref. If the server can determine the type of file that is returned, the Content-type header returns the appropriate media type information. Otherwise, application/octet-stream data is returned for the Content-type header.
     * @summary Download a file
     * @param {FilesApiGetFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFile(
      requestParameters: FilesApiGetFileRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFile(
        requestParameters.sessionId,
        requestParameters.fileref,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Get file information from a fileref in a session.
     * @summary Get fileref information
     * @param {FilesApiGetFilerefRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFileref(
      requestParameters: FilesApiGetFilerefRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<Fileref>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFileref(
        requestParameters.sessionId,
        requestParameters.fileref,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Gets fileref summary information for a fileref in a session.
     * @summary Get fileref summary information
     * @param {FilesApiGetFilerefSummaryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFilerefSummary(
      requestParameters: FilesApiGetFilerefSummaryRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<FilerefSummary>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getFilerefSummary(
          requestParameters.sessionId,
          requestParameters.fileref,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns a list of all the filerefs that are defined for a session.
     * @summary List filerefs in a session
     * @param {FilesApiGetFilerefsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFilerefs(
      requestParameters: FilesApiGetFilerefsRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<FilerefSummaryCollection>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFilerefs(
        requestParameters.acceptItem,
        requestParameters.sessionId,
        requestParameters.filter,
        requestParameters.start,
        requestParameters.limit,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether the specified fileref exists in a session.
     * @summary Check for a fileref
     * @param {FilesApiHeadersForFilerefRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForFileref(
      requestParameters: FilesApiHeadersForFilerefRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForFileref(
          requestParameters.sessionId,
          requestParameters.fileref,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether the file service is available for a session.
     * @summary Check endpoint availability
     * @param {FilesApiHeadersForFilerefsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForFilerefs(
      requestParameters: FilesApiHeadersForFilerefsRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForFilerefs(
          requestParameters.sessionId,
          requestParameters.filter,
          requestParameters.start,
          requestParameters.limit,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether a file is available for download.
     * @summary Check file availability
     * @param {FilesApiHeadersForGetFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForGetFile(
      requestParameters: FilesApiHeadersForGetFileRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForGetFile(
          requestParameters.sessionId,
          requestParameters.fileref,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Uploads a physical file that is associated with a fileref.
     * @summary Upload a file
     * @param {FilesApiUpdateFileContentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateFileContent(
      requestParameters: FilesApiUpdateFileContentRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateFileContent(
          requestParameters.sessionId,
          requestParameters.fileref,
          requestParameters.ifMatch,
          requestParameters.body,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },
  };
};

/**
 * Request parameters for assignFileref operation in FilesApi.
 * @export
 * @interface FilesApiAssignFilerefRequest
 */
export interface FilesApiAssignFilerefRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof FilesApiAssignFileref
   */
  readonly sessionId: string;

  /**
   * Specifies a fileref creation request.
   * @type {FilerefRequest}
   * @memberof FilesApiAssignFileref
   */
  readonly filerefRequest: FilerefRequest;

  /**
   * To create a fileref to a member of a directory fileref, specify the directory fileref as the parent.
   * @type {string}
   * @memberof FilesApiAssignFileref
   */
  readonly parent?: string;
}

/**
 * Request parameters for deleteFile operation in FilesApi.
 * @export
 * @interface FilesApiDeleteFileRequest
 */
export interface FilesApiDeleteFileRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof FilesApiDeleteFile
   */
  readonly sessionId: string;

  /**
   * Specifies the fileref name. The name must be eight or fewer characters.
   * @type {string}
   * @memberof FilesApiDeleteFile
   */
  readonly fileref: string;
}

/**
 * Request parameters for deleteFileref operation in FilesApi.
 * @export
 * @interface FilesApiDeleteFilerefRequest
 */
export interface FilesApiDeleteFilerefRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof FilesApiDeleteFileref
   */
  readonly sessionId: string;

  /**
   * Specifies the fileref name. The name must be eight or fewer characters.
   * @type {string}
   * @memberof FilesApiDeleteFileref
   */
  readonly fileref: string;
}

/**
 * Request parameters for getDirectoryFileref operation in FilesApi.
 * @export
 * @interface FilesApiGetDirectoryFilerefRequest
 */
export interface FilesApiGetDirectoryFilerefRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof FilesApiGetDirectoryFileref
   */
  readonly sessionId: string;

  /**
   * Specifies the fileref name. The name must be eight or fewer characters.
   * @type {string}
   * @memberof FilesApiGetDirectoryFileref
   */
  readonly fileref: string;

  /**
   * Specifies the name of the member to return.
   * @type {string}
   * @memberof FilesApiGetDirectoryFileref
   */
  readonly member: string;
}

/**
 * Request parameters for getDirectoryFilerefContents operation in FilesApi.
 * @export
 * @interface FilesApiGetDirectoryFilerefContentsRequest
 */
export interface FilesApiGetDirectoryFilerefContentsRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof FilesApiGetDirectoryFilerefContents
   */
  readonly sessionId: string;

  /**
   * Specifies the fileref name. The name must be eight or fewer characters.
   * @type {string}
   * @memberof FilesApiGetDirectoryFilerefContents
   */
  readonly fileref: string;

  /**
   * Specifies the offset of the first directory member to return. The default value is \&quot;0\&quot;.
   * @type {number}
   * @memberof FilesApiGetDirectoryFilerefContents
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of members to return. The default value is \&quot;10\&quot;.
   * @type {number}
   * @memberof FilesApiGetDirectoryFilerefContents
   */
  readonly limit?: number;
}

/**
 * Request parameters for getFile operation in FilesApi.
 * @export
 * @interface FilesApiGetFileRequest
 */
export interface FilesApiGetFileRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof FilesApiGetFile
   */
  readonly sessionId: string;

  /**
   * Specifies the fileref name. The name must be eight or fewer characters.
   * @type {string}
   * @memberof FilesApiGetFile
   */
  readonly fileref: string;
}

/**
 * Request parameters for getFileref operation in FilesApi.
 * @export
 * @interface FilesApiGetFilerefRequest
 */
export interface FilesApiGetFilerefRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof FilesApiGetFileref
   */
  readonly sessionId: string;

  /**
   * Specifies the fileref name. The name must be eight or fewer characters.
   * @type {string}
   * @memberof FilesApiGetFileref
   */
  readonly fileref: string;
}

/**
 * Request parameters for getFilerefSummary operation in FilesApi.
 * @export
 * @interface FilesApiGetFilerefSummaryRequest
 */
export interface FilesApiGetFilerefSummaryRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof FilesApiGetFilerefSummary
   */
  readonly sessionId: string;

  /**
   * Specifies the fileref name. The name must be eight or fewer characters.
   * @type {string}
   * @memberof FilesApiGetFilerefSummary
   */
  readonly fileref: string;
}

/**
 * Request parameters for getFilerefs operation in FilesApi.
 * @export
 * @interface FilesApiGetFilerefsRequest
 */
export interface FilesApiGetFilerefsRequest {
  /**
   * Specifies the desired fileref representation.&lt;br&gt; The Accept-Item options are: &lt;ul&gt; &lt;li&gt;application/vnd.sas.compute.fileref+json &lt;li&gt;application/vnd.sas.compute.fileref.summary+json &lt;li&gt;blank &lt;/ul&gt; If the application/vnd.sas.compute.fileref.summary+json type is specified or no Accept-Item header is specified, the filerefs are returned as summary representation fileref objects.
   * @type {'application/vnd.sas.compute.fileref+json'}
   * @memberof FilesApiGetFilerefs
   */
  readonly acceptItem: "application/vnd.sas.compute.fileref+json";

  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof FilesApiGetFilerefs
   */
  readonly sessionId: string;

  /**
   * Specifies filter criteria for returned filerefs.
   * @type {string}
   * @memberof FilesApiGetFilerefs
   */
  readonly filter?: string;

  /**
   * Specifies the offset of the first fileref to return.
   * @type {number}
   * @memberof FilesApiGetFilerefs
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of filerefs to return.
   * @type {number}
   * @memberof FilesApiGetFilerefs
   */
  readonly limit?: number;
}

/**
 * Request parameters for headersForFileref operation in FilesApi.
 * @export
 * @interface FilesApiHeadersForFilerefRequest
 */
export interface FilesApiHeadersForFilerefRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof FilesApiHeadersForFileref
   */
  readonly sessionId: string;

  /**
   * Specifies the fileref name. The name must be eight or fewer characters.
   * @type {string}
   * @memberof FilesApiHeadersForFileref
   */
  readonly fileref: string;
}

/**
 * Request parameters for headersForFilerefs operation in FilesApi.
 * @export
 * @interface FilesApiHeadersForFilerefsRequest
 */
export interface FilesApiHeadersForFilerefsRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof FilesApiHeadersForFilerefs
   */
  readonly sessionId: string;

  /**
   * Specifies the filter criteria for returned filerefs.
   * @type {string}
   * @memberof FilesApiHeadersForFilerefs
   */
  readonly filter?: string;

  /**
   * Specifies the offset of the first fileref to return. The default value is \&quot;0\&quot;.
   * @type {number}
   * @memberof FilesApiHeadersForFilerefs
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of filerefs to return.
   * @type {number}
   * @memberof FilesApiHeadersForFilerefs
   */
  readonly limit?: number;
}

/**
 * Request parameters for headersForGetFile operation in FilesApi.
 * @export
 * @interface FilesApiHeadersForGetFileRequest
 */
export interface FilesApiHeadersForGetFileRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof FilesApiHeadersForGetFile
   */
  readonly sessionId: string;

  /**
   * Specifies the fileref name. The name must be eight or fewer characters.
   * @type {string}
   * @memberof FilesApiHeadersForGetFile
   */
  readonly fileref: string;
}

/**
 * Request parameters for updateFileContent operation in FilesApi.
 * @export
 * @interface FilesApiUpdateFileContentRequest
 */
export interface FilesApiUpdateFileContentRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof FilesApiUpdateFileContent
   */
  readonly sessionId: string;

  /**
   * Specifies the fileref name. The name must be eight or fewer characters.
   * @type {string}
   * @memberof FilesApiUpdateFileContent
   */
  readonly fileref: string;

  /**
   * Specifies the ETag of the fileref that you are updating.
   * @type {string}
   * @memberof FilesApiUpdateFileContent
   */
  readonly ifMatch: string;

  /**
   * Specifies the data to upload to the fileref.
   * @type {File}
   * @memberof FilesApiUpdateFileContent
   */
  readonly body: File;
}

/**
 * FormatsApi - axios parameter creator
 * @export
 */
export const FormatsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Gets format information from a session.
     * @summary Get format information
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} formatName Specifies the format name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFormat: async (
      sessionId: string,
      formatName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getFormat", "sessionId", sessionId);
      // verify required parameter 'formatName' is not null or undefined
      assertParamExists("getFormat", "formatName", formatName);
      const localVarPath = `/sessions/{sessionId}/formats/{formatName}`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"formatName"}}`, encodeURIComponent(String(formatName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of all the formats that are defined for a session.
     * @summary List formats in a session
     * @param {string} sessionId Specifies the ID of the session.
     * @param {'application/vnd.sas.format.summary+json' | 'application/vnd.sas.format+json'} [acceptItem] Specifies the desired format representation.&lt;br&gt; The Accept-Item options are: &lt;ul&gt; &lt;li&gt;application/vnd.sas.format+json &lt;li&gt;application/vnd.sas.format.summary+json &lt;li&gt;blank &lt;/ul&gt; If the application/vnd.sas.format.summary+json type is specified or no Accept-Item header is specified, then the formats are returned as summary representation format objects.
     * @param {string} [filter] Specifies filter criteria for returned formats.
     * @param {number} [start] Specifies the offset of the first format to return.
     * @param {number} [limit] Specifies the maximum number of formats to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFormats: async (
      sessionId: string,
      acceptItem?:
        | "application/vnd.sas.format.summary+json"
        | "application/vnd.sas.format+json",
      filter?: string,
      start?: number,
      limit?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getFormats", "sessionId", sessionId);
      const localVarPath = `/sessions/{sessionId}/formats`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (filter !== undefined) {
        localVarQueryParameter["filter"] = filter;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (acceptItem != null) {
        localVarHeaderParameter["Accept-Item"] = String(acceptItem);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether the specified format exists in a session.
     * @summary Check for a format
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} formatName Specifies the format name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForFormat: async (
      sessionId: string,
      formatName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForFormat", "sessionId", sessionId);
      // verify required parameter 'formatName' is not null or undefined
      assertParamExists("headersForFormat", "formatName", formatName);
      const localVarPath = `/sessions/{sessionId}/formats/{formatName}`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"formatName"}}`, encodeURIComponent(String(formatName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether the formats endpoint is available for a session.
     * @summary Check endpoint availability
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} [filter] Specifies the filter criteria for returned formats.
     * @param {number} [start] Specifies the offset of the first format to return. The default value is 0.
     * @param {number} [limit] Specifies the maximum number of formats to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForFormats: async (
      sessionId: string,
      filter?: string,
      start?: number,
      limit?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForFormats", "sessionId", sessionId);
      const localVarPath = `/sessions/{sessionId}/formats`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (filter !== undefined) {
        localVarQueryParameter["filter"] = filter;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FormatsApi - functional programming interface
 * @export
 */
export const FormatsApi = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FormatsApiAxiosParamCreator(configuration);
  return {
    /**
     * Gets format information from a session.
     * @summary Get format information
     * @param {FormatsApiGetFormatRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFormat(
      requestParameters: FormatsApiGetFormatRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<Format>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFormat(
        requestParameters.sessionId,
        requestParameters.formatName,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns a list of all the formats that are defined for a session.
     * @summary List formats in a session
     * @param {FormatsApiGetFormatsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFormats(
      requestParameters: FormatsApiGetFormatsRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<FormatSummaryCollection>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFormats(
        requestParameters.sessionId,
        requestParameters.acceptItem,
        requestParameters.filter,
        requestParameters.start,
        requestParameters.limit,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether the specified format exists in a session.
     * @summary Check for a format
     * @param {FormatsApiHeadersForFormatRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForFormat(
      requestParameters: FormatsApiHeadersForFormatRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForFormat(
          requestParameters.sessionId,
          requestParameters.formatName,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether the formats endpoint is available for a session.
     * @summary Check endpoint availability
     * @param {FormatsApiHeadersForFormatsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForFormats(
      requestParameters: FormatsApiHeadersForFormatsRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForFormats(
          requestParameters.sessionId,
          requestParameters.filter,
          requestParameters.start,
          requestParameters.limit,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },
  };
};

/**
 * Request parameters for getFormat operation in FormatsApi.
 * @export
 * @interface FormatsApiGetFormatRequest
 */
export interface FormatsApiGetFormatRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof FormatsApiGetFormat
   */
  readonly sessionId: string;

  /**
   * Specifies the format name.
   * @type {string}
   * @memberof FormatsApiGetFormat
   */
  readonly formatName: string;
}

/**
 * Request parameters for getFormats operation in FormatsApi.
 * @export
 * @interface FormatsApiGetFormatsRequest
 */
export interface FormatsApiGetFormatsRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof FormatsApiGetFormats
   */
  readonly sessionId: string;

  /**
   * Specifies the desired format representation.&lt;br&gt; The Accept-Item options are: &lt;ul&gt; &lt;li&gt;application/vnd.sas.format+json &lt;li&gt;application/vnd.sas.format.summary+json &lt;li&gt;blank &lt;/ul&gt; If the application/vnd.sas.format.summary+json type is specified or no Accept-Item header is specified, then the formats are returned as summary representation format objects.
   * @type {'application/vnd.sas.format.summary+json' | 'application/vnd.sas.format+json'}
   * @memberof FormatsApiGetFormats
   */
  readonly acceptItem?:
    | "application/vnd.sas.format.summary+json"
    | "application/vnd.sas.format+json";

  /**
   * Specifies filter criteria for returned formats.
   * @type {string}
   * @memberof FormatsApiGetFormats
   */
  readonly filter?: string;

  /**
   * Specifies the offset of the first format to return.
   * @type {number}
   * @memberof FormatsApiGetFormats
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of formats to return.
   * @type {number}
   * @memberof FormatsApiGetFormats
   */
  readonly limit?: number;
}

/**
 * Request parameters for headersForFormat operation in FormatsApi.
 * @export
 * @interface FormatsApiHeadersForFormatRequest
 */
export interface FormatsApiHeadersForFormatRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof FormatsApiHeadersForFormat
   */
  readonly sessionId: string;

  /**
   * Specifies the format name.
   * @type {string}
   * @memberof FormatsApiHeadersForFormat
   */
  readonly formatName: string;
}

/**
 * Request parameters for headersForFormats operation in FormatsApi.
 * @export
 * @interface FormatsApiHeadersForFormatsRequest
 */
export interface FormatsApiHeadersForFormatsRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof FormatsApiHeadersForFormats
   */
  readonly sessionId: string;

  /**
   * Specifies the filter criteria for returned formats.
   * @type {string}
   * @memberof FormatsApiHeadersForFormats
   */
  readonly filter?: string;

  /**
   * Specifies the offset of the first format to return. The default value is 0.
   * @type {number}
   * @memberof FormatsApiHeadersForFormats
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of formats to return.
   * @type {number}
   * @memberof FormatsApiHeadersForFormats
   */
  readonly limit?: number;
}

/**
 * InformatsApi - axios parameter creator
 * @export
 */
export const InformatsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Gets informat information from a session.
     * @summary Get informat information
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} informatName Specifies the informat name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInformat: async (
      sessionId: string,
      informatName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getInformat", "sessionId", sessionId);
      // verify required parameter 'informatName' is not null or undefined
      assertParamExists("getInformat", "informatName", informatName);
      const localVarPath = `/sessions/{sessionId}/informats/{informatName}`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(
          `{${"informatName"}}`,
          encodeURIComponent(String(informatName))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of all the informats that are defined for a session.
     * @summary List informats in a session
     * @param {string} sessionId Specifies the ID of the session.
     * @param {'application/vnd.sas.format.summary+json' | 'application/vnd.sas.format+json'} [acceptItem] Specifies the desired format representation.&lt;br&gt; The Accept-Item options are: &lt;ul&gt; &lt;li&gt;application/vnd.sas.format+json &lt;li&gt;application/vnd.sas.format.summary+json &lt;li&gt;blank &lt;/ul&gt; If the application/vnd.sas.format.summary+json type is specified or no Accept-Item header is specified, then the formats are returned as summary representation format objects.
     * @param {string} [filter] Specifies filter criteria for returned informats.
     * @param {number} [start] Specifies the offset of the first informat to return.
     * @param {number} [limit] Specifies the maximum number of informats to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInformats: async (
      sessionId: string,
      acceptItem?:
        | "application/vnd.sas.format.summary+json"
        | "application/vnd.sas.format+json",
      filter?: string,
      start?: number,
      limit?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getInformats", "sessionId", sessionId);
      const localVarPath = `/sessions/{sessionId}/informats`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (filter !== undefined) {
        localVarQueryParameter["filter"] = filter;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (acceptItem != null) {
        localVarHeaderParameter["Accept-Item"] = String(acceptItem);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether the specified informat exists in a session.
     * @summary Check for an informat
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} informatName Specifies the informat name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForInformat: async (
      sessionId: string,
      informatName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForInformat", "sessionId", sessionId);
      // verify required parameter 'informatName' is not null or undefined
      assertParamExists("headersForInformat", "informatName", informatName);
      const localVarPath = `/sessions/{sessionId}/informats/{informatName}`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(
          `{${"informatName"}}`,
          encodeURIComponent(String(informatName))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether the informats endpoint is available for a session.
     * @summary Check endpoint availability
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} [filter] Specifies the filter criteria for returned informats.
     * @param {number} [start] Specifies the offset of the first informat to return. The default value is 0.
     * @param {number} [limit] Specifies the maximum number of informats to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForInformats: async (
      sessionId: string,
      filter?: string,
      start?: number,
      limit?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForInformats", "sessionId", sessionId);
      const localVarPath = `/sessions/{sessionId}/informats`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (filter !== undefined) {
        localVarQueryParameter["filter"] = filter;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * InformatsApi - functional programming interface
 * @export
 */
export const InformatsApi = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    InformatsApiAxiosParamCreator(configuration);
  return {
    /**
     * Gets informat information from a session.
     * @summary Get informat information
     * @param {InformatsApiGetInformatRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInformat(
      requestParameters: InformatsApiGetInformatRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<Format>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getInformat(
        requestParameters.sessionId,
        requestParameters.informatName,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns a list of all the informats that are defined for a session.
     * @summary List informats in a session
     * @param {InformatsApiGetInformatsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInformats(
      requestParameters: InformatsApiGetInformatsRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<FormatSummaryCollection>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getInformats(
        requestParameters.sessionId,
        requestParameters.acceptItem,
        requestParameters.filter,
        requestParameters.start,
        requestParameters.limit,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether the specified informat exists in a session.
     * @summary Check for an informat
     * @param {InformatsApiHeadersForInformatRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForInformat(
      requestParameters: InformatsApiHeadersForInformatRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForInformat(
          requestParameters.sessionId,
          requestParameters.informatName,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether the informats endpoint is available for a session.
     * @summary Check endpoint availability
     * @param {InformatsApiHeadersForInformatsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForInformats(
      requestParameters: InformatsApiHeadersForInformatsRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForInformats(
          requestParameters.sessionId,
          requestParameters.filter,
          requestParameters.start,
          requestParameters.limit,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },
  };
};

/**
 * Request parameters for getInformat operation in InformatsApi.
 * @export
 * @interface InformatsApiGetInformatRequest
 */
export interface InformatsApiGetInformatRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof InformatsApiGetInformat
   */
  readonly sessionId: string;

  /**
   * Specifies the informat name.
   * @type {string}
   * @memberof InformatsApiGetInformat
   */
  readonly informatName: string;
}

/**
 * Request parameters for getInformats operation in InformatsApi.
 * @export
 * @interface InformatsApiGetInformatsRequest
 */
export interface InformatsApiGetInformatsRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof InformatsApiGetInformats
   */
  readonly sessionId: string;

  /**
   * Specifies the desired format representation.&lt;br&gt; The Accept-Item options are: &lt;ul&gt; &lt;li&gt;application/vnd.sas.format+json &lt;li&gt;application/vnd.sas.format.summary+json &lt;li&gt;blank &lt;/ul&gt; If the application/vnd.sas.format.summary+json type is specified or no Accept-Item header is specified, then the formats are returned as summary representation format objects.
   * @type {'application/vnd.sas.format.summary+json' | 'application/vnd.sas.format+json'}
   * @memberof InformatsApiGetInformats
   */
  readonly acceptItem?:
    | "application/vnd.sas.format.summary+json"
    | "application/vnd.sas.format+json";

  /**
   * Specifies filter criteria for returned informats.
   * @type {string}
   * @memberof InformatsApiGetInformats
   */
  readonly filter?: string;

  /**
   * Specifies the offset of the first informat to return.
   * @type {number}
   * @memberof InformatsApiGetInformats
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of informats to return.
   * @type {number}
   * @memberof InformatsApiGetInformats
   */
  readonly limit?: number;
}

/**
 * Request parameters for headersForInformat operation in InformatsApi.
 * @export
 * @interface InformatsApiHeadersForInformatRequest
 */
export interface InformatsApiHeadersForInformatRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof InformatsApiHeadersForInformat
   */
  readonly sessionId: string;

  /**
   * Specifies the informat name.
   * @type {string}
   * @memberof InformatsApiHeadersForInformat
   */
  readonly informatName: string;
}

/**
 * Request parameters for headersForInformats operation in InformatsApi.
 * @export
 * @interface InformatsApiHeadersForInformatsRequest
 */
export interface InformatsApiHeadersForInformatsRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof InformatsApiHeadersForInformats
   */
  readonly sessionId: string;

  /**
   * Specifies the filter criteria for returned informats.
   * @type {string}
   * @memberof InformatsApiHeadersForInformats
   */
  readonly filter?: string;

  /**
   * Specifies the offset of the first informat to return. The default value is 0.
   * @type {number}
   * @memberof InformatsApiHeadersForInformats
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of informats to return.
   * @type {number}
   * @memberof InformatsApiHeadersForInformats
   */
  readonly limit?: number;
}

/**
 * JobsApi - axios parameter creator
 * @export
 */
export const JobsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Executes SAS code in the specified session. Code is always submitted asynchronously. URLs are returned that contain endpoints. The Location header contains the URI of the job resource. You might submit the code directly in a request or as a reference to a File service resource.
     * @summary Execute SAS code in a session
     * @param {string} sessionId Specifies the ID of the session.
     * @param {JobRequest} jobRequest Specifies the job submission request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createJob: async (
      sessionId: string,
      jobRequest: JobRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("createJob", "sessionId", sessionId);
      // verify required parameter 'jobRequest' is not null or undefined
      assertParamExists("createJob", "jobRequest", jobRequest);
      const localVarPath = `/sessions/{sessionId}/jobs`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] =
        "application/vnd.sas.compute.job.request+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        jobRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes a job and all job access points into a session from this job. The log, listing, and results that were created by the job are also deleted. Actual job resources are still available via the session, until the session is destroyed.
     * @summary Delete a job
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} jobId Specifies the ID of the job.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteJob: async (
      sessionId: string,
      jobId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("deleteJob", "sessionId", sessionId);
      // verify required parameter 'jobId' is not null or undefined
      assertParamExists("deleteJob", "jobId", jobId);
      const localVarPath = `/sessions/{sessionId}/jobs/{jobId}`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns information about a specified job. This information includes the job\'s current state and links to other endpoints that are associated with the job, such as results, log, or output.
     * @summary Get information about a job
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} jobId Specifies the ID of the job to return information for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJob: async (
      sessionId: string,
      jobId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getJob", "sessionId", sessionId);
      // verify required parameter 'jobId' is not null or undefined
      assertParamExists("getJob", "jobId", jobId);
      const localVarPath = `/sessions/{sessionId}/jobs/{jobId}`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns the current state of the specified job.
     * @summary Get current state of a job
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} jobId Specifies the ID of the job to return information for.
     * @param {number} [wait] Specifies the request time-out, in seconds. This parameter is ignored unless it is specified in combination with the &#x60;If-None-Match&#x60; header. If the state of the resource remains unchanged until the specified number of seconds has elapsed, then a status of 304 is returned. The request determines whether the current state matches the state when the ETag was specified via the &#x60;If-None-Match&#x60; header. If the state differs within the specified time period, then the new state is returned.
     * @param {string} [ifNoneMatch] Specifies the ETag that is associated with a value of the job state.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJobState: async (
      sessionId: string,
      jobId: string,
      wait?: number,
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getJobState", "sessionId", sessionId);
      // verify required parameter 'jobId' is not null or undefined
      assertParamExists("getJobState", "jobId", jobId);
      const localVarPath = `/sessions/{sessionId}/jobs/{jobId}/state`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (wait !== undefined) {
        localVarQueryParameter["wait"] = wait;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a collection of all the current jobs for a session. Standard paging, filtering, and sorting options are provided.
     * @summary Get the current jobs for a session
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} [jobId] Returns jobs that match the specified jobId.
     * @param {number} [start] Specifies the offset of the first job to return. The default value is \&quot;0\&quot;.
     * @param {number} [limit] Specifies the maximum number of jobs to return. The default value is \&quot;10\&quot;.
     * @param {string} [filter] Specifies the filter criteria for returned jobs.
     * @param {string} [sortBy] Sorts returned jobs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJobs: async (
      sessionId: string,
      jobId?: string,
      start?: number,
      limit?: number,
      filter?: string,
      sortBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getJobs", "sessionId", sessionId);
      const localVarPath = `/sessions/{sessionId}/jobs`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (jobId !== undefined) {
        localVarQueryParameter["jobId"] = jobId;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (filter !== undefined) {
        localVarQueryParameter["filter"] = filter;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter["sortBy"] = sortBy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether the specified job exists.
     * @summary Verify that a job exists
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} jobId Specifies the ID of the job to query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForJob: async (
      sessionId: string,
      jobId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForJob", "sessionId", sessionId);
      // verify required parameter 'jobId' is not null or undefined
      assertParamExists("headersForJob", "jobId", jobId);
      const localVarPath = `/sessions/{sessionId}/jobs/{jobId}`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether the state can be determined for a job.
     * @summary Check endpoint availability
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} jobId Specifies the ID of the job to return information for.
     * @param {number} [wait] Specifies the request time-out, in seconds. This parameter is ignored unless it is specified in combination with the &#x60;If-None-Match&#x60; header. If the state of the resource remains unchanged until the specified number of seconds has elapsed, then a status of 304 is returned. The request determines whether the current state matches the state when the ETag was specified via the &#x60;If-None-Match&#x60; header. If the state differs within the specified time period, then the new state is returned.
     * @param {string} [ifNoneMatch] Specifies the ETag that is associated with a value of the job state.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForJobState: async (
      sessionId: string,
      jobId: string,
      wait?: number,
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForJobState", "sessionId", sessionId);
      // verify required parameter 'jobId' is not null or undefined
      assertParamExists("headersForJobState", "jobId", jobId);
      const localVarPath = `/sessions/{sessionId}/jobs/{jobId}/state`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (wait !== undefined) {
        localVarQueryParameter["wait"] = wait;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether the jobs endpoint is available for a session.
     * @summary Check endpoint availability
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} [jobId] Returns only jobs that match this jobId.
     * @param {number} [start] Specifies the offset of the first job to return. The default value is \&quot;0\&quot;.
     * @param {number} [limit] Specifies the maximum number of jobs to return. The default value is \&quot;10\&quot;.
     * @param {string} [filter] Specifies the filter criteria for returned jobs.
     * @param {string} [sortBy] Sorts returned jobs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForJobs: async (
      sessionId: string,
      jobId?: string,
      start?: number,
      limit?: number,
      filter?: string,
      sortBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForJobs", "sessionId", sessionId);
      const localVarPath = `/sessions/{sessionId}/jobs`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (jobId !== undefined) {
        localVarQueryParameter["jobId"] = jobId;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (filter !== undefined) {
        localVarQueryParameter["filter"] = filter;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter["sortBy"] = sortBy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Sets the current state of the specified job. For example, you can use this method to set the state to canceled.
     * @summary Set current state of a job
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} jobId Specifies the ID of the job whose state you want to update.
     * @param {'canceled' | 'deleted'} value Specifies the new job state, such as canceled.
     * @param {string} ifMatch Specifies the current ETag of the job being updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateJobState: async (
      sessionId: string,
      jobId: string,
      value: "canceled" | "deleted",
      ifMatch: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("updateJobState", "sessionId", sessionId);
      // verify required parameter 'jobId' is not null or undefined
      assertParamExists("updateJobState", "jobId", jobId);
      // verify required parameter 'value' is not null or undefined
      assertParamExists("updateJobState", "value", value);
      // verify required parameter 'ifMatch' is not null or undefined
      assertParamExists("updateJobState", "ifMatch", ifMatch);
      const localVarPath = `/sessions/{sessionId}/jobs/{jobId}/state`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (value !== undefined) {
        localVarQueryParameter["value"] = value;
      }

      if (ifMatch != null) {
        localVarHeaderParameter["If-Match"] = String(ifMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * JobsApi - functional programming interface
 * @export
 */
export const JobsApi = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = JobsApiAxiosParamCreator(configuration);
  return {
    /**
     * Executes SAS code in the specified session. Code is always submitted asynchronously. URLs are returned that contain endpoints. The Location header contains the URI of the job resource. You might submit the code directly in a request or as a reference to a File service resource.
     * @summary Execute SAS code in a session
     * @param {JobsApiCreateJobRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createJob(
      requestParameters: JobsApiCreateJobRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<Job>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createJob(
        requestParameters.sessionId,
        requestParameters.jobRequest,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Deletes a job and all job access points into a session from this job. The log, listing, and results that were created by the job are also deleted. Actual job resources are still available via the session, until the session is destroyed.
     * @summary Delete a job
     * @param {JobsApiDeleteJobRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteJob(
      requestParameters: JobsApiDeleteJobRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteJob(
        requestParameters.sessionId,
        requestParameters.jobId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns information about a specified job. This information includes the job\'s current state and links to other endpoints that are associated with the job, such as results, log, or output.
     * @summary Get information about a job
     * @param {JobsApiGetJobRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getJob(
      requestParameters: JobsApiGetJobRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<Job>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getJob(
        requestParameters.sessionId,
        requestParameters.jobId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns the current state of the specified job.
     * @summary Get current state of a job
     * @param {JobsApiGetJobStateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getJobState(
      requestParameters: JobsApiGetJobStateRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getJobState(
        requestParameters.sessionId,
        requestParameters.jobId,
        requestParameters.wait,
        requestParameters.ifNoneMatch,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns a collection of all the current jobs for a session. Standard paging, filtering, and sorting options are provided.
     * @summary Get the current jobs for a session
     * @param {JobsApiGetJobsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getJobs(
      requestParameters: JobsApiGetJobsRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<JobCollection>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getJobs(
        requestParameters.sessionId,
        requestParameters.jobId,
        requestParameters.start,
        requestParameters.limit,
        requestParameters.filter,
        requestParameters.sortBy,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether the specified job exists.
     * @summary Verify that a job exists
     * @param {JobsApiHeadersForJobRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForJob(
      requestParameters: JobsApiHeadersForJobRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.headersForJob(
        requestParameters.sessionId,
        requestParameters.jobId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether the state can be determined for a job.
     * @summary Check endpoint availability
     * @param {JobsApiHeadersForJobStateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForJobState(
      requestParameters: JobsApiHeadersForJobStateRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForJobState(
          requestParameters.sessionId,
          requestParameters.jobId,
          requestParameters.wait,
          requestParameters.ifNoneMatch,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether the jobs endpoint is available for a session.
     * @summary Check endpoint availability
     * @param {JobsApiHeadersForJobsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForJobs(
      requestParameters: JobsApiHeadersForJobsRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.headersForJobs(
        requestParameters.sessionId,
        requestParameters.jobId,
        requestParameters.start,
        requestParameters.limit,
        requestParameters.filter,
        requestParameters.sortBy,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Sets the current state of the specified job. For example, you can use this method to set the state to canceled.
     * @summary Set current state of a job
     * @param {JobsApiUpdateJobStateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateJobState(
      requestParameters: JobsApiUpdateJobStateRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateJobState(
        requestParameters.sessionId,
        requestParameters.jobId,
        requestParameters.value,
        requestParameters.ifMatch,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },
  };
};

/**
 * Request parameters for createJob operation in JobsApi.
 * @export
 * @interface JobsApiCreateJobRequest
 */
export interface JobsApiCreateJobRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof JobsApiCreateJob
   */
  readonly sessionId: string;

  /**
   * Specifies the job submission request.
   * @type {JobRequest}
   * @memberof JobsApiCreateJob
   */
  readonly jobRequest: JobRequest;
}

/**
 * Request parameters for deleteJob operation in JobsApi.
 * @export
 * @interface JobsApiDeleteJobRequest
 */
export interface JobsApiDeleteJobRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof JobsApiDeleteJob
   */
  readonly sessionId: string;

  /**
   * Specifies the ID of the job.
   * @type {string}
   * @memberof JobsApiDeleteJob
   */
  readonly jobId: string;
}

/**
 * Request parameters for getJob operation in JobsApi.
 * @export
 * @interface JobsApiGetJobRequest
 */
export interface JobsApiGetJobRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof JobsApiGetJob
   */
  readonly sessionId: string;

  /**
   * Specifies the ID of the job to return information for.
   * @type {string}
   * @memberof JobsApiGetJob
   */
  readonly jobId: string;
}

/**
 * Request parameters for getJobState operation in JobsApi.
 * @export
 * @interface JobsApiGetJobStateRequest
 */
export interface JobsApiGetJobStateRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof JobsApiGetJobState
   */
  readonly sessionId: string;

  /**
   * Specifies the ID of the job to return information for.
   * @type {string}
   * @memberof JobsApiGetJobState
   */
  readonly jobId: string;

  /**
   * Specifies the request time-out, in seconds. This parameter is ignored unless it is specified in combination with the &#x60;If-None-Match&#x60; header. If the state of the resource remains unchanged until the specified number of seconds has elapsed, then a status of 304 is returned. The request determines whether the current state matches the state when the ETag was specified via the &#x60;If-None-Match&#x60; header. If the state differs within the specified time period, then the new state is returned.
   * @type {number}
   * @memberof JobsApiGetJobState
   */
  readonly wait?: number;

  /**
   * Specifies the ETag that is associated with a value of the job state.
   * @type {string}
   * @memberof JobsApiGetJobState
   */
  readonly ifNoneMatch?: string;
}

/**
 * Request parameters for getJobs operation in JobsApi.
 * @export
 * @interface JobsApiGetJobsRequest
 */
export interface JobsApiGetJobsRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof JobsApiGetJobs
   */
  readonly sessionId: string;

  /**
   * Returns jobs that match the specified jobId.
   * @type {string}
   * @memberof JobsApiGetJobs
   */
  readonly jobId?: string;

  /**
   * Specifies the offset of the first job to return. The default value is \&quot;0\&quot;.
   * @type {number}
   * @memberof JobsApiGetJobs
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of jobs to return. The default value is \&quot;10\&quot;.
   * @type {number}
   * @memberof JobsApiGetJobs
   */
  readonly limit?: number;

  /**
   * Specifies the filter criteria for returned jobs.
   * @type {string}
   * @memberof JobsApiGetJobs
   */
  readonly filter?: string;

  /**
   * Sorts returned jobs.
   * @type {string}
   * @memberof JobsApiGetJobs
   */
  readonly sortBy?: string;
}

/**
 * Request parameters for headersForJob operation in JobsApi.
 * @export
 * @interface JobsApiHeadersForJobRequest
 */
export interface JobsApiHeadersForJobRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof JobsApiHeadersForJob
   */
  readonly sessionId: string;

  /**
   * Specifies the ID of the job to query.
   * @type {string}
   * @memberof JobsApiHeadersForJob
   */
  readonly jobId: string;
}

/**
 * Request parameters for headersForJobState operation in JobsApi.
 * @export
 * @interface JobsApiHeadersForJobStateRequest
 */
export interface JobsApiHeadersForJobStateRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof JobsApiHeadersForJobState
   */
  readonly sessionId: string;

  /**
   * Specifies the ID of the job to return information for.
   * @type {string}
   * @memberof JobsApiHeadersForJobState
   */
  readonly jobId: string;

  /**
   * Specifies the request time-out, in seconds. This parameter is ignored unless it is specified in combination with the &#x60;If-None-Match&#x60; header. If the state of the resource remains unchanged until the specified number of seconds has elapsed, then a status of 304 is returned. The request determines whether the current state matches the state when the ETag was specified via the &#x60;If-None-Match&#x60; header. If the state differs within the specified time period, then the new state is returned.
   * @type {number}
   * @memberof JobsApiHeadersForJobState
   */
  readonly wait?: number;

  /**
   * Specifies the ETag that is associated with a value of the job state.
   * @type {string}
   * @memberof JobsApiHeadersForJobState
   */
  readonly ifNoneMatch?: string;
}

/**
 * Request parameters for headersForJobs operation in JobsApi.
 * @export
 * @interface JobsApiHeadersForJobsRequest
 */
export interface JobsApiHeadersForJobsRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof JobsApiHeadersForJobs
   */
  readonly sessionId: string;

  /**
   * Returns only jobs that match this jobId.
   * @type {string}
   * @memberof JobsApiHeadersForJobs
   */
  readonly jobId?: string;

  /**
   * Specifies the offset of the first job to return. The default value is \&quot;0\&quot;.
   * @type {number}
   * @memberof JobsApiHeadersForJobs
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of jobs to return. The default value is \&quot;10\&quot;.
   * @type {number}
   * @memberof JobsApiHeadersForJobs
   */
  readonly limit?: number;

  /**
   * Specifies the filter criteria for returned jobs.
   * @type {string}
   * @memberof JobsApiHeadersForJobs
   */
  readonly filter?: string;

  /**
   * Sorts returned jobs.
   * @type {string}
   * @memberof JobsApiHeadersForJobs
   */
  readonly sortBy?: string;
}

/**
 * Request parameters for updateJobState operation in JobsApi.
 * @export
 * @interface JobsApiUpdateJobStateRequest
 */
export interface JobsApiUpdateJobStateRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof JobsApiUpdateJobState
   */
  readonly sessionId: string;

  /**
   * Specifies the ID of the job whose state you want to update.
   * @type {string}
   * @memberof JobsApiUpdateJobState
   */
  readonly jobId: string;

  /**
   * Specifies the new job state, such as canceled.
   * @type {'canceled' | 'deleted'}
   * @memberof JobsApiUpdateJobState
   */
  readonly value: "canceled" | "deleted";

  /**
   * Specifies the current ETag of the job being updated.
   * @type {string}
   * @memberof JobsApiUpdateJobState
   */
  readonly ifMatch: string;
}

/**
 * ListingsApi - axios parameter creator
 * @export
 */
export const ListingsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieves the listing output associated with a job. A job listing is a subset of the session listing. Therefore, the first line of a job listing begins at a location (offset) within the session listing. This operation returns a collection in which each entry is of the type application/vnd.sas.compute.log.line.
     * @summary Retrieve listing information for a job
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} jobId Specifies the ID of the job.
     * @param {number} [start] Specifies the offset of the first item in the collection. The first line is at start&#x3D;0.
     * @param {number} [limit] Specifies the number of items in this page.
     * @param {string} [type] Restricts listing information to those entries whose type matches the query. Specify multiple types by separating them with a \&#39;|\&#39;. For example, you might specify ?type&#x3D;normal or ?type&#x3D;normal|hilighted.
     * @param {number} [timeout] Specifies the request time-out in seconds.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJobListing: async (
      sessionId: string,
      jobId: string,
      start?: number,
      limit?: number,
      type?: string,
      timeout?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getJobListing", "sessionId", sessionId);
      // verify required parameter 'jobId' is not null or undefined
      assertParamExists("getJobListing", "jobId", jobId);
      const localVarPath = `/sessions/{sessionId}/jobs/{jobId}/listing`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (type !== undefined) {
        localVarQueryParameter["type"] = type;
      }

      if (timeout !== undefined) {
        localVarQueryParameter["timeout"] = timeout;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the listing output associated with a job as text.
     * @summary Retrieve listing information for a job as text.
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} jobId Specifies the ID of the job.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJobListingAsText: async (
      sessionId: string,
      jobId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getJobListingAsText", "sessionId", sessionId);
      // verify required parameter 'jobId' is not null or undefined
      assertParamExists("getJobListingAsText", "jobId", jobId);
      const localVarPath = `/sessions/{sessionId}/jobs/{jobId}/listing#asText`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the listing output associated with a session. This operation returns a collection in which each entry is of the type application/vnd.sas.compute.log.line.
     * @summary Retrieve listing information for a session
     * @param {string} sessionId Specifies the ID of the session.
     * @param {number} [start] Specifies the offset of the first item in the collection. The first line is at start&#x3D;0.
     * @param {number} [limit] Specifies the number of items in this page.
     * @param {string} [type] Restricts listing information to those entries whose type matches the query. Specify multiple types by separating them with a \&#39;|\&#39;. For example, you might specify ?type&#x3D;normal or ?type&#x3D;normal|hilighted.
     * @param {number} [timeout] Specifies the request time-out in seconds.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSessionListing: async (
      sessionId: string,
      start?: number,
      limit?: number,
      type?: string,
      timeout?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getSessionListing", "sessionId", sessionId);
      const localVarPath = `/sessions/{sessionId}/listing`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (type !== undefined) {
        localVarQueryParameter["type"] = type;
      }

      if (timeout !== undefined) {
        localVarQueryParameter["timeout"] = timeout;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the listing output associated with a session as text.
     * @summary Retrieve listing information for a session as text.
     * @param {string} sessionId Specifies the ID of the session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSessionListingAsText: async (
      sessionId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getSessionListingAsText", "sessionId", sessionId);
      const localVarPath = `/sessions/{sessionId}/listing#asText`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether a job listing exists.
     * @summary Check for a job listing
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} jobId Specifies the ID of the job.
     * @param {number} [start] Specifies the offset of the first item in the collection.  The first line is at start&#x3D;0.
     * @param {number} [limit] Specifies the number of items in this page.
     * @param {string} [type] Restricts listing information to those entries whose type matches the query. Specify multiple types by separating them with a \&#39;|\&#39;. For example, you might specify ?type&#x3D;error or ?type&#x3D;error|warning.
     * @param {number} [timeout] Specifies the request time-out in seconds.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForJobListing: async (
      sessionId: string,
      jobId: string,
      start?: number,
      limit?: number,
      type?: string,
      timeout?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForJobListing", "sessionId", sessionId);
      // verify required parameter 'jobId' is not null or undefined
      assertParamExists("headersForJobListing", "jobId", jobId);
      const localVarPath = `/sessions/{sessionId}/jobs/{jobId}/listing`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (type !== undefined) {
        localVarQueryParameter["type"] = type;
      }

      if (timeout !== undefined) {
        localVarQueryParameter["timeout"] = timeout;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether a job listing exists as text.
     * @summary Check for job listing as text
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} jobId Specifies the ID of the job.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForJobListingAsText: async (
      sessionId: string,
      jobId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForJobListingAsText", "sessionId", sessionId);
      // verify required parameter 'jobId' is not null or undefined
      assertParamExists("headersForJobListingAsText", "jobId", jobId);
      const localVarPath = `/sessions/{sessionId}/jobs/{jobId}/listing#asText`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether a session listing is available.
     * @summary Check for a session listing
     * @param {string} sessionId Specifies the ID of the session.
     * @param {number} [start] Specifies the offset of the first item in the collection. The first line is at start&#x3D;0.
     * @param {number} [limit] Specifies the number of items in this page.
     * @param {string} [type] Restricts listing information to those entries whose type matches the query. Specify multiple types by separating them with a \&#39;|\&#39;. For example, you might specify ?type&#x3D;error or ?type&#x3D;error|warning.
     * @param {number} [timeout] Specifies the request time-out in seconds.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForSessionListing: async (
      sessionId: string,
      start?: number,
      limit?: number,
      type?: string,
      timeout?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForSessionListing", "sessionId", sessionId);
      const localVarPath = `/sessions/{sessionId}/listing`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (type !== undefined) {
        localVarQueryParameter["type"] = type;
      }

      if (timeout !== undefined) {
        localVarQueryParameter["timeout"] = timeout;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether a session listing is available as text.
     * @summary Check for session listing as text.
     * @param {string} sessionId Specifies the ID of the session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForSessionListingAsText: async (
      sessionId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists(
        "headersForSessionListingAsText",
        "sessionId",
        sessionId
      );
      const localVarPath = `/sessions/{sessionId}/listing#asText`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Uploads job listing output to the Files service and returns the representation of the file resource containing the output. The file is created in one of two formats, based on the value of the property \"format\" specified in the post body. If \"collection\" is specified as the value of \"format\", the output file is rendered as application/vnd.sas.collection+json. If the format is specified as \"prefixedText\", the output is text/plain in which each line of output is prefixed with the name of the line type followed by a colon. In either case, all available output is returned; neither pagination nor filtering is supported.
     * @summary Upload job listing output to the Files service
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} jobId Specifies the ID of the job.
     * @param {OutputStreamFileRequest} outputStreamFileRequest Specifies the request to stream output to the Files service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    streamJobListingAsFile: async (
      sessionId: string,
      jobId: string,
      outputStreamFileRequest: OutputStreamFileRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("streamJobListingAsFile", "sessionId", sessionId);
      // verify required parameter 'jobId' is not null or undefined
      assertParamExists("streamJobListingAsFile", "jobId", jobId);
      // verify required parameter 'outputStreamFileRequest' is not null or undefined
      assertParamExists(
        "streamJobListingAsFile",
        "outputStreamFileRequest",
        outputStreamFileRequest
      );
      const localVarPath = `/sessions/{sessionId}/jobs/{jobId}/listing`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] =
        "application/vnd.sas.compute.output.stream.file.request+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        outputStreamFileRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Uploads session listing output to the Files service and returns the representation of the file resource containing the output. The file is created in one of two formats, based on the value of the property \"format\" specified in the post body. If \"collection\" is specified as the value of \"format\", the output file is rendered as application/vnd.sas.collection+json. If the format is specified as \"prefixedText\", the output is text/plain in which each line of output is prefixed with the name of the line type followed by a colon. In either case, all available output is returned; neither pagination nor filtering is supported.
     * @summary Upload session listing output to the Files service
     * @param {string} sessionId Specifies the ID of the session.
     * @param {OutputStreamFileRequest} outputStreamFileRequest Specifies the request to stream output to the Files service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    streamSessionListingAsFile: async (
      sessionId: string,
      outputStreamFileRequest: OutputStreamFileRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("streamSessionListingAsFile", "sessionId", sessionId);
      // verify required parameter 'outputStreamFileRequest' is not null or undefined
      assertParamExists(
        "streamSessionListingAsFile",
        "outputStreamFileRequest",
        outputStreamFileRequest
      );
      const localVarPath = `/sessions/{sessionId}/listing`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] =
        "application/vnd.sas.compute.output.stream.file.request+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        outputStreamFileRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ListingsApi - functional programming interface
 * @export
 */
export const ListingsApi = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ListingsApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieves the listing output associated with a job. A job listing is a subset of the session listing. Therefore, the first line of a job listing begins at a location (offset) within the session listing. This operation returns a collection in which each entry is of the type application/vnd.sas.compute.log.line.
     * @summary Retrieve listing information for a job
     * @param {ListingsApiGetJobListingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getJobListing(
      requestParameters: ListingsApiGetJobListingRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<JobListingCollection>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getJobListing(
        requestParameters.sessionId,
        requestParameters.jobId,
        requestParameters.start,
        requestParameters.limit,
        requestParameters.type,
        requestParameters.timeout,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Retrieves the listing output associated with a job as text.
     * @summary Retrieve listing information for a job as text.
     * @param {ListingsApiGetJobListingAsTextRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getJobListingAsText(
      requestParameters: ListingsApiGetJobListingAsTextRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getJobListingAsText(
          requestParameters.sessionId,
          requestParameters.jobId,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Retrieves the listing output associated with a session. This operation returns a collection in which each entry is of the type application/vnd.sas.compute.log.line.
     * @summary Retrieve listing information for a session
     * @param {ListingsApiGetSessionListingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSessionListing(
      requestParameters: ListingsApiGetSessionListingRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<SessionListingCollection>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSessionListing(
          requestParameters.sessionId,
          requestParameters.start,
          requestParameters.limit,
          requestParameters.type,
          requestParameters.timeout,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Retrieves the listing output associated with a session as text.
     * @summary Retrieve listing information for a session as text.
     * @param {ListingsApiGetSessionListingAsTextRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSessionListingAsText(
      requestParameters: ListingsApiGetSessionListingAsTextRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSessionListingAsText(
          requestParameters.sessionId,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether a job listing exists.
     * @summary Check for a job listing
     * @param {ListingsApiHeadersForJobListingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForJobListing(
      requestParameters: ListingsApiHeadersForJobListingRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForJobListing(
          requestParameters.sessionId,
          requestParameters.jobId,
          requestParameters.start,
          requestParameters.limit,
          requestParameters.type,
          requestParameters.timeout,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether a job listing exists as text.
     * @summary Check for job listing as text
     * @param {ListingsApiHeadersForJobListingAsTextRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForJobListingAsText(
      requestParameters: ListingsApiHeadersForJobListingAsTextRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForJobListingAsText(
          requestParameters.sessionId,
          requestParameters.jobId,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether a session listing is available.
     * @summary Check for a session listing
     * @param {ListingsApiHeadersForSessionListingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForSessionListing(
      requestParameters: ListingsApiHeadersForSessionListingRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForSessionListing(
          requestParameters.sessionId,
          requestParameters.start,
          requestParameters.limit,
          requestParameters.type,
          requestParameters.timeout,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether a session listing is available as text.
     * @summary Check for session listing as text.
     * @param {ListingsApiHeadersForSessionListingAsTextRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForSessionListingAsText(
      requestParameters: ListingsApiHeadersForSessionListingAsTextRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForSessionListingAsText(
          requestParameters.sessionId,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Uploads job listing output to the Files service and returns the representation of the file resource containing the output. The file is created in one of two formats, based on the value of the property \"format\" specified in the post body. If \"collection\" is specified as the value of \"format\", the output file is rendered as application/vnd.sas.collection+json. If the format is specified as \"prefixedText\", the output is text/plain in which each line of output is prefixed with the name of the line type followed by a colon. In either case, all available output is returned; neither pagination nor filtering is supported.
     * @summary Upload job listing output to the Files service
     * @param {ListingsApiStreamJobListingAsFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async streamJobListingAsFile(
      requestParameters: ListingsApiStreamJobListingAsFileRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<FileResource>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.streamJobListingAsFile(
          requestParameters.sessionId,
          requestParameters.jobId,
          requestParameters.outputStreamFileRequest,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Uploads session listing output to the Files service and returns the representation of the file resource containing the output. The file is created in one of two formats, based on the value of the property \"format\" specified in the post body. If \"collection\" is specified as the value of \"format\", the output file is rendered as application/vnd.sas.collection+json. If the format is specified as \"prefixedText\", the output is text/plain in which each line of output is prefixed with the name of the line type followed by a colon. In either case, all available output is returned; neither pagination nor filtering is supported.
     * @summary Upload session listing output to the Files service
     * @param {ListingsApiStreamSessionListingAsFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async streamSessionListingAsFile(
      requestParameters: ListingsApiStreamSessionListingAsFileRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<FileResource>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.streamSessionListingAsFile(
          requestParameters.sessionId,
          requestParameters.outputStreamFileRequest,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },
  };
};

/**
 * Request parameters for getJobListing operation in ListingsApi.
 * @export
 * @interface ListingsApiGetJobListingRequest
 */
export interface ListingsApiGetJobListingRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof ListingsApiGetJobListing
   */
  readonly sessionId: string;

  /**
   * Specifies the ID of the job.
   * @type {string}
   * @memberof ListingsApiGetJobListing
   */
  readonly jobId: string;

  /**
   * Specifies the offset of the first item in the collection. The first line is at start&#x3D;0.
   * @type {number}
   * @memberof ListingsApiGetJobListing
   */
  readonly start?: number;

  /**
   * Specifies the number of items in this page.
   * @type {number}
   * @memberof ListingsApiGetJobListing
   */
  readonly limit?: number;

  /**
   * Restricts listing information to those entries whose type matches the query. Specify multiple types by separating them with a \&#39;|\&#39;. For example, you might specify ?type&#x3D;normal or ?type&#x3D;normal|hilighted.
   * @type {string}
   * @memberof ListingsApiGetJobListing
   */
  readonly type?: string;

  /**
   * Specifies the request time-out in seconds.
   * @type {number}
   * @memberof ListingsApiGetJobListing
   */
  readonly timeout?: number;
}

/**
 * Request parameters for getJobListingAsText operation in ListingsApi.
 * @export
 * @interface ListingsApiGetJobListingAsTextRequest
 */
export interface ListingsApiGetJobListingAsTextRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof ListingsApiGetJobListingAsText
   */
  readonly sessionId: string;

  /**
   * Specifies the ID of the job.
   * @type {string}
   * @memberof ListingsApiGetJobListingAsText
   */
  readonly jobId: string;
}

/**
 * Request parameters for getSessionListing operation in ListingsApi.
 * @export
 * @interface ListingsApiGetSessionListingRequest
 */
export interface ListingsApiGetSessionListingRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof ListingsApiGetSessionListing
   */
  readonly sessionId: string;

  /**
   * Specifies the offset of the first item in the collection. The first line is at start&#x3D;0.
   * @type {number}
   * @memberof ListingsApiGetSessionListing
   */
  readonly start?: number;

  /**
   * Specifies the number of items in this page.
   * @type {number}
   * @memberof ListingsApiGetSessionListing
   */
  readonly limit?: number;

  /**
   * Restricts listing information to those entries whose type matches the query. Specify multiple types by separating them with a \&#39;|\&#39;. For example, you might specify ?type&#x3D;normal or ?type&#x3D;normal|hilighted.
   * @type {string}
   * @memberof ListingsApiGetSessionListing
   */
  readonly type?: string;

  /**
   * Specifies the request time-out in seconds.
   * @type {number}
   * @memberof ListingsApiGetSessionListing
   */
  readonly timeout?: number;
}

/**
 * Request parameters for getSessionListingAsText operation in ListingsApi.
 * @export
 * @interface ListingsApiGetSessionListingAsTextRequest
 */
export interface ListingsApiGetSessionListingAsTextRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof ListingsApiGetSessionListingAsText
   */
  readonly sessionId: string;
}

/**
 * Request parameters for headersForJobListing operation in ListingsApi.
 * @export
 * @interface ListingsApiHeadersForJobListingRequest
 */
export interface ListingsApiHeadersForJobListingRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof ListingsApiHeadersForJobListing
   */
  readonly sessionId: string;

  /**
   * Specifies the ID of the job.
   * @type {string}
   * @memberof ListingsApiHeadersForJobListing
   */
  readonly jobId: string;

  /**
   * Specifies the offset of the first item in the collection.  The first line is at start&#x3D;0.
   * @type {number}
   * @memberof ListingsApiHeadersForJobListing
   */
  readonly start?: number;

  /**
   * Specifies the number of items in this page.
   * @type {number}
   * @memberof ListingsApiHeadersForJobListing
   */
  readonly limit?: number;

  /**
   * Restricts listing information to those entries whose type matches the query. Specify multiple types by separating them with a \&#39;|\&#39;. For example, you might specify ?type&#x3D;error or ?type&#x3D;error|warning.
   * @type {string}
   * @memberof ListingsApiHeadersForJobListing
   */
  readonly type?: string;

  /**
   * Specifies the request time-out in seconds.
   * @type {number}
   * @memberof ListingsApiHeadersForJobListing
   */
  readonly timeout?: number;
}

/**
 * Request parameters for headersForJobListingAsText operation in ListingsApi.
 * @export
 * @interface ListingsApiHeadersForJobListingAsTextRequest
 */
export interface ListingsApiHeadersForJobListingAsTextRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof ListingsApiHeadersForJobListingAsText
   */
  readonly sessionId: string;

  /**
   * Specifies the ID of the job.
   * @type {string}
   * @memberof ListingsApiHeadersForJobListingAsText
   */
  readonly jobId: string;
}

/**
 * Request parameters for headersForSessionListing operation in ListingsApi.
 * @export
 * @interface ListingsApiHeadersForSessionListingRequest
 */
export interface ListingsApiHeadersForSessionListingRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof ListingsApiHeadersForSessionListing
   */
  readonly sessionId: string;

  /**
   * Specifies the offset of the first item in the collection. The first line is at start&#x3D;0.
   * @type {number}
   * @memberof ListingsApiHeadersForSessionListing
   */
  readonly start?: number;

  /**
   * Specifies the number of items in this page.
   * @type {number}
   * @memberof ListingsApiHeadersForSessionListing
   */
  readonly limit?: number;

  /**
   * Restricts listing information to those entries whose type matches the query. Specify multiple types by separating them with a \&#39;|\&#39;. For example, you might specify ?type&#x3D;error or ?type&#x3D;error|warning.
   * @type {string}
   * @memberof ListingsApiHeadersForSessionListing
   */
  readonly type?: string;

  /**
   * Specifies the request time-out in seconds.
   * @type {number}
   * @memberof ListingsApiHeadersForSessionListing
   */
  readonly timeout?: number;
}

/**
 * Request parameters for headersForSessionListingAsText operation in ListingsApi.
 * @export
 * @interface ListingsApiHeadersForSessionListingAsTextRequest
 */
export interface ListingsApiHeadersForSessionListingAsTextRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof ListingsApiHeadersForSessionListingAsText
   */
  readonly sessionId: string;
}

/**
 * Request parameters for streamJobListingAsFile operation in ListingsApi.
 * @export
 * @interface ListingsApiStreamJobListingAsFileRequest
 */
export interface ListingsApiStreamJobListingAsFileRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof ListingsApiStreamJobListingAsFile
   */
  readonly sessionId: string;

  /**
   * Specifies the ID of the job.
   * @type {string}
   * @memberof ListingsApiStreamJobListingAsFile
   */
  readonly jobId: string;

  /**
   * Specifies the request to stream output to the Files service.
   * @type {OutputStreamFileRequest}
   * @memberof ListingsApiStreamJobListingAsFile
   */
  readonly outputStreamFileRequest: OutputStreamFileRequest;
}

/**
 * Request parameters for streamSessionListingAsFile operation in ListingsApi.
 * @export
 * @interface ListingsApiStreamSessionListingAsFileRequest
 */
export interface ListingsApiStreamSessionListingAsFileRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof ListingsApiStreamSessionListingAsFile
   */
  readonly sessionId: string;

  /**
   * Specifies the request to stream output to the Files service.
   * @type {OutputStreamFileRequest}
   * @memberof ListingsApiStreamSessionListingAsFile
   */
  readonly outputStreamFileRequest: OutputStreamFileRequest;
}

/**
 * LogsApi - axios parameter creator
 * @export
 */
export const LogsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieves the log output associated with a job. A job log is a subset of the session log. Therefore, the first line of a job log begins at a location (offset) within the session log. This operation returns a collection in which each entry is of the type application/vnd.sas.compute.log.line.
     * @summary Retrieve a job log
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} jobId Specifies the ID of the job.
     * @param {number} [start] Specifies the offset of the first item in a collection. The first line is at start&#x3D;0.
     * @param {number} [limit] Specifies the number of items in a page.
     * @param {string} [type] Restricts log collection to those entries with a specified type. Specify multiple types in a query by separating them with a \&#39;|\&#39;.  For example, you might specify ?type&#x3D;error or ?type&#x3D;error|warning.
     * @param {number} [timeout] Specifies the request time-out in seconds. If no log lines are available over this time period, an empty collection is returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJobLog: async (
      sessionId: string,
      jobId: string,
      start?: number,
      limit?: number,
      type?: string,
      timeout?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getJobLog", "sessionId", sessionId);
      // verify required parameter 'jobId' is not null or undefined
      assertParamExists("getJobLog", "jobId", jobId);
      const localVarPath = `/sessions/{sessionId}/jobs/{jobId}/log`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (type !== undefined) {
        localVarQueryParameter["type"] = type;
      }

      if (timeout !== undefined) {
        localVarQueryParameter["timeout"] = timeout;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the entire log output associated with a job as text.
     * @summary Retrieve a job log as text.
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} jobId Specifies the ID of the job.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJobLogAsText: async (
      sessionId: string,
      jobId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getJobLogAsText", "sessionId", sessionId);
      // verify required parameter 'jobId' is not null or undefined
      assertParamExists("getJobLogAsText", "jobId", jobId);
      const localVarPath = `/sessions/{sessionId}/jobs/{jobId}/log#asText`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the log output associated with a session. This operation returns a collection in which each entry is of the type application/vnd.sas.compute.log.line.
     * @summary Retrieve a session log
     * @param {string} sessionId Specifies the ID of the session.
     * @param {number} [start] Specifies the offset of the first item in the collection. The first line is at start&#x3D;0.
     * @param {number} [limit] Specifies the number of items in this page.
     * @param {string} [type] Restricts the log collection to those entries whose type matches the query. Specify multiple types by separating them with a \&#39;|\&#39;. For example, you might specify ?type&#x3D;error or ?type&#x3D;error|warning.
     * @param {number} [timeout] Specifies the request time-out in seconds.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSessionLog: async (
      sessionId: string,
      start?: number,
      limit?: number,
      type?: string,
      timeout?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getSessionLog", "sessionId", sessionId);
      const localVarPath = `/sessions/{sessionId}/log`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (type !== undefined) {
        localVarQueryParameter["type"] = type;
      }

      if (timeout !== undefined) {
        localVarQueryParameter["timeout"] = timeout;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the log output associated with a session as text.
     * @summary Retrieve a session log as text.
     * @param {string} sessionId Specifies the ID of the session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSessionLogAsText: async (
      sessionId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getSessionLogAsText", "sessionId", sessionId);
      const localVarPath = `/sessions/{sessionId}/log#asText`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether there is currently a log for a job.
     * @summary Check job log availability
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} jobId Specifies the ID of the job.
     * @param {number} [start] Specifies the offset of the first item in the collection. The first line is at start&#x3D;0.
     * @param {number} [limit] Specifies the number of items in this page.
     * @param {string} [type] Restricts a log collection to those entries whose type matches the query. Specify multiple types by separating them with a \&#39;|\&#39;.  For example, you might specify ?type&#x3D;error or ?type&#x3D;error|warning.
     * @param {number} [timeout] Specifies the request time-out in seconds. If no log lines are available in this time period, an empty collection is returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForJobLog: async (
      sessionId: string,
      jobId: string,
      start?: number,
      limit?: number,
      type?: string,
      timeout?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForJobLog", "sessionId", sessionId);
      // verify required parameter 'jobId' is not null or undefined
      assertParamExists("headersForJobLog", "jobId", jobId);
      const localVarPath = `/sessions/{sessionId}/jobs/{jobId}/log`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (type !== undefined) {
        localVarQueryParameter["type"] = type;
      }

      if (timeout !== undefined) {
        localVarQueryParameter["timeout"] = timeout;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether there is currently a log for a job as text.
     * @summary Check for job log as text
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} jobId Specifies the ID of the job.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForJobLogAsText: async (
      sessionId: string,
      jobId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForJobLogAsText", "sessionId", sessionId);
      // verify required parameter 'jobId' is not null or undefined
      assertParamExists("headersForJobLogAsText", "jobId", jobId);
      const localVarPath = `/sessions/{sessionId}/jobs/{jobId}/log#asText`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether the session has a log available.
     * @summary Check for a session log
     * @param {string} sessionId Specifies the ID of the session.
     * @param {number} [start] Specifies the offset of the first item in the collection. The first line is at start&#x3D;0.
     * @param {number} [limit] Specifies the number of items in this page.
     * @param {string} [type] Restricts log collection to those entries whose type matches the query. Specify multiple types by separating them with a \&#39;|\&#39;. For example, you might specify ?type&#x3D;error or ?type&#x3D;error|warning.
     * @param {number} [timeout] Specifies the request time-out in seconds.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForSessionLog: async (
      sessionId: string,
      start?: number,
      limit?: number,
      type?: string,
      timeout?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForSessionLog", "sessionId", sessionId);
      const localVarPath = `/sessions/{sessionId}/log`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (type !== undefined) {
        localVarQueryParameter["type"] = type;
      }

      if (timeout !== undefined) {
        localVarQueryParameter["timeout"] = timeout;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether the session has a log available as text.
     * @summary Check for session log as text.
     * @param {string} sessionId Specifies the ID of the session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForSessionLogAsText: async (
      sessionId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForSessionLogAsText", "sessionId", sessionId);
      const localVarPath = `/sessions/{sessionId}/log#asText`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Uploads job log output to the Files service and returns the representation of the file resource containing the output. The file is created in one of two formats, based on the value of the property \"format\" specified in the post body. If \"collection\" is specified as the value of \"format\", the output file is rendered as application/vnd.sas.collection+json. If the format is specified as \"prefixedText\", the output is text/plain in which each line of output is prefixed with the name of the line type followed by a colon. In either case, all available output is returned; neither pagination nor filtering is supported.
     * @summary Upload job log output to the Files service
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} jobId Specifies the ID of the job.
     * @param {OutputStreamFileRequest} outputStreamFileRequest Specifies the request to stream output to the Files service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    streamJobLogAsFile: async (
      sessionId: string,
      jobId: string,
      outputStreamFileRequest: OutputStreamFileRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("streamJobLogAsFile", "sessionId", sessionId);
      // verify required parameter 'jobId' is not null or undefined
      assertParamExists("streamJobLogAsFile", "jobId", jobId);
      // verify required parameter 'outputStreamFileRequest' is not null or undefined
      assertParamExists(
        "streamJobLogAsFile",
        "outputStreamFileRequest",
        outputStreamFileRequest
      );
      const localVarPath = `/sessions/{sessionId}/jobs/{jobId}/log`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] =
        "application/vnd.sas.compute.output.stream.file.request+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        outputStreamFileRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Uploads session log output to the Files service and returns the representation of the file resource containing the output. The file is created in one of two formats, based on the value of the property \"format\" specified in the post body. If \"collection\" is specified as the value of \"format\", the output file is rendered as application/vnd.sas.collection+json. If the format is specified as \"prefixedText\", the output is text/plain in which each line of output is prefixed with the name of the line type followed by a colon. In either case, all available output is returned; neither pagination nor filtering is supported.
     * @summary Upload session log output to the Files service
     * @param {string} sessionId Specifies the ID of the session.
     * @param {OutputStreamFileRequest} outputStreamFileRequest Specifies the request to stream output to the Files service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    streamSessionLogAsFile: async (
      sessionId: string,
      outputStreamFileRequest: OutputStreamFileRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("streamSessionLogAsFile", "sessionId", sessionId);
      // verify required parameter 'outputStreamFileRequest' is not null or undefined
      assertParamExists(
        "streamSessionLogAsFile",
        "outputStreamFileRequest",
        outputStreamFileRequest
      );
      const localVarPath = `/sessions/{sessionId}/log`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] =
        "application/vnd.sas.compute.output.stream.file.request+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        outputStreamFileRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LogsApi - functional programming interface
 * @export
 */
export const LogsApi = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LogsApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieves the log output associated with a job. A job log is a subset of the session log. Therefore, the first line of a job log begins at a location (offset) within the session log. This operation returns a collection in which each entry is of the type application/vnd.sas.compute.log.line.
     * @summary Retrieve a job log
     * @param {LogsApiGetJobLogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getJobLog(
      requestParameters: LogsApiGetJobLogRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<JobLogCollection>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getJobLog(
        requestParameters.sessionId,
        requestParameters.jobId,
        requestParameters.start,
        requestParameters.limit,
        requestParameters.type,
        requestParameters.timeout,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Retrieves the entire log output associated with a job as text.
     * @summary Retrieve a job log as text.
     * @param {LogsApiGetJobLogAsTextRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getJobLogAsText(
      requestParameters: LogsApiGetJobLogAsTextRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getJobLogAsText(
        requestParameters.sessionId,
        requestParameters.jobId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Retrieves the log output associated with a session. This operation returns a collection in which each entry is of the type application/vnd.sas.compute.log.line.
     * @summary Retrieve a session log
     * @param {LogsApiGetSessionLogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSessionLog(
      requestParameters: LogsApiGetSessionLogRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<SessionLogCollection>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionLog(
        requestParameters.sessionId,
        requestParameters.start,
        requestParameters.limit,
        requestParameters.type,
        requestParameters.timeout,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Retrieves the log output associated with a session as text.
     * @summary Retrieve a session log as text.
     * @param {LogsApiGetSessionLogAsTextRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSessionLogAsText(
      requestParameters: LogsApiGetSessionLogAsTextRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSessionLogAsText(
          requestParameters.sessionId,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether there is currently a log for a job.
     * @summary Check job log availability
     * @param {LogsApiHeadersForJobLogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForJobLog(
      requestParameters: LogsApiHeadersForJobLogRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForJobLog(
          requestParameters.sessionId,
          requestParameters.jobId,
          requestParameters.start,
          requestParameters.limit,
          requestParameters.type,
          requestParameters.timeout,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether there is currently a log for a job as text.
     * @summary Check for job log as text
     * @param {LogsApiHeadersForJobLogAsTextRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForJobLogAsText(
      requestParameters: LogsApiHeadersForJobLogAsTextRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForJobLogAsText(
          requestParameters.sessionId,
          requestParameters.jobId,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether the session has a log available.
     * @summary Check for a session log
     * @param {LogsApiHeadersForSessionLogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForSessionLog(
      requestParameters: LogsApiHeadersForSessionLogRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForSessionLog(
          requestParameters.sessionId,
          requestParameters.start,
          requestParameters.limit,
          requestParameters.type,
          requestParameters.timeout,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether the session has a log available as text.
     * @summary Check for session log as text.
     * @param {LogsApiHeadersForSessionLogAsTextRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForSessionLogAsText(
      requestParameters: LogsApiHeadersForSessionLogAsTextRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForSessionLogAsText(
          requestParameters.sessionId,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Uploads job log output to the Files service and returns the representation of the file resource containing the output. The file is created in one of two formats, based on the value of the property \"format\" specified in the post body. If \"collection\" is specified as the value of \"format\", the output file is rendered as application/vnd.sas.collection+json. If the format is specified as \"prefixedText\", the output is text/plain in which each line of output is prefixed with the name of the line type followed by a colon. In either case, all available output is returned; neither pagination nor filtering is supported.
     * @summary Upload job log output to the Files service
     * @param {LogsApiStreamJobLogAsFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async streamJobLogAsFile(
      requestParameters: LogsApiStreamJobLogAsFileRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<FileResource>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.streamJobLogAsFile(
          requestParameters.sessionId,
          requestParameters.jobId,
          requestParameters.outputStreamFileRequest,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Uploads session log output to the Files service and returns the representation of the file resource containing the output. The file is created in one of two formats, based on the value of the property \"format\" specified in the post body. If \"collection\" is specified as the value of \"format\", the output file is rendered as application/vnd.sas.collection+json. If the format is specified as \"prefixedText\", the output is text/plain in which each line of output is prefixed with the name of the line type followed by a colon. In either case, all available output is returned; neither pagination nor filtering is supported.
     * @summary Upload session log output to the Files service
     * @param {LogsApiStreamSessionLogAsFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async streamSessionLogAsFile(
      requestParameters: LogsApiStreamSessionLogAsFileRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<FileResource>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.streamSessionLogAsFile(
          requestParameters.sessionId,
          requestParameters.outputStreamFileRequest,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },
  };
};

/**
 * Request parameters for getJobLog operation in LogsApi.
 * @export
 * @interface LogsApiGetJobLogRequest
 */
export interface LogsApiGetJobLogRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof LogsApiGetJobLog
   */
  readonly sessionId: string;

  /**
   * Specifies the ID of the job.
   * @type {string}
   * @memberof LogsApiGetJobLog
   */
  readonly jobId: string;

  /**
   * Specifies the offset of the first item in a collection. The first line is at start&#x3D;0.
   * @type {number}
   * @memberof LogsApiGetJobLog
   */
  readonly start?: number;

  /**
   * Specifies the number of items in a page.
   * @type {number}
   * @memberof LogsApiGetJobLog
   */
  readonly limit?: number;

  /**
   * Restricts log collection to those entries with a specified type. Specify multiple types in a query by separating them with a \&#39;|\&#39;.  For example, you might specify ?type&#x3D;error or ?type&#x3D;error|warning.
   * @type {string}
   * @memberof LogsApiGetJobLog
   */
  readonly type?: string;

  /**
   * Specifies the request time-out in seconds. If no log lines are available over this time period, an empty collection is returned.
   * @type {number}
   * @memberof LogsApiGetJobLog
   */
  readonly timeout?: number;
}

/**
 * Request parameters for getJobLogAsText operation in LogsApi.
 * @export
 * @interface LogsApiGetJobLogAsTextRequest
 */
export interface LogsApiGetJobLogAsTextRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof LogsApiGetJobLogAsText
   */
  readonly sessionId: string;

  /**
   * Specifies the ID of the job.
   * @type {string}
   * @memberof LogsApiGetJobLogAsText
   */
  readonly jobId: string;
}

/**
 * Request parameters for getSessionLog operation in LogsApi.
 * @export
 * @interface LogsApiGetSessionLogRequest
 */
export interface LogsApiGetSessionLogRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof LogsApiGetSessionLog
   */
  readonly sessionId: string;

  /**
   * Specifies the offset of the first item in the collection. The first line is at start&#x3D;0.
   * @type {number}
   * @memberof LogsApiGetSessionLog
   */
  readonly start?: number;

  /**
   * Specifies the number of items in this page.
   * @type {number}
   * @memberof LogsApiGetSessionLog
   */
  readonly limit?: number;

  /**
   * Restricts the log collection to those entries whose type matches the query. Specify multiple types by separating them with a \&#39;|\&#39;. For example, you might specify ?type&#x3D;error or ?type&#x3D;error|warning.
   * @type {string}
   * @memberof LogsApiGetSessionLog
   */
  readonly type?: string;

  /**
   * Specifies the request time-out in seconds.
   * @type {number}
   * @memberof LogsApiGetSessionLog
   */
  readonly timeout?: number;
}

/**
 * Request parameters for getSessionLogAsText operation in LogsApi.
 * @export
 * @interface LogsApiGetSessionLogAsTextRequest
 */
export interface LogsApiGetSessionLogAsTextRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof LogsApiGetSessionLogAsText
   */
  readonly sessionId: string;
}

/**
 * Request parameters for headersForJobLog operation in LogsApi.
 * @export
 * @interface LogsApiHeadersForJobLogRequest
 */
export interface LogsApiHeadersForJobLogRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof LogsApiHeadersForJobLog
   */
  readonly sessionId: string;

  /**
   * Specifies the ID of the job.
   * @type {string}
   * @memberof LogsApiHeadersForJobLog
   */
  readonly jobId: string;

  /**
   * Specifies the offset of the first item in the collection. The first line is at start&#x3D;0.
   * @type {number}
   * @memberof LogsApiHeadersForJobLog
   */
  readonly start?: number;

  /**
   * Specifies the number of items in this page.
   * @type {number}
   * @memberof LogsApiHeadersForJobLog
   */
  readonly limit?: number;

  /**
   * Restricts a log collection to those entries whose type matches the query. Specify multiple types by separating them with a \&#39;|\&#39;.  For example, you might specify ?type&#x3D;error or ?type&#x3D;error|warning.
   * @type {string}
   * @memberof LogsApiHeadersForJobLog
   */
  readonly type?: string;

  /**
   * Specifies the request time-out in seconds. If no log lines are available in this time period, an empty collection is returned.
   * @type {number}
   * @memberof LogsApiHeadersForJobLog
   */
  readonly timeout?: number;
}

/**
 * Request parameters for headersForJobLogAsText operation in LogsApi.
 * @export
 * @interface LogsApiHeadersForJobLogAsTextRequest
 */
export interface LogsApiHeadersForJobLogAsTextRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof LogsApiHeadersForJobLogAsText
   */
  readonly sessionId: string;

  /**
   * Specifies the ID of the job.
   * @type {string}
   * @memberof LogsApiHeadersForJobLogAsText
   */
  readonly jobId: string;
}

/**
 * Request parameters for headersForSessionLog operation in LogsApi.
 * @export
 * @interface LogsApiHeadersForSessionLogRequest
 */
export interface LogsApiHeadersForSessionLogRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof LogsApiHeadersForSessionLog
   */
  readonly sessionId: string;

  /**
   * Specifies the offset of the first item in the collection. The first line is at start&#x3D;0.
   * @type {number}
   * @memberof LogsApiHeadersForSessionLog
   */
  readonly start?: number;

  /**
   * Specifies the number of items in this page.
   * @type {number}
   * @memberof LogsApiHeadersForSessionLog
   */
  readonly limit?: number;

  /**
   * Restricts log collection to those entries whose type matches the query. Specify multiple types by separating them with a \&#39;|\&#39;. For example, you might specify ?type&#x3D;error or ?type&#x3D;error|warning.
   * @type {string}
   * @memberof LogsApiHeadersForSessionLog
   */
  readonly type?: string;

  /**
   * Specifies the request time-out in seconds.
   * @type {number}
   * @memberof LogsApiHeadersForSessionLog
   */
  readonly timeout?: number;
}

/**
 * Request parameters for headersForSessionLogAsText operation in LogsApi.
 * @export
 * @interface LogsApiHeadersForSessionLogAsTextRequest
 */
export interface LogsApiHeadersForSessionLogAsTextRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof LogsApiHeadersForSessionLogAsText
   */
  readonly sessionId: string;
}

/**
 * Request parameters for streamJobLogAsFile operation in LogsApi.
 * @export
 * @interface LogsApiStreamJobLogAsFileRequest
 */
export interface LogsApiStreamJobLogAsFileRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof LogsApiStreamJobLogAsFile
   */
  readonly sessionId: string;

  /**
   * Specifies the ID of the job.
   * @type {string}
   * @memberof LogsApiStreamJobLogAsFile
   */
  readonly jobId: string;

  /**
   * Specifies the request to stream output to the Files service.
   * @type {OutputStreamFileRequest}
   * @memberof LogsApiStreamJobLogAsFile
   */
  readonly outputStreamFileRequest: OutputStreamFileRequest;
}

/**
 * Request parameters for streamSessionLogAsFile operation in LogsApi.
 * @export
 * @interface LogsApiStreamSessionLogAsFileRequest
 */
export interface LogsApiStreamSessionLogAsFileRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof LogsApiStreamSessionLogAsFile
   */
  readonly sessionId: string;

  /**
   * Specifies the request to stream output to the Files service.
   * @type {OutputStreamFileRequest}
   * @memberof LogsApiStreamSessionLogAsFile
   */
  readonly outputStreamFileRequest: OutputStreamFileRequest;
}

/**
 * OptionsApi - axios parameter creator
 * @export
 */
export const OptionsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Returns the value of the option as a plain text value.
     * @summary Get an option by name
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} optionName Specifies the name of the requested option.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOptionValue: async (
      sessionId: string,
      optionName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getOptionValue", "sessionId", sessionId);
      // verify required parameter 'optionName' is not null or undefined
      assertParamExists("getOptionValue", "optionName", optionName);
      const localVarPath = `/sessions/{sessionId}/options/{optionName}`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"optionName"}}`, encodeURIComponent(String(optionName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns information about the specified option, including the value.
     * @summary Get an option representation
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} optionName Specifies the name of the requested option.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOptionValueFull: async (
      sessionId: string,
      optionName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getOptionValueFull", "sessionId", sessionId);
      // verify required parameter 'optionName' is not null or undefined
      assertParamExists("getOptionValueFull", "optionName", optionName);
      const localVarPath =
        `/sessions/{sessionId}/options/{optionName}#optionFull`
          .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
          .replace(`{${"optionName"}}`, encodeURIComponent(String(optionName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns headers for option retrieval.
     * @summary Verify that an option exists
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} optionName Specifies the name of the requested option.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForOptionValue: async (
      sessionId: string,
      optionName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForOptionValue", "sessionId", sessionId);
      // verify required parameter 'optionName' is not null or undefined
      assertParamExists("headersForOptionValue", "optionName", optionName);
      const localVarPath = `/sessions/{sessionId}/options/{optionName}`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"optionName"}}`, encodeURIComponent(String(optionName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns headers for option retrieval.
     * @summary Verify that an option exists
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} optionName Specifies the name of the requested option.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForOptionValueFull: async (
      sessionId: string,
      optionName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForOptionValueFull", "sessionId", sessionId);
      // verify required parameter 'optionName' is not null or undefined
      assertParamExists("headersForOptionValueFull", "optionName", optionName);
      const localVarPath =
        `/sessions/{sessionId}/options/{optionName}#optionFull`
          .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
          .replace(`{${"optionName"}}`, encodeURIComponent(String(optionName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Enables you to set or update the value of the specified option.
     * @summary Set or update option value
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} optionName Specifies the name of the requested option.
     * @param {string} body Specifies the value for the requested option.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateOptionValue: async (
      sessionId: string,
      optionName: string,
      body: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("updateOptionValue", "sessionId", sessionId);
      // verify required parameter 'optionName' is not null or undefined
      assertParamExists("updateOptionValue", "optionName", optionName);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("updateOptionValue", "body", body);
      const localVarPath = `/sessions/{sessionId}/options/{optionName}`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"optionName"}}`, encodeURIComponent(String(optionName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "text/plain";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OptionsApi - functional programming interface
 * @export
 */
export const OptionsApi = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = OptionsApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns the value of the option as a plain text value.
     * @summary Get an option by name
     * @param {OptionsApiGetOptionValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOptionValue(
      requestParameters: OptionsApiGetOptionValueRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getOptionValue(
        requestParameters.sessionId,
        requestParameters.optionName,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns information about the specified option, including the value.
     * @summary Get an option representation
     * @param {OptionsApiGetOptionValueFullRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOptionValueFull(
      requestParameters: OptionsApiGetOptionValueFullRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<SessionOption>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getOptionValueFull(
          requestParameters.sessionId,
          requestParameters.optionName,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns headers for option retrieval.
     * @summary Verify that an option exists
     * @param {OptionsApiHeadersForOptionValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForOptionValue(
      requestParameters: OptionsApiHeadersForOptionValueRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForOptionValue(
          requestParameters.sessionId,
          requestParameters.optionName,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns headers for option retrieval.
     * @summary Verify that an option exists
     * @param {OptionsApiHeadersForOptionValueFullRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForOptionValueFull(
      requestParameters: OptionsApiHeadersForOptionValueFullRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForOptionValueFull(
          requestParameters.sessionId,
          requestParameters.optionName,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Enables you to set or update the value of the specified option.
     * @summary Set or update option value
     * @param {OptionsApiUpdateOptionValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateOptionValue(
      requestParameters: OptionsApiUpdateOptionValueRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<string>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateOptionValue(
          requestParameters.sessionId,
          requestParameters.optionName,
          requestParameters.body,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },
  };
};

/**
 * Request parameters for getOptionValue operation in OptionsApi.
 * @export
 * @interface OptionsApiGetOptionValueRequest
 */
export interface OptionsApiGetOptionValueRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof OptionsApiGetOptionValue
   */
  readonly sessionId: string;

  /**
   * Specifies the name of the requested option.
   * @type {string}
   * @memberof OptionsApiGetOptionValue
   */
  readonly optionName: string;
}

/**
 * Request parameters for getOptionValueFull operation in OptionsApi.
 * @export
 * @interface OptionsApiGetOptionValueFullRequest
 */
export interface OptionsApiGetOptionValueFullRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof OptionsApiGetOptionValueFull
   */
  readonly sessionId: string;

  /**
   * Specifies the name of the requested option.
   * @type {string}
   * @memberof OptionsApiGetOptionValueFull
   */
  readonly optionName: string;
}

/**
 * Request parameters for headersForOptionValue operation in OptionsApi.
 * @export
 * @interface OptionsApiHeadersForOptionValueRequest
 */
export interface OptionsApiHeadersForOptionValueRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof OptionsApiHeadersForOptionValue
   */
  readonly sessionId: string;

  /**
   * Specifies the name of the requested option.
   * @type {string}
   * @memberof OptionsApiHeadersForOptionValue
   */
  readonly optionName: string;
}

/**
 * Request parameters for headersForOptionValueFull operation in OptionsApi.
 * @export
 * @interface OptionsApiHeadersForOptionValueFullRequest
 */
export interface OptionsApiHeadersForOptionValueFullRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof OptionsApiHeadersForOptionValueFull
   */
  readonly sessionId: string;

  /**
   * Specifies the name of the requested option.
   * @type {string}
   * @memberof OptionsApiHeadersForOptionValueFull
   */
  readonly optionName: string;
}

/**
 * Request parameters for updateOptionValue operation in OptionsApi.
 * @export
 * @interface OptionsApiUpdateOptionValueRequest
 */
export interface OptionsApiUpdateOptionValueRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof OptionsApiUpdateOptionValue
   */
  readonly sessionId: string;

  /**
   * Specifies the name of the requested option.
   * @type {string}
   * @memberof OptionsApiUpdateOptionValue
   */
  readonly optionName: string;

  /**
   * Specifies the value for the requested option.
   * @type {string}
   * @memberof OptionsApiUpdateOptionValue
   */
  readonly body: string;
}

/**
 * ResultsApi - axios parameter creator
 * @export
 */
export const ResultsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieves the results of a job as a collection. The results might be ODS output or other output. Standard paging options are available.
     * @summary Fetch the results of a job
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} jobId Specifies the ID of the job whose results you want to retrieve.
     * @param {number} [start] Specifies the offset of the first item in the collection. The first line is at start&#x3D;0.
     * @param {number} [limit] Specifies the number of items requested.
     * @param {string} [filter] Specifies the filter criteria for returned items.
     * @param {string} [sortBy] Sorts returned items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJobResults: async (
      sessionId: string,
      jobId: string,
      start?: number,
      limit?: number,
      filter?: string,
      sortBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getJobResults", "sessionId", sessionId);
      // verify required parameter 'jobId' is not null or undefined
      assertParamExists("getJobResults", "jobId", jobId);
      const localVarPath = `/sessions/{sessionId}/jobs/{jobId}/results`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (filter !== undefined) {
        localVarQueryParameter["filter"] = filter;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter["sortBy"] = sortBy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the results of an entire session. This can be ODS output or other output.
     * @summary Fetch results for a session
     * @param {string} sessionId Specifies the ID of the session.
     * @param {number} [start] Specifies the offset of the first item in the collection.  The first line is at start&#x3D;0.
     * @param {number} [limit] Specifies the number of items that were requested.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSessionResults: async (
      sessionId: string,
      start?: number,
      limit?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getSessionResults", "sessionId", sessionId);
      const localVarPath = `/sessions/{sessionId}/results`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether a job has any results.
     * @summary Check for job results
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} jobId Specifies the ID of the job to fetch results from.
     * @param {number} [start] Specifies the offset of the first item in the collection. The first line is at start&#x3D;0.
     * @param {number} [limit] Specifies the number of items to fetch.
     * @param {string} [filter] Specifies the filter criteria for returned items.
     * @param {string} [sortBy] Sorts returned items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForJobResults: async (
      sessionId: string,
      jobId: string,
      start?: number,
      limit?: number,
      filter?: string,
      sortBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForJobResults", "sessionId", sessionId);
      // verify required parameter 'jobId' is not null or undefined
      assertParamExists("headersForJobResults", "jobId", jobId);
      const localVarPath = `/sessions/{sessionId}/jobs/{jobId}/results`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (filter !== undefined) {
        localVarQueryParameter["filter"] = filter;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter["sortBy"] = sortBy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether the session has any results.
     * @summary Check for session results
     * @param {string} sessionId Specifies the ID of the session.
     * @param {number} [start] Specifies the offset of the first item in the collection.  The first line is at start&#x3D;0.
     * @param {number} [limit] Specifies the number of items that were requested.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForSessionResults: async (
      sessionId: string,
      start?: number,
      limit?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForSessionResults", "sessionId", sessionId);
      const localVarPath = `/sessions/{sessionId}/results`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ResultsApi - functional programming interface
 * @export
 */
export const ResultsApi = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ResultsApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieves the results of a job as a collection. The results might be ODS output or other output. Standard paging options are available.
     * @summary Fetch the results of a job
     * @param {ResultsApiGetJobResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getJobResults(
      requestParameters: ResultsApiGetJobResultsRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<ResultCollection>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getJobResults(
        requestParameters.sessionId,
        requestParameters.jobId,
        requestParameters.start,
        requestParameters.limit,
        requestParameters.filter,
        requestParameters.sortBy,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Retrieves the results of an entire session. This can be ODS output or other output.
     * @summary Fetch results for a session
     * @param {ResultsApiGetSessionResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSessionResults(
      requestParameters: ResultsApiGetSessionResultsRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<ResultCollection>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSessionResults(
          requestParameters.sessionId,
          requestParameters.start,
          requestParameters.limit,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether a job has any results.
     * @summary Check for job results
     * @param {ResultsApiHeadersForJobResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForJobResults(
      requestParameters: ResultsApiHeadersForJobResultsRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForJobResults(
          requestParameters.sessionId,
          requestParameters.jobId,
          requestParameters.start,
          requestParameters.limit,
          requestParameters.filter,
          requestParameters.sortBy,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether the session has any results.
     * @summary Check for session results
     * @param {ResultsApiHeadersForSessionResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForSessionResults(
      requestParameters: ResultsApiHeadersForSessionResultsRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForSessionResults(
          requestParameters.sessionId,
          requestParameters.start,
          requestParameters.limit,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },
  };
};

/**
 * Request parameters for getJobResults operation in ResultsApi.
 * @export
 * @interface ResultsApiGetJobResultsRequest
 */
export interface ResultsApiGetJobResultsRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof ResultsApiGetJobResults
   */
  readonly sessionId: string;

  /**
   * Specifies the ID of the job whose results you want to retrieve.
   * @type {string}
   * @memberof ResultsApiGetJobResults
   */
  readonly jobId: string;

  /**
   * Specifies the offset of the first item in the collection. The first line is at start&#x3D;0.
   * @type {number}
   * @memberof ResultsApiGetJobResults
   */
  readonly start?: number;

  /**
   * Specifies the number of items requested.
   * @type {number}
   * @memberof ResultsApiGetJobResults
   */
  readonly limit?: number;

  /**
   * Specifies the filter criteria for returned items.
   * @type {string}
   * @memberof ResultsApiGetJobResults
   */
  readonly filter?: string;

  /**
   * Sorts returned items.
   * @type {string}
   * @memberof ResultsApiGetJobResults
   */
  readonly sortBy?: string;
}

/**
 * Request parameters for getSessionResults operation in ResultsApi.
 * @export
 * @interface ResultsApiGetSessionResultsRequest
 */
export interface ResultsApiGetSessionResultsRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof ResultsApiGetSessionResults
   */
  readonly sessionId: string;

  /**
   * Specifies the offset of the first item in the collection.  The first line is at start&#x3D;0.
   * @type {number}
   * @memberof ResultsApiGetSessionResults
   */
  readonly start?: number;

  /**
   * Specifies the number of items that were requested.
   * @type {number}
   * @memberof ResultsApiGetSessionResults
   */
  readonly limit?: number;
}

/**
 * Request parameters for headersForJobResults operation in ResultsApi.
 * @export
 * @interface ResultsApiHeadersForJobResultsRequest
 */
export interface ResultsApiHeadersForJobResultsRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof ResultsApiHeadersForJobResults
   */
  readonly sessionId: string;

  /**
   * Specifies the ID of the job to fetch results from.
   * @type {string}
   * @memberof ResultsApiHeadersForJobResults
   */
  readonly jobId: string;

  /**
   * Specifies the offset of the first item in the collection. The first line is at start&#x3D;0.
   * @type {number}
   * @memberof ResultsApiHeadersForJobResults
   */
  readonly start?: number;

  /**
   * Specifies the number of items to fetch.
   * @type {number}
   * @memberof ResultsApiHeadersForJobResults
   */
  readonly limit?: number;

  /**
   * Specifies the filter criteria for returned items.
   * @type {string}
   * @memberof ResultsApiHeadersForJobResults
   */
  readonly filter?: string;

  /**
   * Sorts returned items.
   * @type {string}
   * @memberof ResultsApiHeadersForJobResults
   */
  readonly sortBy?: string;
}

/**
 * Request parameters for headersForSessionResults operation in ResultsApi.
 * @export
 * @interface ResultsApiHeadersForSessionResultsRequest
 */
export interface ResultsApiHeadersForSessionResultsRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof ResultsApiHeadersForSessionResults
   */
  readonly sessionId: string;

  /**
   * Specifies the offset of the first item in the collection.  The first line is at start&#x3D;0.
   * @type {number}
   * @memberof ResultsApiHeadersForSessionResults
   */
  readonly start?: number;

  /**
   * Specifies the number of items that were requested.
   * @type {number}
   * @memberof ResultsApiHeadersForSessionResults
   */
  readonly limit?: number;
}

/**
 * RootApi - axios parameter creator
 * @export
 */
export const RootApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Checks the availability of the service.
     * @summary Check service availability
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForRoot: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of links to the top level resources in this API.
     * @summary Get API resource links
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    root: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RootApi - functional programming interface
 * @export
 */
export const RootApi = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RootApiAxiosParamCreator(configuration);
  return {
    /**
     * Checks the availability of the service.
     * @summary Check service availability
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForRoot(
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.headersForRoot(
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns a list of links to the top level resources in this API.
     * @summary Get API resource links
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async root(options?: AxiosRequestConfig): Promise<AxiosResponse<Api>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.root(options);
      return createRequestFunction(localVarAxiosArgs, configuration);
    },
  };
};

/**
 * ServersApi - axios parameter creator
 * @export
 */
export const ServersApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Stops the specified server instance. The user must have administration permissions on the server to perform this request.
     * @summary Stop the server
     * @param {string} serverId Specifies the ID of the server definition.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteServer: async (
      serverId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'serverId' is not null or undefined
      assertParamExists("deleteServer", "serverId", serverId);
      const localVarPath = `/servers/{serverId}`.replace(
        `{${"serverId"}}`,
        encodeURIComponent(String(serverId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns links and information for the active server instance. The serverId is a unique identifier for an active SAS Compute Server instance.
     * @summary Get links for the active server
     * @param {string} serverId Returns the active server for this server identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServer: async (
      serverId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'serverId' is not null or undefined
      assertParamExists("getServer", "serverId", serverId);
      const localVarPath = `/servers/{serverId}`.replace(
        `{${"serverId"}}`,
        encodeURIComponent(String(serverId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets a paginated list of sessions that are owned by the requested service instance. Standard paging, filtering, and sorting options are provided.
     * @summary Get active sessions for server
     * @param {string} serverId Specifies the ID of the server definition.
     * @param {'application/vnd.sas.compute.session+json' | 'application/vnd.sas.compute.session.summary+json'} [acceptItem] Returns the desired session representation.&lt;br&gt; The Accept-Item options are: &lt;ul&gt; &lt;li&gt;application/vnd.sas.compute.session+json &lt;li&gt;application/vnd.sas.compute.session.summary+json &lt;li&gt;blank &lt;/ul&gt; If the application/vnd.sas.compute.session.summary+json type is specified or no Accept-Item header is specified, then the sessions are returned as summary representation session objects.
     * @param {number} [start] Specifies the offset of first session to return. The default value is \&quot;0\&quot;.
     * @param {number} [limit] Specifies the maximum number of sessions to return. The default value is \&quot;10\&quot;.
     * @param {string} [filter] Specifies the filter criteria for returned sessions.
     * @param {string} [sortBy] Sorts returned sessions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServerSessions: async (
      serverId: string,
      acceptItem?:
        | "application/vnd.sas.compute.session+json"
        | "application/vnd.sas.compute.session.summary+json",
      start?: number,
      limit?: number,
      filter?: string,
      sortBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'serverId' is not null or undefined
      assertParamExists("getServerSessions", "serverId", serverId);
      const localVarPath = `/servers/{serverId}/sessions`.replace(
        `{${"serverId"}}`,
        encodeURIComponent(String(serverId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (filter !== undefined) {
        localVarQueryParameter["filter"] = filter;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter["sortBy"] = sortBy;
      }

      if (acceptItem != null) {
        localVarHeaderParameter["Accept-Item"] = String(acceptItem);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets the current status of a server. The value that is returned is either running or stopped.
     * @summary Get server status
     * @param {string} serverId Specifies the ID of the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServerState: async (
      serverId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'serverId' is not null or undefined
      assertParamExists("getServerState", "serverId", serverId);
      const localVarPath = `/servers/{serverId}/state`.replace(
        `{${"serverId"}}`,
        encodeURIComponent(String(serverId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of active servers. Standard paging, filtering, and sorting options are provided. This method is restricted to users with ADMIN permission on this URL for monitoring purposes. By default, this endpoint returns a summary of the available information about the active servers. Specify an Accept-Item header with the value application/vnd.sas.compute.server+json to get all available information for each server.
     * @summary Get active servers
     * @param {'application/vnd.sas.compute.server+json' | 'application/vnd.sas.compute.server.summary+json'} [acceptItem] Specifies the desired server representation.&lt;br&gt; The Accept-Item options are: &lt;ul&gt; &lt;li&gt;application/vnd.sas.compute.server+json &lt;li&gt;application/vnd.sas.compute.server.summary+json &lt;li&gt;blank &lt;/ul&gt; If the application/vnd.sas.compute.server.summary+json type is specified or no Accept-Item header is specified, then the servers are returned as summary representation server objects.
     * @param {string} [serverId] Returns only the active server that matches the serverId. The serverId is a unique identifier for an active SAS Compute Server instance.
     * @param {string} [contextName] Returns only active servers for the specified context definition.
     * @param {number} [start] Specifies the offset of first active server listing to return. The default value is \&quot;0\&quot;.
     * @param {number} [limit] Specifies the maximum number of active server listings to return. The default value is \&quot;10\&quot;.
     * @param {string} [filter] Specifies the filter criteria for returned active server listings.
     * @param {string} [sortBy] Sorts returned active server listings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServers: async (
      acceptItem?:
        | "application/vnd.sas.compute.server+json"
        | "application/vnd.sas.compute.server.summary+json",
      serverId?: string,
      contextName?: string,
      start?: number,
      limit?: number,
      filter?: string,
      sortBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/servers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (serverId !== undefined) {
        localVarQueryParameter["serverId"] = serverId;
      }

      if (contextName !== undefined) {
        localVarQueryParameter["contextName"] = contextName;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (filter !== undefined) {
        localVarQueryParameter["filter"] = filter;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter["sortBy"] = sortBy;
      }

      if (acceptItem != null) {
        localVarHeaderParameter["Accept-Item"] = String(acceptItem);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether the specified server exists.
     * @summary Verify that a server exists
     * @param {string} serverId Returns the active server for this server identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForServer: async (
      serverId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'serverId' is not null or undefined
      assertParamExists("headersForServer", "serverId", serverId);
      const localVarPath = `/servers/{serverId}`.replace(
        `{${"serverId"}}`,
        encodeURIComponent(String(serverId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether the session endpoint for a server is available.
     * @summary Check sessions endpoint for a server
     * @param {string} serverId Specifies the ID of the server definition.
     * @param {number} [start] Specifies the offset of first session to return. The default value is \&quot;0\&quot;.
     * @param {number} [limit] Specifies the maximum number of sessions to return. The default value is \&quot;10\&quot;.
     * @param {string} [filter] Specifies the filter criteria for returned sessions.
     * @param {string} [sortBy] Sorts returned sessions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForServerSessions: async (
      serverId: string,
      start?: number,
      limit?: number,
      filter?: string,
      sortBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'serverId' is not null or undefined
      assertParamExists("headersForServerSessions", "serverId", serverId);
      const localVarPath = `/servers/{serverId}/sessions`.replace(
        `{${"serverId"}}`,
        encodeURIComponent(String(serverId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (filter !== undefined) {
        localVarQueryParameter["filter"] = filter;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter["sortBy"] = sortBy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether the status endpoint for a server is available.
     * @summary Check server status endpoint
     * @param {string} serverId Specifies the ID of the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForServerState: async (
      serverId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'serverId' is not null or undefined
      assertParamExists("headersForServerState", "serverId", serverId);
      const localVarPath = `/servers/{serverId}/state`.replace(
        `{${"serverId"}}`,
        encodeURIComponent(String(serverId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determine whether the servers endpoint is currently available.
     * @summary Check endpoint availability
     * @param {string} [serverId] Returns the active server that matches a serverId. The serverId is a unique identifier for an active SAS Compute Server instance.
     * @param {string} [contextName] Returns active servers for the specified context definition.
     * @param {number} [start] Specifies the offset of the first active server listing to return. The default value is \&quot;0\&quot;.
     * @param {number} [limit] Specifies the maximum number of active server listings to return. The default value is \&quot;10\&quot;.
     * @param {string} [filter] Specifies the filter criteria for returned active server listings.
     * @param {string} [sortBy] Sorts returned active server listings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForServers: async (
      serverId?: string,
      contextName?: string,
      start?: number,
      limit?: number,
      filter?: string,
      sortBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/servers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (serverId !== undefined) {
        localVarQueryParameter["serverId"] = serverId;
      }

      if (contextName !== undefined) {
        localVarQueryParameter["contextName"] = contextName;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (filter !== undefined) {
        localVarQueryParameter["filter"] = filter;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter["sortBy"] = sortBy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ServersApi - functional programming interface
 * @export
 */
export const ServersApi = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ServersApiAxiosParamCreator(configuration);
  return {
    /**
     * Stops the specified server instance. The user must have administration permissions on the server to perform this request.
     * @summary Stop the server
     * @param {ServersApiDeleteServerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteServer(
      requestParameters: ServersApiDeleteServerRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteServer(
        requestParameters.serverId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns links and information for the active server instance. The serverId is a unique identifier for an active SAS Compute Server instance.
     * @summary Get links for the active server
     * @param {ServersApiGetServerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getServer(
      requestParameters: ServersApiGetServerRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<Server>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getServer(
        requestParameters.serverId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Gets a paginated list of sessions that are owned by the requested service instance. Standard paging, filtering, and sorting options are provided.
     * @summary Get active sessions for server
     * @param {ServersApiGetServerSessionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getServerSessions(
      requestParameters: ServersApiGetServerSessionsRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<SessionSummaryCollection>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getServerSessions(
          requestParameters.serverId,
          requestParameters.acceptItem,
          requestParameters.start,
          requestParameters.limit,
          requestParameters.filter,
          requestParameters.sortBy,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Gets the current status of a server. The value that is returned is either running or stopped.
     * @summary Get server status
     * @param {ServersApiGetServerStateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getServerState(
      requestParameters: ServersApiGetServerStateRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getServerState(
        requestParameters.serverId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns a list of active servers. Standard paging, filtering, and sorting options are provided. This method is restricted to users with ADMIN permission on this URL for monitoring purposes. By default, this endpoint returns a summary of the available information about the active servers. Specify an Accept-Item header with the value application/vnd.sas.compute.server+json to get all available information for each server.
     * @summary Get active servers
     * @param {ServersApiGetServersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getServers(
      requestParameters: ServersApiGetServersRequest = {},
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<ServerSummaryCollection>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getServers(
        requestParameters.acceptItem,
        requestParameters.serverId,
        requestParameters.contextName,
        requestParameters.start,
        requestParameters.limit,
        requestParameters.filter,
        requestParameters.sortBy,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether the specified server exists.
     * @summary Verify that a server exists
     * @param {ServersApiHeadersForServerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForServer(
      requestParameters: ServersApiHeadersForServerRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForServer(
          requestParameters.serverId,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether the session endpoint for a server is available.
     * @summary Check sessions endpoint for a server
     * @param {ServersApiHeadersForServerSessionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForServerSessions(
      requestParameters: ServersApiHeadersForServerSessionsRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForServerSessions(
          requestParameters.serverId,
          requestParameters.start,
          requestParameters.limit,
          requestParameters.filter,
          requestParameters.sortBy,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether the status endpoint for a server is available.
     * @summary Check server status endpoint
     * @param {ServersApiHeadersForServerStateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForServerState(
      requestParameters: ServersApiHeadersForServerStateRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForServerState(
          requestParameters.serverId,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determine whether the servers endpoint is currently available.
     * @summary Check endpoint availability
     * @param {ServersApiHeadersForServersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForServers(
      requestParameters: ServersApiHeadersForServersRequest = {},
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForServers(
          requestParameters.serverId,
          requestParameters.contextName,
          requestParameters.start,
          requestParameters.limit,
          requestParameters.filter,
          requestParameters.sortBy,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },
  };
};

/**
 * Request parameters for deleteServer operation in ServersApi.
 * @export
 * @interface ServersApiDeleteServerRequest
 */
export interface ServersApiDeleteServerRequest {
  /**
   * Specifies the ID of the server definition.
   * @type {string}
   * @memberof ServersApiDeleteServer
   */
  readonly serverId: string;
}

/**
 * Request parameters for getServer operation in ServersApi.
 * @export
 * @interface ServersApiGetServerRequest
 */
export interface ServersApiGetServerRequest {
  /**
   * Returns the active server for this server identifier.
   * @type {string}
   * @memberof ServersApiGetServer
   */
  readonly serverId: string;
}

/**
 * Request parameters for getServerSessions operation in ServersApi.
 * @export
 * @interface ServersApiGetServerSessionsRequest
 */
export interface ServersApiGetServerSessionsRequest {
  /**
   * Specifies the ID of the server definition.
   * @type {string}
   * @memberof ServersApiGetServerSessions
   */
  readonly serverId: string;

  /**
   * Returns the desired session representation.&lt;br&gt; The Accept-Item options are: &lt;ul&gt; &lt;li&gt;application/vnd.sas.compute.session+json &lt;li&gt;application/vnd.sas.compute.session.summary+json &lt;li&gt;blank &lt;/ul&gt; If the application/vnd.sas.compute.session.summary+json type is specified or no Accept-Item header is specified, then the sessions are returned as summary representation session objects.
   * @type {'application/vnd.sas.compute.session+json' | 'application/vnd.sas.compute.session.summary+json'}
   * @memberof ServersApiGetServerSessions
   */
  readonly acceptItem?:
    | "application/vnd.sas.compute.session+json"
    | "application/vnd.sas.compute.session.summary+json";

  /**
   * Specifies the offset of first session to return. The default value is \&quot;0\&quot;.
   * @type {number}
   * @memberof ServersApiGetServerSessions
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of sessions to return. The default value is \&quot;10\&quot;.
   * @type {number}
   * @memberof ServersApiGetServerSessions
   */
  readonly limit?: number;

  /**
   * Specifies the filter criteria for returned sessions.
   * @type {string}
   * @memberof ServersApiGetServerSessions
   */
  readonly filter?: string;

  /**
   * Sorts returned sessions.
   * @type {string}
   * @memberof ServersApiGetServerSessions
   */
  readonly sortBy?: string;
}

/**
 * Request parameters for getServerState operation in ServersApi.
 * @export
 * @interface ServersApiGetServerStateRequest
 */
export interface ServersApiGetServerStateRequest {
  /**
   * Specifies the ID of the server.
   * @type {string}
   * @memberof ServersApiGetServerState
   */
  readonly serverId: string;
}

/**
 * Request parameters for getServers operation in ServersApi.
 * @export
 * @interface ServersApiGetServersRequest
 */
export interface ServersApiGetServersRequest {
  /**
   * Specifies the desired server representation.&lt;br&gt; The Accept-Item options are: &lt;ul&gt; &lt;li&gt;application/vnd.sas.compute.server+json &lt;li&gt;application/vnd.sas.compute.server.summary+json &lt;li&gt;blank &lt;/ul&gt; If the application/vnd.sas.compute.server.summary+json type is specified or no Accept-Item header is specified, then the servers are returned as summary representation server objects.
   * @type {'application/vnd.sas.compute.server+json' | 'application/vnd.sas.compute.server.summary+json'}
   * @memberof ServersApiGetServers
   */
  readonly acceptItem?:
    | "application/vnd.sas.compute.server+json"
    | "application/vnd.sas.compute.server.summary+json";

  /**
   * Returns only the active server that matches the serverId. The serverId is a unique identifier for an active SAS Compute Server instance.
   * @type {string}
   * @memberof ServersApiGetServers
   */
  readonly serverId?: string;

  /**
   * Returns only active servers for the specified context definition.
   * @type {string}
   * @memberof ServersApiGetServers
   */
  readonly contextName?: string;

  /**
   * Specifies the offset of first active server listing to return. The default value is \&quot;0\&quot;.
   * @type {number}
   * @memberof ServersApiGetServers
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of active server listings to return. The default value is \&quot;10\&quot;.
   * @type {number}
   * @memberof ServersApiGetServers
   */
  readonly limit?: number;

  /**
   * Specifies the filter criteria for returned active server listings.
   * @type {string}
   * @memberof ServersApiGetServers
   */
  readonly filter?: string;

  /**
   * Sorts returned active server listings.
   * @type {string}
   * @memberof ServersApiGetServers
   */
  readonly sortBy?: string;
}

/**
 * Request parameters for headersForServer operation in ServersApi.
 * @export
 * @interface ServersApiHeadersForServerRequest
 */
export interface ServersApiHeadersForServerRequest {
  /**
   * Returns the active server for this server identifier.
   * @type {string}
   * @memberof ServersApiHeadersForServer
   */
  readonly serverId: string;
}

/**
 * Request parameters for headersForServerSessions operation in ServersApi.
 * @export
 * @interface ServersApiHeadersForServerSessionsRequest
 */
export interface ServersApiHeadersForServerSessionsRequest {
  /**
   * Specifies the ID of the server definition.
   * @type {string}
   * @memberof ServersApiHeadersForServerSessions
   */
  readonly serverId: string;

  /**
   * Specifies the offset of first session to return. The default value is \&quot;0\&quot;.
   * @type {number}
   * @memberof ServersApiHeadersForServerSessions
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of sessions to return. The default value is \&quot;10\&quot;.
   * @type {number}
   * @memberof ServersApiHeadersForServerSessions
   */
  readonly limit?: number;

  /**
   * Specifies the filter criteria for returned sessions.
   * @type {string}
   * @memberof ServersApiHeadersForServerSessions
   */
  readonly filter?: string;

  /**
   * Sorts returned sessions.
   * @type {string}
   * @memberof ServersApiHeadersForServerSessions
   */
  readonly sortBy?: string;
}

/**
 * Request parameters for headersForServerState operation in ServersApi.
 * @export
 * @interface ServersApiHeadersForServerStateRequest
 */
export interface ServersApiHeadersForServerStateRequest {
  /**
   * Specifies the ID of the server.
   * @type {string}
   * @memberof ServersApiHeadersForServerState
   */
  readonly serverId: string;
}

/**
 * Request parameters for headersForServers operation in ServersApi.
 * @export
 * @interface ServersApiHeadersForServersRequest
 */
export interface ServersApiHeadersForServersRequest {
  /**
   * Returns the active server that matches a serverId. The serverId is a unique identifier for an active SAS Compute Server instance.
   * @type {string}
   * @memberof ServersApiHeadersForServers
   */
  readonly serverId?: string;

  /**
   * Returns active servers for the specified context definition.
   * @type {string}
   * @memberof ServersApiHeadersForServers
   */
  readonly contextName?: string;

  /**
   * Specifies the offset of the first active server listing to return. The default value is \&quot;0\&quot;.
   * @type {number}
   * @memberof ServersApiHeadersForServers
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of active server listings to return. The default value is \&quot;10\&quot;.
   * @type {number}
   * @memberof ServersApiHeadersForServers
   */
  readonly limit?: number;

  /**
   * Specifies the filter criteria for returned active server listings.
   * @type {string}
   * @memberof ServersApiHeadersForServers
   */
  readonly filter?: string;

  /**
   * Sorts returned active server listings.
   * @type {string}
   * @memberof ServersApiHeadersForServers
   */
  readonly sortBy?: string;
}

/**
 * SessionsApi - axios parameter creator
 * @export
 */
export const SessionsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Deletes the specified session.
     * @summary Delete session
     * @param {string} sessionId Specifies the ID of the session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSession: async (
      sessionId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("deleteSession", "sessionId", sessionId);
      const localVarPath = `/sessions/{sessionId}`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a representation of the session that includes links for the session.
     * @summary Get current session information
     * @param {string} sessionId Specifies the ID of the session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSession: async (
      sessionId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getSession", "sessionId", sessionId);
      const localVarPath = `/sessions/{sessionId}`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns the session state.
     * @summary Get session state
     * @param {string} sessionId Specifies the ID of the session.
     * @param {number} [wait] Specifies the request time-out, in seconds. This parameter is ignored unless it is specified in combination with the &#x60;If-None-Match&#x60; header. If the state of the resource remains unchanged until the specified number of seconds has elapsed, then a status of 304 is returned. The request determines whether the current state matches the state when the ETag was specified via the &#x60;If-None-Match&#x60; header. If the state differs within the specified time period, then the new state is returned.
     * @param {string} [ifNoneMatch] Specifies the ETag associated with a value of the session state.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSessionState: async (
      sessionId: string,
      wait?: number,
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getSessionState", "sessionId", sessionId);
      const localVarPath = `/sessions/{sessionId}/state`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (wait !== undefined) {
        localVarQueryParameter["wait"] = wait;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets a paginated list of sessions. Standard paging, filtering, and sorting options are provided. By default, this endpoint returns a summary of the available information about the sessions. Specify an Accept-Item header with the value application/vnd.sas.compute.session+json to get all available information for each session.
     * @summary Get active compute sessions
     * @param {'application/vnd.sas.compute.session+json' | 'application/vnd.sas.compute.session.summary+json'} [acceptItem] Specifies the desired session representation.&lt;br&gt; The Accept-Item options are: &lt;ul&gt; &lt;li&gt;application/vnd.sas.compute.session+json &lt;li&gt;application/vnd.sas.compute.session.summary+json &lt;li&gt;blank &lt;/ul&gt; If the application/vnd.sas.compute.session.summary+json type is specified or no Accept-Item header is specified, then the sessions are returned as summary representation session objects.
     * @param {number} [start] Specifies the offset of first session to return. The default value is \&quot;0\&quot;.
     * @param {number} [limit] Specifies the maximum number of sessions to return. The default value is \&quot;10\&quot;.
     * @param {string} [filter] Specifies the filter criteria for returned sessions.
     * @param {string} [sortBy] Sorts returned sessions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSessions: async (
      acceptItem?:
        | "application/vnd.sas.compute.session+json"
        | "application/vnd.sas.compute.session.summary+json",
      start?: number,
      limit?: number,
      filter?: string,
      sortBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/sessions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (filter !== undefined) {
        localVarQueryParameter["filter"] = filter;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter["sortBy"] = sortBy;
      }

      if (acceptItem != null) {
        localVarHeaderParameter["Accept-Item"] = String(acceptItem);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether the specified session is available.
     * @summary Verify session availability
     * @param {string} sessionId Specifies the ID of the session that you are checking.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForSession: async (
      sessionId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForSession", "sessionId", sessionId);
      const localVarPath = `/sessions/{sessionId}`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether the state endpoint is available.
     * @summary Check state availability
     * @param {string} sessionId Specifies the ID of the session whose state endpoint you are checking.
     * @param {number} [wait] Specifies the request time-out, in seconds. This parameter is ignored unless it is specified in combination with the &#x60;If-None-Match&#x60; header. If the state of the resource remains unchanged until the specified number of seconds has elapsed, then a status of 304 is returned. The request determines whether the current state matches the state when the ETag was specified via the &#x60;If-None-Match&#x60; header. If the state differs within the specified time period, then the new state is returned.
     * @param {string} [ifNoneMatch] Specifies the ETag that is associated with a value of the session state.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForSessionState: async (
      sessionId: string,
      wait?: number,
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForSessionState", "sessionId", sessionId);
      const localVarPath = `/sessions/{sessionId}/state`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (wait !== undefined) {
        localVarQueryParameter["wait"] = wait;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether a session endpoint is available.
     * @summary Check endpoint availability
     * @param {number} [start] Specifies the offset of the first session to return. The default value is \&quot;0\&quot;.
     * @param {number} [limit] Maximum number of sessions to return.  The default value is \&quot;10\&quot;.
     * @param {string} [filter] Specifies the filter criteria for returned sessions.
     * @param {string} [sortBy] Sorts returned sessions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForSessions: async (
      start?: number,
      limit?: number,
      filter?: string,
      sortBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/sessions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (filter !== undefined) {
        localVarQueryParameter["filter"] = filter;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter["sortBy"] = sortBy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Sets the current state of a session. Use this method to cancel running code by setting the state to canceled.
     * @summary Set state of a session
     * @param {string} sessionId Specifies the ID of the session.
     * @param {'canceled' | 'deleted'} value Specifies the new session state, such as canceled.
     * @param {string} ifMatch Specifies the ETag of the session that you are updating.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSessionState: async (
      sessionId: string,
      value: "canceled" | "deleted",
      ifMatch: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("updateSessionState", "sessionId", sessionId);
      // verify required parameter 'value' is not null or undefined
      assertParamExists("updateSessionState", "value", value);
      // verify required parameter 'ifMatch' is not null or undefined
      assertParamExists("updateSessionState", "ifMatch", ifMatch);
      const localVarPath = `/sessions/{sessionId}/state`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (value !== undefined) {
        localVarQueryParameter["value"] = value;
      }

      if (ifMatch != null) {
        localVarHeaderParameter["If-Match"] = String(ifMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SessionsApi - functional programming interface
 * @export
 */
export const SessionsApi = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SessionsApiAxiosParamCreator(configuration);
  return {
    /**
     * Deletes the specified session.
     * @summary Delete session
     * @param {SessionsApiDeleteSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSession(
      requestParameters: SessionsApiDeleteSessionRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSession(
        requestParameters.sessionId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns a representation of the session that includes links for the session.
     * @summary Get current session information
     * @param {SessionsApiGetSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSession(
      requestParameters: SessionsApiGetSessionRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<Session>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSession(
        requestParameters.sessionId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns the session state.
     * @summary Get session state
     * @param {SessionsApiGetSessionStateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSessionState(
      requestParameters: SessionsApiGetSessionStateRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionState(
        requestParameters.sessionId,
        requestParameters.wait,
        requestParameters.ifNoneMatch,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Gets a paginated list of sessions. Standard paging, filtering, and sorting options are provided. By default, this endpoint returns a summary of the available information about the sessions. Specify an Accept-Item header with the value application/vnd.sas.compute.session+json to get all available information for each session.
     * @summary Get active compute sessions
     * @param {SessionsApiGetSessionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSessions(
      requestParameters: SessionsApiGetSessionsRequest = {},
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<SessionSummaryCollection>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSessions(
        requestParameters.acceptItem,
        requestParameters.start,
        requestParameters.limit,
        requestParameters.filter,
        requestParameters.sortBy,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether the specified session is available.
     * @summary Verify session availability
     * @param {SessionsApiHeadersForSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForSession(
      requestParameters: SessionsApiHeadersForSessionRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForSession(
          requestParameters.sessionId,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether the state endpoint is available.
     * @summary Check state availability
     * @param {SessionsApiHeadersForSessionStateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForSessionState(
      requestParameters: SessionsApiHeadersForSessionStateRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForSessionState(
          requestParameters.sessionId,
          requestParameters.wait,
          requestParameters.ifNoneMatch,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether a session endpoint is available.
     * @summary Check endpoint availability
     * @param {SessionsApiHeadersForSessionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForSessions(
      requestParameters: SessionsApiHeadersForSessionsRequest = {},
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForSessions(
          requestParameters.start,
          requestParameters.limit,
          requestParameters.filter,
          requestParameters.sortBy,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Sets the current state of a session. Use this method to cancel running code by setting the state to canceled.
     * @summary Set state of a session
     * @param {SessionsApiUpdateSessionStateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateSessionState(
      requestParameters: SessionsApiUpdateSessionStateRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateSessionState(
          requestParameters.sessionId,
          requestParameters.value,
          requestParameters.ifMatch,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },
  };
};

/**
 * Request parameters for deleteSession operation in SessionsApi.
 * @export
 * @interface SessionsApiDeleteSessionRequest
 */
export interface SessionsApiDeleteSessionRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof SessionsApiDeleteSession
   */
  readonly sessionId: string;
}

/**
 * Request parameters for getSession operation in SessionsApi.
 * @export
 * @interface SessionsApiGetSessionRequest
 */
export interface SessionsApiGetSessionRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof SessionsApiGetSession
   */
  readonly sessionId: string;
}

/**
 * Request parameters for getSessionState operation in SessionsApi.
 * @export
 * @interface SessionsApiGetSessionStateRequest
 */
export interface SessionsApiGetSessionStateRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof SessionsApiGetSessionState
   */
  readonly sessionId: string;

  /**
   * Specifies the request time-out, in seconds. This parameter is ignored unless it is specified in combination with the &#x60;If-None-Match&#x60; header. If the state of the resource remains unchanged until the specified number of seconds has elapsed, then a status of 304 is returned. The request determines whether the current state matches the state when the ETag was specified via the &#x60;If-None-Match&#x60; header. If the state differs within the specified time period, then the new state is returned.
   * @type {number}
   * @memberof SessionsApiGetSessionState
   */
  readonly wait?: number;

  /**
   * Specifies the ETag associated with a value of the session state.
   * @type {string}
   * @memberof SessionsApiGetSessionState
   */
  readonly ifNoneMatch?: string;
}

/**
 * Request parameters for getSessions operation in SessionsApi.
 * @export
 * @interface SessionsApiGetSessionsRequest
 */
export interface SessionsApiGetSessionsRequest {
  /**
   * Specifies the desired session representation.&lt;br&gt; The Accept-Item options are: &lt;ul&gt; &lt;li&gt;application/vnd.sas.compute.session+json &lt;li&gt;application/vnd.sas.compute.session.summary+json &lt;li&gt;blank &lt;/ul&gt; If the application/vnd.sas.compute.session.summary+json type is specified or no Accept-Item header is specified, then the sessions are returned as summary representation session objects.
   * @type {'application/vnd.sas.compute.session+json' | 'application/vnd.sas.compute.session.summary+json'}
   * @memberof SessionsApiGetSessions
   */
  readonly acceptItem?:
    | "application/vnd.sas.compute.session+json"
    | "application/vnd.sas.compute.session.summary+json";

  /**
   * Specifies the offset of first session to return. The default value is \&quot;0\&quot;.
   * @type {number}
   * @memberof SessionsApiGetSessions
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of sessions to return. The default value is \&quot;10\&quot;.
   * @type {number}
   * @memberof SessionsApiGetSessions
   */
  readonly limit?: number;

  /**
   * Specifies the filter criteria for returned sessions.
   * @type {string}
   * @memberof SessionsApiGetSessions
   */
  readonly filter?: string;

  /**
   * Sorts returned sessions.
   * @type {string}
   * @memberof SessionsApiGetSessions
   */
  readonly sortBy?: string;
}

/**
 * Request parameters for headersForSession operation in SessionsApi.
 * @export
 * @interface SessionsApiHeadersForSessionRequest
 */
export interface SessionsApiHeadersForSessionRequest {
  /**
   * Specifies the ID of the session that you are checking.
   * @type {string}
   * @memberof SessionsApiHeadersForSession
   */
  readonly sessionId: string;
}

/**
 * Request parameters for headersForSessionState operation in SessionsApi.
 * @export
 * @interface SessionsApiHeadersForSessionStateRequest
 */
export interface SessionsApiHeadersForSessionStateRequest {
  /**
   * Specifies the ID of the session whose state endpoint you are checking.
   * @type {string}
   * @memberof SessionsApiHeadersForSessionState
   */
  readonly sessionId: string;

  /**
   * Specifies the request time-out, in seconds. This parameter is ignored unless it is specified in combination with the &#x60;If-None-Match&#x60; header. If the state of the resource remains unchanged until the specified number of seconds has elapsed, then a status of 304 is returned. The request determines whether the current state matches the state when the ETag was specified via the &#x60;If-None-Match&#x60; header. If the state differs within the specified time period, then the new state is returned.
   * @type {number}
   * @memberof SessionsApiHeadersForSessionState
   */
  readonly wait?: number;

  /**
   * Specifies the ETag that is associated with a value of the session state.
   * @type {string}
   * @memberof SessionsApiHeadersForSessionState
   */
  readonly ifNoneMatch?: string;
}

/**
 * Request parameters for headersForSessions operation in SessionsApi.
 * @export
 * @interface SessionsApiHeadersForSessionsRequest
 */
export interface SessionsApiHeadersForSessionsRequest {
  /**
   * Specifies the offset of the first session to return. The default value is \&quot;0\&quot;.
   * @type {number}
   * @memberof SessionsApiHeadersForSessions
   */
  readonly start?: number;

  /**
   * Maximum number of sessions to return.  The default value is \&quot;10\&quot;.
   * @type {number}
   * @memberof SessionsApiHeadersForSessions
   */
  readonly limit?: number;

  /**
   * Specifies the filter criteria for returned sessions.
   * @type {string}
   * @memberof SessionsApiHeadersForSessions
   */
  readonly filter?: string;

  /**
   * Sorts returned sessions.
   * @type {string}
   * @memberof SessionsApiHeadersForSessions
   */
  readonly sortBy?: string;
}

/**
 * Request parameters for updateSessionState operation in SessionsApi.
 * @export
 * @interface SessionsApiUpdateSessionStateRequest
 */
export interface SessionsApiUpdateSessionStateRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof SessionsApiUpdateSessionState
   */
  readonly sessionId: string;

  /**
   * Specifies the new session state, such as canceled.
   * @type {'canceled' | 'deleted'}
   * @memberof SessionsApiUpdateSessionState
   */
  readonly value: "canceled" | "deleted";

  /**
   * Specifies the ETag of the session that you are updating.
   * @type {string}
   * @memberof SessionsApiUpdateSessionState
   */
  readonly ifMatch: string;
}

/**
 * VariablesApi - axios parameter creator
 * @export
 */
export const VariablesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Returns the information about the requested variable in the session. By default, the session variable resource is returned. You can get the simple value of the variable by specifying an Accept header of text/plain.
     * @summary Get a variable from the session
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} variableName Specifies the name of the variable to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVariable: async (
      sessionId: string,
      variableName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getVariable", "sessionId", sessionId);
      // verify required parameter 'variableName' is not null or undefined
      assertParamExists("getVariable", "variableName", variableName);
      const localVarPath = `/sessions/{sessionId}/variables/{variableName}`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(
          `{${"variableName"}}`,
          encodeURIComponent(String(variableName))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets the variables that are currently defined in a session. These variables are macro variables that have been defined either by SAS or by you. A collection of application/vnd.sas.compute.variable items is returned. Standard pagination rules apply, and simple filtering is allowed.
     * @summary Get session variables
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} [filter] Specifies filter criteria for returned context definitions.
     * @param {number} [start] Specifies the offset of the first variable to return. The default value is \&quot;0\&quot;.
     * @param {number} [limit] Specifies the maximum number of variables to return in a page. The default value is \&quot;50\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVariables: async (
      sessionId: string,
      filter?: string,
      start?: number,
      limit?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getVariables", "sessionId", sessionId);
      const localVarPath = `/sessions/{sessionId}/variables`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (filter !== undefined) {
        localVarQueryParameter["filter"] = filter;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether the requested variable exists for a session and obtains the header information for the variable.
     * @summary Determine whether a variable exists in a session
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} variableName Specifies the name of the variable to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForVariable: async (
      sessionId: string,
      variableName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForVariable", "sessionId", sessionId);
      // verify required parameter 'variableName' is not null or undefined
      assertParamExists("headersForVariable", "variableName", variableName);
      const localVarPath = `/sessions/{sessionId}/variables/{variableName}`
        .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
        .replace(
          `{${"variableName"}}`,
          encodeURIComponent(String(variableName))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether it is possible to get variables for a session.
     * @summary Check variable availability for a session
     * @param {string} sessionId Specifies the ID of the session.
     * @param {string} [filter] Specifies the filter criteria for returned context definitions.
     * @param {number} [start] Specifies the offset of the first variable to return. The default value is \&quot;0\&quot;.
     * @param {number} [limit] Specifies the maximum number of variables to return in a page. The default value is \&quot;50\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForVariables: async (
      sessionId: string,
      filter?: string,
      start?: number,
      limit?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("headersForVariables", "sessionId", sessionId);
      const localVarPath = `/sessions/{sessionId}/variables`.replace(
        `{${"sessionId"}}`,
        encodeURIComponent(String(sessionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (filter !== undefined) {
        localVarQueryParameter["filter"] = filter;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * VariablesApi - functional programming interface
 * @export
 */
export const VariablesApi = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    VariablesApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns the information about the requested variable in the session. By default, the session variable resource is returned. You can get the simple value of the variable by specifying an Accept header of text/plain.
     * @summary Get a variable from the session
     * @param {VariablesApiGetVariableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVariable(
      requestParameters: VariablesApiGetVariableRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<Variable>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getVariable(
        requestParameters.sessionId,
        requestParameters.variableName,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Gets the variables that are currently defined in a session. These variables are macro variables that have been defined either by SAS or by you. A collection of application/vnd.sas.compute.variable items is returned. Standard pagination rules apply, and simple filtering is allowed.
     * @summary Get session variables
     * @param {VariablesApiGetVariablesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVariables(
      requestParameters: VariablesApiGetVariablesRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<SessionVariableCollection>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getVariables(
        requestParameters.sessionId,
        requestParameters.filter,
        requestParameters.start,
        requestParameters.limit,
        options
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether the requested variable exists for a session and obtains the header information for the variable.
     * @summary Determine whether a variable exists in a session
     * @param {VariablesApiHeadersForVariableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForVariable(
      requestParameters: VariablesApiHeadersForVariableRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForVariable(
          requestParameters.sessionId,
          requestParameters.variableName,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether it is possible to get variables for a session.
     * @summary Check variable availability for a session
     * @param {VariablesApiHeadersForVariablesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForVariables(
      requestParameters: VariablesApiHeadersForVariablesRequest,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForVariables(
          requestParameters.sessionId,
          requestParameters.filter,
          requestParameters.start,
          requestParameters.limit,
          options
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },
  };
};

/**
 * Request parameters for getVariable operation in VariablesApi.
 * @export
 * @interface VariablesApiGetVariableRequest
 */
export interface VariablesApiGetVariableRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof VariablesApiGetVariable
   */
  readonly sessionId: string;

  /**
   * Specifies the name of the variable to retrieve.
   * @type {string}
   * @memberof VariablesApiGetVariable
   */
  readonly variableName: string;
}

/**
 * Request parameters for getVariables operation in VariablesApi.
 * @export
 * @interface VariablesApiGetVariablesRequest
 */
export interface VariablesApiGetVariablesRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof VariablesApiGetVariables
   */
  readonly sessionId: string;

  /**
   * Specifies filter criteria for returned context definitions.
   * @type {string}
   * @memberof VariablesApiGetVariables
   */
  readonly filter?: string;

  /**
   * Specifies the offset of the first variable to return. The default value is \&quot;0\&quot;.
   * @type {number}
   * @memberof VariablesApiGetVariables
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of variables to return in a page. The default value is \&quot;50\&quot;.
   * @type {number}
   * @memberof VariablesApiGetVariables
   */
  readonly limit?: number;
}

/**
 * Request parameters for headersForVariable operation in VariablesApi.
 * @export
 * @interface VariablesApiHeadersForVariableRequest
 */
export interface VariablesApiHeadersForVariableRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof VariablesApiHeadersForVariable
   */
  readonly sessionId: string;

  /**
   * Specifies the name of the variable to retrieve.
   * @type {string}
   * @memberof VariablesApiHeadersForVariable
   */
  readonly variableName: string;
}

/**
 * Request parameters for headersForVariables operation in VariablesApi.
 * @export
 * @interface VariablesApiHeadersForVariablesRequest
 */
export interface VariablesApiHeadersForVariablesRequest {
  /**
   * Specifies the ID of the session.
   * @type {string}
   * @memberof VariablesApiHeadersForVariables
   */
  readonly sessionId: string;

  /**
   * Specifies the filter criteria for returned context definitions.
   * @type {string}
   * @memberof VariablesApiHeadersForVariables
   */
  readonly filter?: string;

  /**
   * Specifies the offset of the first variable to return. The default value is \&quot;0\&quot;.
   * @type {number}
   * @memberof VariablesApiHeadersForVariables
   */
  readonly start?: number;

  /**
   * Specifies the maximum number of variables to return in a page. The default value is \&quot;50\&quot;.
   * @type {number}
   * @memberof VariablesApiHeadersForVariables
   */
  readonly limit?: number;
}
