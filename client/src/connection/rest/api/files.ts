// Copyright Â© 2023, SAS Institute Inc., Cary, NC, USA.  All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

/**
 * Files
 * The Files API provides persistence of files, such as comment attachments and report images.With this version File API will now support versioned files. A solution can maintain multiple versions of a file. There are few additional parameters which will be required while creation of File, which indicates that the File is a versioned file.
 *
 * The version of the OpenAPI document: 9
 * Contact: devex@sas.com
 *
 * NOTE: This class is auto generated by OpenAPI
 * Do not edit the class manually.
 */

/* tslint:disable */

/* eslint-disable */
import { AxiosRequestConfig, AxiosResponse } from "axios";
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from "url";

// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  RequestArgs,
  assertParamExists,
  createRequestFunction,
  serializeDataIfNeeded,
  setSearchParams,
  toPathString,
} from "./common";
import { Configuration } from "./configuration";

/**
 * The list of links to top-level resources and operations available from the root of the API.
 * @export
 * @interface Api
 */
export interface Api {
  /**
   * The API\'s top-level links.
   * @type {Array<Link>}
   * @memberof Api
   */
  links?: Array<Link>;
  /**
   * The version number of the API representation. This is version 1.
   * @type {number}
   * @memberof Api
   */
  version?: number;
}
/**
 * The configuration settings for this service.
 * @export
 * @interface AttributesMap
 */
export interface AttributesMap {
  /**
   * The comma seperated list of blocked media type.
   * @type {Array<string>}
   * @memberof AttributesMap
   */
  blockedTypes?: Array<string>;
  /**
   * The max files size which can be uploaded in the file service.
   * @type {number}
   * @memberof AttributesMap
   */
  maxFileSizeMB?: number;
}
/**
 * This is a base schema used to define paginated collections of resources. This base schema is extended by other schemas in APIs by adding an \'items\' array property. These extensions define the application/vnd.sas.collection media type (version 2)
 * @export
 * @interface BaseCollection2
 */
export interface BaseCollection2 {
  /**
   * A space-delimited list of media types from which an `Accept` header may be constructed.
   * @type {string}
   * @memberof BaseCollection2
   */
  accept?: string;
  /**
   * If populated indicates the number of items in the collection.
   * @type {number}
   * @memberof BaseCollection2
   */
  count?: number;
  /**
   * The number of items that were requested for the collection.
   * @type {number}
   * @memberof BaseCollection2
   */
  limit?: number;
  /**
   * The links that apply to the collection.
   * @type {Array<Link>}
   * @memberof BaseCollection2
   */
  links?: Array<Link>;
  /**
   * The name of the collection.
   * @type {string}
   * @memberof BaseCollection2
   */
  name?: string;
  /**
   * The zero-based index of the first item in the collection.
   * @type {number}
   * @memberof BaseCollection2
   */
  start?: number;
  /**
   * The version number of the collection representation. This representation is version 2.
   * @type {number}
   * @memberof BaseCollection2
   */
  version?: number;
}
/**
 * Standard media type for error response.
 * @export
 * @interface Error2
 */
export interface Error2 {
  /**
   * Messages that provide additional details about the cause of the error.
   * @type {Array<string>}
   * @memberof Error2
   */
  details?: Array<string>;
  /**
   * The numeric ID for the error.
   * @type {number}
   * @memberof Error2
   */
  errorCode?: number;
  /**
   * Any additional errors that occurred.
   * @type {Array<Error2>}
   * @memberof Error2
   */
  errors?: Array<Error2>;
  /**
   * The HTTP status code for the error.
   * @type {number}
   * @memberof Error2
   */
  httpStatusCode?: number;
  /**
   * The string ID for the error.
   * @type {string}
   * @memberof Error2
   */
  id?: string;
  /**
   * The links that apply to the error.
   * @type {Array<Link>}
   * @memberof Error2
   */
  links?: Array<Link>;
  /**
   * The message for the error.
   * @type {string}
   * @memberof Error2
   */
  message?: string;
  /**
   * A message that describes how to resolve the error.
   * @type {string}
   * @memberof Error2
   */
  remediation?: string;
  /**
   * The version number of the error representation. This representation is version 2.
   * @type {number}
   * @memberof Error2
   */
  version?: number;
}
/**
 * The file service field to be indexed.
 * @export
 * @interface Field
 */
export interface Field {
  /**
   * The boolean value to represent if the field is primary key.
   * @type {boolean}
   * @memberof Field
   */
  primaryKey?: boolean;
  /**
   * The name of the field.
   * @type {string}
   * @memberof Field
   */
  name?: string;
  /**
   * The type of the field.
   * @type {string}
   * @memberof Field
   */
  type?: string;
  /**
   * The label given to the field.
   * @type {string}
   * @memberof Field
   */
  label?: string;
  /**
   * It indicates if the field is facetable.
   * @type {boolean}
   * @memberof Field
   */
  facetable?: boolean;
  /**
   * It indicates if the field is searchable.
   * @type {boolean}
   * @memberof Field
   */
  searchable?: boolean;
  /**
   * It indicates if the field is default facet.
   * @type {boolean}
   * @memberof Field
   */
  defaultFacet?: boolean;
  /**
   * It indicates if the field is multivalued.
   * @type {boolean}
   * @memberof Field
   */
  multiValued?: boolean;
  /**
   * It indicates if the field should be displayed.
   * @type {boolean}
   * @memberof Field
   */
  displayableFacet?: boolean;
}
/**
 * Details of file resource
 * @export
 * @interface FileResource
 */
export interface FileResource {
  /**
   * The URI of the object that is associated with or linked to a file resource.
   * @type {string}
   * @memberof FileResource
   */
  parentUri?: string;
  /**
   * Properties that are specific to this file. Each property uses a \"key\" : \"value\" format. Use a comma to separate  properties.
   * @type {{ [key: string]: string; }}
   * @memberof FileResource
   */
  properties?: { [key: string]: string };
  /**
   * Value for the Content-Disposition header. It is specified in response when downloading the file.
   * @type {string}
   * @memberof FileResource
   */
  contentDisposition?: string;
  /**
   * The type of the content.
   * @type {string}
   * @memberof FileResource
   */
  contentType?: string;
  /**
   * The name of the author.
   * @type {string}
   * @memberof FileResource
   */
  createdBy?: string;
  /**
   * The timestamp that indicates when the file resource was created.
   * @type {string}
   * @memberof FileResource
   */
  creationTimeStamp?: string;
  /**
   * The description of the file resource.
   * @type {string}
   * @memberof FileResource
   */
  description?: string;
  /**
   * The type of the file resource.
   * @type {string}
   * @memberof FileResource
   */
  documentType?: string;
  /**
   * The encoding of the file resource.
   * @type {string}
   * @memberof FileResource
   */
  encoding?: string;
  /**
   * The identifier of the file resource.
   * @type {string}
   * @memberof FileResource
   */
  id?: string;
  /**
   * Links that apply to this file resource. The links are \"self\", \"content\", \"patch\", \"update\", and \"delete\".
   * @type {Array<Link>}
   * @memberof FileResource
   */
  links?: Array<Link>;
  /**
   * The name of the user who modified this file resource.
   * @type {string}
   * @memberof FileResource
   */
  modifiedBy?: string;
  /**
   * The timestamp when the file resource was modified.
   * @type {string}
   * @memberof FileResource
   */
  modifiedTimeStamp?: string;
  /**
   * The name of the file resource.
   * @type {string}
   * @memberof FileResource
   */
  name?: string;
  /**
   * The byte size of the file resource content.
   * @type {number}
   * @memberof FileResource
   */
  size?: number;
  /**
   * The type definition name of the file. If the file is associated with a folder and the client does not provide the value of this parameter, the file-service tries to find the best possible value using the type-registry service. If it fails to find a default value, it defaults to \"file\".
   * @type {string}
   * @memberof FileResource
   */
  typeDefName?: string;
  /**
   * It indicates if a file is searchable or not.
   * @type {boolean}
   * @memberof FileResource
   */
  searchable?: boolean;
  /**
   * It indicates the version of the file. In case the file is not versioned then the value will be \'0\'. If the file is versioned then the file Version will be greater then \'0\'.
   * @type {number}
   * @memberof FileResource
   */
  fileVersion?: number;
  /**
   * It indicates the fileStatus whether locked or unlocked.
   * @type {string}
   * @memberof FileResource
   */
  fileStatus?: string;
  /**
   * An indicator specifying if a file contains virus or not.
   * @type {boolean}
   * @memberof FileResource
   */
  virusDetected?: boolean;
  /**
   * An indicator specifying if a file of type html, JS or CSS, contains an URL.
   * @type {boolean}
   * @memberof FileResource
   */
  urlDetected?: boolean;
  /**
   * An indicator that if a file contains vulnerability then the file will be quarantined.
   * @type {boolean}
   * @memberof FileResource
   */
  quarantine?: boolean;
}
/**
 * A collection of file representations.
 * @export
 * @interface FileResourceCollection
 */
export interface FileResourceCollection {
  /**
   * A space-delimited list of media types from which an `Accept` header may be constructed.
   * @type {string}
   * @memberof FileResourceCollection
   */
  accept?: string;
  /**
   * If populated indicates the number of items in the collection.
   * @type {number}
   * @memberof FileResourceCollection
   */
  count?: number;
  /**
   * The number of items that were requested for the collection.
   * @type {number}
   * @memberof FileResourceCollection
   */
  limit?: number;
  /**
   * The links that apply to the collection.
   * @type {Array<Link>}
   * @memberof FileResourceCollection
   */
  links?: Array<Link>;
  /**
   * The name of the collection.
   * @type {string}
   * @memberof FileResourceCollection
   */
  name?: string;
  /**
   * The zero-based index of the first item in the collection.
   * @type {number}
   * @memberof FileResourceCollection
   */
  start?: number;
  /**
   * The version number of the collection representation. This representation is version 2.
   * @type {number}
   * @memberof FileResourceCollection
   */
  version?: number;
  /**
   * The array of application/vnd.sas.file representations.
   * @type {Array<FileResource>}
   * @memberof FileResourceCollection
   */
  items?: Array<FileResource>;
}
/**
 *
 * @export
 * @interface FileResourceCollectionAllOf
 */
export interface FileResourceCollectionAllOf {
  /**
   * The array of application/vnd.sas.file representations.
   * @type {Array<FileResource>}
   * @memberof FileResourceCollectionAllOf
   */
  items?: Array<FileResource>;
}
/**
 * Collection of indexable representation of the files.
 * @export
 * @interface FileResourceIndex
 */
export interface FileResourceIndex {
  /**
   * The version of the representation.
   * @type {number}
   * @memberof FileResourceIndex
   */
  version?: number;
  /**
   *
   * @type {Array<IndexableDataElement>}
   * @memberof FileResourceIndex
   */
  properties?: Array<IndexableDataElement>;
  /**
   * The URI of the representation.
   * @type {string}
   * @memberof FileResourceIndex
   */
  resourceUri?: string;
  /**
   * The sasType of the representation.
   * @type {string}
   * @memberof FileResourceIndex
   */
  sasType?: string;
}
/**
 * A collection of file representations.
 * @export
 * @interface FileResourceIndexCollection
 */
export interface FileResourceIndexCollection {
  /**
   * A space-delimited list of media types from which an `Accept` header may be constructed.
   * @type {string}
   * @memberof FileResourceIndexCollection
   */
  accept?: string;
  /**
   * If populated indicates the number of items in the collection.
   * @type {number}
   * @memberof FileResourceIndexCollection
   */
  count?: number;
  /**
   * The number of items that were requested for the collection.
   * @type {number}
   * @memberof FileResourceIndexCollection
   */
  limit?: number;
  /**
   * The links that apply to the collection.
   * @type {Array<Link>}
   * @memberof FileResourceIndexCollection
   */
  links?: Array<Link>;
  /**
   * The name of the collection.
   * @type {string}
   * @memberof FileResourceIndexCollection
   */
  name?: string;
  /**
   * The zero-based index of the first item in the collection.
   * @type {number}
   * @memberof FileResourceIndexCollection
   */
  start?: number;
  /**
   * The version number of the collection representation. This representation is version 2.
   * @type {number}
   * @memberof FileResourceIndexCollection
   */
  version?: number;
  /**
   * The array of file indexable representations.
   * @type {Array<FileResourceIndex>}
   * @memberof FileResourceIndexCollection
   */
  items?: Array<FileResourceIndex>;
}
/**
 *
 * @export
 * @interface FileResourceIndexCollectionAllOf
 */
export interface FileResourceIndexCollectionAllOf {
  /**
   * The array of file indexable representations.
   * @type {Array<FileResourceIndex>}
   * @memberof FileResourceIndexCollectionAllOf
   */
  items?: Array<FileResourceIndex>;
}
/**
 * A generic summary representation of a file.
 * @export
 * @interface FileResourceSummary
 */
export interface FileResourceSummary {
  /**
   * The name of the author.
   * @type {string}
   * @memberof FileResourceSummary
   */
  createdBy?: string;
  /**
   * The timestamp that indicates when the file resource was created.
   * @type {string}
   * @memberof FileResourceSummary
   */
  creationTimeStamp?: string;
  /**
   * The description of the file resource.
   * @type {string}
   * @memberof FileResourceSummary
   */
  description?: string;
  /**
   * The identifier of the file resource.
   * @type {string}
   * @memberof FileResourceSummary
   */
  id?: string;
  /**
   * The alternate link to fetch the complete representation of the file resource--for example, vnd.sas.file.
   * @type {Array<Link>}
   * @memberof FileResourceSummary
   */
  links?: Array<Link>;
  /**
   * The name of the user who modified the file resource.
   * @type {string}
   * @memberof FileResourceSummary
   */
  modifiedBy?: string;
  /**
   * The timestamp that indicates when the file resource was modified.
   * @type {string}
   * @memberof FileResourceSummary
   */
  modifiedTimeStamp?: string;
  /**
   * The name of the file.
   * @type {string}
   * @memberof FileResourceSummary
   */
  name?: string;
  /**
   * The timestamp that indicates when the file expires.
   * @type {string}
   * @memberof FileResourceSummary
   */
  expirationTimeStamp?: string;
  /**
   * The type definition name of the fileIf the file is associated with a folder and the client does not provide the value of this parameter, the  file-service tries to find the best possible value using type-registry service. If it fails to find a default value, it defaults to \"file\".
   * @type {string}
   * @memberof FileResourceSummary
   */
  typeDefName?: string;
  /**
   * The version of the media type.
   * @type {number}
   * @memberof FileResourceSummary
   */
  version?: number;
}
/**
 * A collection of file representations.
 * @export
 * @interface FileResourceSummaryCollection
 */
export interface FileResourceSummaryCollection {
  /**
   * A space-delimited list of media types from which an `Accept` header may be constructed.
   * @type {string}
   * @memberof FileResourceSummaryCollection
   */
  accept?: string;
  /**
   * If populated indicates the number of items in the collection.
   * @type {number}
   * @memberof FileResourceSummaryCollection
   */
  count?: number;
  /**
   * The number of items that were requested for the collection.
   * @type {number}
   * @memberof FileResourceSummaryCollection
   */
  limit?: number;
  /**
   * The links that apply to the collection.
   * @type {Array<Link>}
   * @memberof FileResourceSummaryCollection
   */
  links?: Array<Link>;
  /**
   * The name of the collection.
   * @type {string}
   * @memberof FileResourceSummaryCollection
   */
  name?: string;
  /**
   * The zero-based index of the first item in the collection.
   * @type {number}
   * @memberof FileResourceSummaryCollection
   */
  start?: number;
  /**
   * The version number of the collection representation. This representation is version 2.
   * @type {number}
   * @memberof FileResourceSummaryCollection
   */
  version?: number;
  /**
   * The array of file resource summary representations.
   * @type {Array<FileResourceSummary>}
   * @memberof FileResourceSummaryCollection
   */
  items?: Array<FileResourceSummary>;
}
/**
 *
 * @export
 * @interface FileResourceSummaryCollectionAllOf
 */
export interface FileResourceSummaryCollectionAllOf {
  /**
   * The array of file resource summary representations.
   * @type {Array<FileResourceSummary>}
   * @memberof FileResourceSummaryCollectionAllOf
   */
  items?: Array<FileResourceSummary>;
}
/**
 * File to Patch
 * @export
 * @interface FileToPatch
 */
export interface FileToPatch {
  /**
   * The URI of the object that is associated with or linked to a file resource.
   * @type {string}
   * @memberof FileToPatch
   */
  parentUri?: string;
  /**
   * The properties that are specific to this file. Each property uses a \"key\" : \"value\" format. Use a comma to separate properties.
   * @type {{ [key: string]: string; }}
   * @memberof FileToPatch
   */
  properties?: { [key: string]: string };
  /**
   * The value for the Content-Disposition header. This is specified in response when downloading the file.
   * @type {string}
   * @memberof FileToPatch
   */
  contentDisposition?: string;
  /**
   * The description of the file resource.
   * @type {string}
   * @memberof FileToPatch
   */
  description?: string;
  /**
   * The type of the file resource.
   * @type {string}
   * @memberof FileToPatch
   */
  documentType?: string;
  /**
   * The name of the file resource.
   * @type {string}
   * @memberof FileToPatch
   */
  name: string;
  /**
   * It indicates if a file is searchable or not.
   * @type {boolean}
   * @memberof FileToPatch
   */
  searchable: boolean;
  /**
   * The type definition name of the file. If the file is associated with a folder and the client does not provide the value of this parameter, the file-service tries to find the best possible value using the type-registry service. If it fails to find a default value, it defaults to \"file\".
   * @type {string}
   * @memberof FileToPatch
   */
  typeDefName?: string;
}
/**
 * INdexable representation of the file.
 * @export
 * @interface IndexableDataElement
 */
export interface IndexableDataElement {
  /**
   * The name of the field.
   * @type {string}
   * @memberof IndexableDataElement
   */
  name?: string;
  /**
   * The value of the field.
   * @type {string}
   * @memberof IndexableDataElement
   */
  value?: string;
}
/**
 * A link to a related operation or resource.
 * @export
 * @interface Link
 */
export interface Link {
  /**
   * The URL for the link.
   * @type {string}
   * @memberof Link
   */
  href?: string;
  /**
   * If this is a link to a container, `itemType` is the media type or link type for the items in the container.
   * @type {string}
   * @memberof Link
   */
  itemType?: string;
  /**
   * The HTTP method for the link.
   * @type {string}
   * @memberof Link
   */
  method?: string;
  /**
   * The relationship of the link to the resource.
   * @type {string}
   * @memberof Link
   */
  rel?: string;
  /**
   * The media type or link type of the items in the response body for a `PUT`, `POST`, or `PATCH` operation.
   * @type {string}
   * @memberof Link
   */
  responseItemType?: string;
  /**
   * The media type or link type of the response body for a `PUT`, `POST`, or `PATCH` operation.
   * @type {string}
   * @memberof Link
   */
  responseType?: string;
  /**
   * The title for the link.
   * @type {string}
   * @memberof Link
   */
  title?: string;
  /**
   * The media type or link type for the link.
   * @type {string}
   * @memberof Link
   */
  type?: string;
  /**
   * The relative URI for the link.
   * @type {string}
   * @memberof Link
   */
  uri?: string;
}
/**
 * File to Patch for quarantine status
 * @export
 * @interface QuarantineFileToPatch
 */
export interface QuarantineFileToPatch {
  /**
   * An indicator that if a file contains vulnerability then the file will be quarantined.
   * @type {boolean}
   * @memberof QuarantineFileToPatch
   */
  quarantine: boolean;
}
/**
 * The schema representation of file service fields to be indexed.
 * @export
 * @interface Schema
 */
export interface Schema {
  /**
   * The collection of schema fields.
   * @type {Array<Field>}
   * @memberof Schema
   */
  fields?: Array<Field>;
  /**
   * The version of the representation.
   * @type {number}
   * @memberof Schema
   */
  version?: number;
}
/**
 * Multiple parentUri values that are specified as an array of string values.
 * @export
 * @interface Selection
 */
export interface Selection {
  /**
   * An array of links to related resources and actions.
   * @type {Array<Link>}
   * @memberof Selection
   */
  links?: Array<Link>;
  /**
   * An array of resource IDs or URIs
   * @type {Array<string>}
   * @memberof Selection
   */
  resources?: Array<string>;
  /**
   * A URI template in which the {id} parameter can be replaced with a value from the \"resources\" array in order to yield the URI of the identified resource.
   * @type {string}
   * @memberof Selection
   */
  template?: string;
  /**
   * Specifies whether the resources array contains IDs, URIs, or both. <dl> <dt>\"id\"</dt><dd>the array contains resource identifiers only. This is the default if \"type\" is omitted.</dd> <dt>\"uri\"</dt><dd>the array contains resource URIs</dd> <dt>\"mixed\"</dt><dd>the array contains a mixture of identifiers and URIs.</dd> </dl>
   * @type {string}
   * @memberof Selection
   */
  type?: SelectionTypeEnum;
  /**
   * The schema version number of this media type. This representation is version 1.
   * @type {number}
   * @memberof Selection
   */
  version?: number;
}

export const SelectionTypeEnum = {
  Id: "id",
  Uri: "uri",
  Mixed: "mixed",
} as const;

export type SelectionTypeEnum =
  (typeof SelectionTypeEnum)[keyof typeof SelectionTypeEnum];

/**
 * The configuration settings exposed for commons usage.
 * @export
 * @interface Settings
 */
export interface Settings {
  /**
   * Version information for this attribute list.
   * @type {number}
   * @memberof Settings
   */
  version: number;
  /**
   * The navigable links relative to this media type.
   * @type {Array<Link>}
   * @memberof Settings
   */
  links: Array<Link>;
  /**
   *
   * @type {AttributesMap}
   * @memberof Settings
   */
  attributes: AttributesMap;
}

/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Copies the file if the user has Read access to the specified file.
     * @summary Copy an existing file
     * @param {string} fileId The identifier of the file resource for which to fetch content.
     * @param {string} [contentDisposition] The content disposition. The previously assigned value can be changed. This indicates whether the content is expected to be displayed inline in a browser (as a web page or part of a web page) or as an attachment that is downloaded and saved locally. If a filename is specified in the header, it is used as the default name of the file.
     * @param {string} [expirationTimeStamp] The date and time at which a file expires. If not specified, the file never expires.
     * @param {string} [parentFolderUri] The URI of the folder in which to add the file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCopyOfFile: async (
      fileId: string,
      contentDisposition?: string,
      expirationTimeStamp?: string,
      parentFolderUri?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'fileId' is not null or undefined
      assertParamExists("createCopyOfFile", "fileId", fileId);
      const localVarPath = `/files/{fileId}/copy`.replace(
        `{${"fileId"}}`,
        encodeURIComponent(String(fileId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (expirationTimeStamp !== undefined) {
        localVarQueryParameter["expirationTimeStamp"] = expirationTimeStamp;
      }

      if (parentFolderUri !== undefined) {
        localVarQueryParameter["parentFolderUri"] = parentFolderUri;
      }

      if (contentDisposition != null) {
        localVarHeaderParameter["Content-Disposition"] =
          String(contentDisposition);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new file resource by passing file content in the request body.
     * @summary Create new file resource
     * @param {string} [contentType] The actual MIME type of the file.
     * @param {string} [contentDisposition] The content disposition. It indicates whether the content is expected to be displayed inline in a browser (as a web page or part of a web page) or as an attachment that is downloaded and saved locally. If a filename is specified in the header, it is used as the default name of the file.
     * @param {string} [expirationTimeStamp] A timestamp that indicates when a file expires. If this is not specified, the file never expires.
     * @param {string} [parentFolderUri] The URI of the folder in which the file should be made a member.
     * @param {string} [searchable] An indicator specifying if a file is searchable or not. Defaulted to \&#39;true\&#39; indicating file is searchable.
     * @param {string} [typeDefName] The type definition name of the file. If the file is associated with a folder and the client does not provide the value of this parameter, the file-service tries to find the best possible value using type-registry service. If it fails to find a default value, it defaults to \&quot;file\&quot;.
     * @param {boolean} [versioned] An indicator specifying if a file is a version control file or not. If set to true, the endpoint will return first version of the file.
     * @param {string} [body] The contents of the file to be passed in raw format in the request body.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewFile: async (
      contentType?: string,
      contentDisposition?: string,
      expirationTimeStamp?: string,
      parentFolderUri?: string,
      searchable?: string,
      typeDefName?: string,
      versioned?: boolean,
      body?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/files#rawUpload`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (expirationTimeStamp !== undefined) {
        localVarQueryParameter["expirationTimeStamp"] = expirationTimeStamp;
      }

      if (parentFolderUri !== undefined) {
        localVarQueryParameter["parentFolderUri"] = parentFolderUri;
      }

      if (searchable !== undefined) {
        localVarQueryParameter["searchable"] = searchable;
      }

      if (typeDefName !== undefined) {
        localVarQueryParameter["typeDefName"] = typeDefName;
      }

      if (versioned !== undefined) {
        localVarQueryParameter["versioned"] = versioned;
      }

      if (contentType != null) {
        localVarHeaderParameter["Content-Type"] = String(contentType);
      }

      if (contentDisposition != null) {
        localVarHeaderParameter["Content-Disposition"] =
          String(contentDisposition);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new file resource by passing a file in the form of a multipart request.
     * @summary Create a new file resource
     * @param {string} [contentType] The MIME type for the multipart request. You must specify \&quot;multipart/form-data; boundary&#x3D;{boundaryString}\&quot;. You can specify the actual MIME type of the file by using Content-Type as form data in the request body.
     * @param {string} [contentDisposition] The content disposition. This indicates whether the content is expected to be displayed inline in a browser (as a web page or part of a web page) or as an attachment that is downloaded and saved locally. If a filename is specified in the header, it is used as the default name of the file.
     * @param {string} [expirationTimeStamp] A timestamp that indicates when a file expires. If it is not specified, the file never expires.
     * @param {string} [parentFolderUri] The URI of the folder in which to add the file.
     * @param {string} [searchable] An indicator specifying if a file is searchable or not. Defaulted to \&#39;true\&#39; indicating file is searchable.
     * @param {string} [typeDefName] The type definition name of the file. If the file is associated with folder and the client does not provide the value of this parameter, the  file-service tries to find the best possible value using type-registry service. If it fails to find a default value, it defaults to \&quot;file\&quot;.
     * @param {boolean} [versioned] An indicator specifying if a file is a version control file or not. If set to true, the endpoint will return first version of the file.
     * @param {boolean} [recoverable] An indicator specifying if a file is recoverable or not.If a user deleted the file then those files can be recovered.There is a certain retention period till which the file will be retained.
     * @param {string} [filename] The name of the file. Clients must specify name of the file as form data in the request body.
     * @param {File} [file] The actual file content. The content should be listed in the format of standard form data in the request body. Only one file is permitted in a multipart request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewFileMultiPart: async (
      contentType?: string,
      contentDisposition?: string,
      expirationTimeStamp?: string,
      parentFolderUri?: string,
      searchable?: string,
      typeDefName?: string,
      versioned?: boolean,
      recoverable?: boolean,
      filename?: string,
      file?: File,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/files#multipartUpload`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)();

      if (expirationTimeStamp !== undefined) {
        localVarQueryParameter["expirationTimeStamp"] = expirationTimeStamp;
      }

      if (parentFolderUri !== undefined) {
        localVarQueryParameter["parentFolderUri"] = parentFolderUri;
      }

      if (searchable !== undefined) {
        localVarQueryParameter["searchable"] = searchable;
      }

      if (typeDefName !== undefined) {
        localVarQueryParameter["typeDefName"] = typeDefName;
      }

      if (versioned !== undefined) {
        localVarQueryParameter["versioned"] = versioned;
      }

      if (recoverable !== undefined) {
        localVarQueryParameter["recoverable"] = recoverable;
      }

      if (contentType != null) {
        localVarHeaderParameter["Content-Type"] = String(contentType);
      }

      if (contentDisposition != null) {
        localVarHeaderParameter["Content-Disposition"] =
          String(contentDisposition);
      }

      if (filename !== undefined) {
        localVarFormParams.append("filename", filename as any);
      }

      if (file !== undefined) {
        localVarFormParams.append("file", file as any);
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes the file resource.
     * @summary Delete a file resource
     * @param {string} fileId The identifier of the file resource to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFileResource: async (
      fileId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'fileId' is not null or undefined
      assertParamExists("deleteFileResource", "fileId", fileId);
      const localVarPath = `/files/{fileId}`.replace(
        `{${"fileId"}}`,
        encodeURIComponent(String(fileId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes file resources for the specified parentUri. If the user is not authorized to delete all matching files, no files are deleted.
     * @summary Delete file resources
     * @param {string} parentUri The parent URI that is associated with the file resources to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFileResourceForGivenParentUri: async (
      parentUri: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'parentUri' is not null or undefined
      assertParamExists(
        "deleteFileResourceForGivenParentUri",
        "parentUri",
        parentUri,
      );
      const localVarPath = `/files`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (parentUri !== undefined) {
        localVarQueryParameter["parentUri"] = parentUri;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the file resources that are associated with multiple parentUri specifications. Request the parentUri values in the body. The returned collection is grouped by parentUri.
     * @summary Get file resources for multiple parentUris
     * @param {Selection} selection Multiple parentUri values that are specified as an array of string values. The file resources that are associated with each parentUri are retrieved.
     * @param {string} [acceptItem] The file resource media type value. If this is not specified, the API returns the latest version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchFilesForParentUris: async (
      selection: Selection,
      acceptItem?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'selection' is not null or undefined
      assertParamExists("fetchFilesForParentUris", "selection", selection);
      const localVarPath = `/files#fetchFilesForMultipleParentUri`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptItem != null) {
        localVarHeaderParameter["Accept-Item"] = String(acceptItem);
      }

      localVarHeaderParameter["Content-Type"] =
        "application/vnd.sas.selection+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        selection,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves a file resource by specifying a fileId.
     * @summary Get a file resource
     * @param {string} fileId The identifier of the file resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFile: async (
      fileId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'fileId' is not null or undefined
      assertParamExists("getFile", "fileId", fileId);
      const localVarPath = `/files/{fileId}`.replace(
        `{${"fileId"}}`,
        encodeURIComponent(String(fileId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves file resources for the specified criteria. Standard paging, filtering, and sorting options are available.
     * @summary Get file resources
     * @param {string} [acceptItem] The file resource media type value. If this is not specified, the API returns the latest version.
     * @param {string} [parentUri] The URI of the associated object or parent object.
     * @param {number} [start] The offset of the first member to return. The default value is 0.
     * @param {number} [limit] The maximum number of members to return. The default value is 10.
     * @param {string} [filter] The filter criteria to apply to the returned member collection.
     * @param {string} [sortBy] The sort criteria  applies to the returned member collection.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileResourceForFilterQuery: async (
      acceptItem?: string,
      parentUri?: string,
      start?: number,
      limit?: number,
      filter?: string,
      sortBy?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/files`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (parentUri !== undefined) {
        localVarQueryParameter["parentUri"] = parentUri;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (filter !== undefined) {
        localVarQueryParameter["filter"] = filter;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter["sortBy"] = sortBy;
      }

      if (acceptItem != null) {
        localVarHeaderParameter["Accept-Item"] = String(acceptItem);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves file resources of all the versions of a given fileId. Standard paging, option is available.
     * @summary Get all the versions of a given file id
     * @param {string} fileId The specific field identifier of the file to return.
     * @param {number} [start] The offset of the first member to return. The default value is 0.
     * @param {number} [limit] The maximum number of members to return. The default value is 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileVersionResourceForFilterQuery: async (
      fileId: string,
      start?: number,
      limit?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'fileId' is not null or undefined
      assertParamExists(
        "getFileVersionResourceForFilterQuery",
        "fileId",
        fileId,
      );
      const localVarPath = `/files/{fileId}/versions`.replace(
        `{${"fileId"}}`,
        encodeURIComponent(String(fileId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the content of the file resource.
     * @summary Get file resource content
     * @param {string} fileId The identifier of the file resource for which to fetch content.
     * @param {boolean} [changeContentDisposition] Specifies whether to use the persisted content-disposition value. If this is specified to true and the word \&quot;attachment\&quot; appears in the content-disposition, it is changed to \&quot;inline\&quot;. No other changes are made to the content-disposition value.
     * @param {string} [ifRange] A conditional range request. The client must specify the previously returned &#x60;ETag&#x60; as the &#x60;If-Range&#x60; header value. This determines whether the resource has been modified. If it has been modified, the entire file is returned. Otherwise, only partial content is returned using the &#x60;Range&#x60; header.
     * @param {string} [range] A specific range request. The value specifies the required byte range--for example, bytes&#x3D;0-100.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getfileContentForGivenId: async (
      fileId: string,
      changeContentDisposition?: boolean,
      ifRange?: string,
      range?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'fileId' is not null or undefined
      assertParamExists("getfileContentForGivenId", "fileId", fileId);
      const localVarPath = `/files/{fileId}/content`.replace(
        `{${"fileId"}}`,
        encodeURIComponent(String(fileId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (changeContentDisposition !== undefined) {
        localVarQueryParameter["changeContentDisposition"] =
          changeContentDisposition;
      }

      if (ifRange != null) {
        localVarHeaderParameter["If-Range"] = String(ifRange);
      }

      if (range != null) {
        localVarHeaderParameter["Range"] = String(range);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the content of the file resource for a specified version.
     * @summary Get the file resource content for a specified version
     * @param {string} fileId The identifier of the file resource for which to fetch content.
     * @param {string} fileVersion The version of the file resource for which to fetch content.
     * @param {boolean} [changeContentDisposition] Specifies whether to use the persisted content-disposition value. If this is specified to true and the word \&quot;attachment\&quot; appears in the content-disposition, it is changed to \&quot;inline\&quot;. No other changes are made to the content-disposition value.
     * @param {string} [ifRange] A conditional range request. The client must specify the previously returned &#x60;ETag&#x60; as the &#x60;If-Range&#x60; header value. This determines whether the resource has been modified. If it has been modified, the entire file is returned. Otherwise, only partial content is returned using the &#x60;Range&#x60; header.
     * @param {string} [range] A specific range request. The value specifies the required byte range--for example, bytes&#x3D;0-100.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getfileContentForGivenVersion: async (
      fileId: string,
      fileVersion: string,
      changeContentDisposition?: boolean,
      ifRange?: string,
      range?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'fileId' is not null or undefined
      assertParamExists("getfileContentForGivenVersion", "fileId", fileId);
      // verify required parameter 'fileVersion' is not null or undefined
      assertParamExists(
        "getfileContentForGivenVersion",
        "fileVersion",
        fileVersion,
      );
      const localVarPath = `/files/{fileId}/version/{fileVersion}/content`
        .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)))
        .replace(`{${"fileVersion"}}`, encodeURIComponent(String(fileVersion)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (changeContentDisposition !== undefined) {
        localVarQueryParameter["changeContentDisposition"] =
          changeContentDisposition;
      }

      if (ifRange != null) {
        localVarHeaderParameter["If-Range"] = String(ifRange);
      }

      if (range != null) {
        localVarHeaderParameter["Range"] = String(range);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves a file resource by specifying fileVersion of a fileId.
     * @summary Get a file resource for specific version
     * @param {string} fileId The identifier of the file resource.
     * @param {number} fileVersion The version of the file resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getfileIdForGivenVersion: async (
      fileId: string,
      fileVersion: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'fileId' is not null or undefined
      assertParamExists("getfileIdForGivenVersion", "fileId", fileId);
      // verify required parameter 'fileVersion' is not null or undefined
      assertParamExists("getfileIdForGivenVersion", "fileVersion", fileVersion);
      const localVarPath = `/files/{fileId}/version/{fileVersion}`
        .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)))
        .replace(`{${"fileVersion"}}`, encodeURIComponent(String(fileVersion)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint returns schema field to be indexed by search service.
     * @summary Get schema for indexing
     * @param {string} [accept] The type specific schema representation media type application/vnd.sas.search.type.schema+json.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getfileindexschema: async (
      accept?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/files#schema`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (accept != null) {
        localVarHeaderParameter["Accept"] = String(accept);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether a file resource exists for the specified fileId.
     * @summary Check if a file resource exists
     * @param {string} fileId The identifier of the file resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForFile: async (
      fileId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'fileId' is not null or undefined
      assertParamExists("headersForFile", "fileId", fileId);
      const localVarPath = `/files/{fileId}`.replace(
        `{${"fileId"}}`,
        encodeURIComponent(String(fileId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determines whether a file resource exists for the specified version of fileId.
     * @summary Check if a file resource exists for given fileVersion
     * @param {string} fileId The identifier of the file resource.
     * @param {number} fileVersion The version of the file resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForfileIdForGivenVersion: async (
      fileId: string,
      fileVersion: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'fileId' is not null or undefined
      assertParamExists("headersForfileIdForGivenVersion", "fileId", fileId);
      // verify required parameter 'fileVersion' is not null or undefined
      assertParamExists(
        "headersForfileIdForGivenVersion",
        "fileVersion",
        fileVersion,
      );
      const localVarPath = `/files/{fileId}/version/{fileVersion}`
        .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)))
        .replace(`{${"fileVersion"}}`, encodeURIComponent(String(fileVersion)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates the file resource information. The user can change these attributes: `name`, `description`, `parentUri`, `documentType`, `contentDisposition`, `properties`, `expirationTimeStamp`,`typeDefName` and `searchable`
     * @summary Update a file resource
     * @param {string} fileId The identifier of the file resource to update.
     * @param {FileToPatch} fileToPatch The file resource to update.
     * @param {string} [ifMatch] The entity tag that was obtained from the most recent &#x60;ETag&#x60; response header.
     * @param {string} [ifUnmodifiedSince] The timestamp that was obtained from the most recent &#x60;Last-Modified&#x60; response header. This is ignored when &#x60;If-Match&#x60; is specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchFileResourceInfo: async (
      fileId: string,
      fileToPatch: FileToPatch,
      ifMatch?: string,
      ifUnmodifiedSince?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'fileId' is not null or undefined
      assertParamExists("patchFileResourceInfo", "fileId", fileId);
      // verify required parameter 'fileToPatch' is not null or undefined
      assertParamExists("patchFileResourceInfo", "fileToPatch", fileToPatch);
      const localVarPath = `/files/{fileId}`.replace(
        `{${"fileId"}}`,
        encodeURIComponent(String(fileId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (ifMatch != null) {
        localVarHeaderParameter["If-Match"] = String(ifMatch);
      }

      if (ifUnmodifiedSince != null) {
        localVarHeaderParameter["If-Unmodified-Since"] =
          String(ifUnmodifiedSince);
      }

      localVarHeaderParameter["Content-Type"] = "application/vnd.sas.file+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        fileToPatch,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates the file resource information. The user can change these attributes: `name`, `description`, `parentUri`, `documentType`, `contentDisposition`, `properties`,`expirationTimeStamp`,`typeDefName` and `searchable`
     * @summary Update a file resource
     * @param {string} fileId The identifier of the file resource to update.
     * @param {FileToPatch} fileToPatch The file resource to update.
     * @param {string} [ifMatch] The entity tag that was obtained from the most recent &#x60;ETag&#x60; response header.
     * @param {string} [ifUnmodifiedSince] The timestamp that was obtained from the most recent &#x60;Last-Modified&#x60; response header. This is ignored when &#x60;If-Match&#x60; is specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFileResource: async (
      fileId: string,
      fileToPatch: FileToPatch,
      ifMatch?: string,
      ifUnmodifiedSince?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'fileId' is not null or undefined
      assertParamExists("updateFileResource", "fileId", fileId);
      // verify required parameter 'fileToPatch' is not null or undefined
      assertParamExists("updateFileResource", "fileToPatch", fileToPatch);
      const localVarPath = `/files/{fileId}`.replace(
        `{${"fileId"}}`,
        encodeURIComponent(String(fileId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (ifMatch != null) {
        localVarHeaderParameter["If-Match"] = String(ifMatch);
      }

      if (ifUnmodifiedSince != null) {
        localVarHeaderParameter["If-Unmodified-Since"] =
          String(ifUnmodifiedSince);
      }

      localVarHeaderParameter["Content-Type"] = "application/vnd.sas.file+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        fileToPatch,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates the content of the file resource.
     * @summary Update file resource content
     * @param {string} fileId The identifier of the file resource for which to fetch content.
     * @param {string} contentType The content type. Specify this as \&quot;multipart/form-data\&quot; if you are using a multipart request, or specify the actual MIME type of the file if the request is a raw data upload.
     * @param {File} file The file data. If you are using a raw data upload request, the request body should contain only the file data (the actual file content). If you are using a multipart request, the request body should be in multipart or form-data format, where the file data is listed as &#x60;file&#x60; in the form data. Only one file is permitted in a multipart request.
     * @param {string} [ifMatch] The entity tag that was obtained from the most recent &#x60;ETag&#x60; response header.
     * @param {string} [ifUnmodifiedSince] The timestamp that was obtained from the most recent &#x60;Last-Modified&#x60; response header. This is ignored when &#x60;If-Match&#x60; is specified.
     * @param {string} [contentDisposition] The content disposition. The previously assigned value can be changed. This indicates whether the content is expected to be displayed inline in a browser (as a web page or part of a web page) or as an attachment that is downloaded and saved locally. If a filename is specified in the header, it is used as the default name of the file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatedFileContent: async (
      fileId: string,
      contentType: string,
      file: File,
      ifMatch?: string,
      ifUnmodifiedSince?: string,
      contentDisposition?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'fileId' is not null or undefined
      assertParamExists("updatedFileContent", "fileId", fileId);
      // verify required parameter 'contentType' is not null or undefined
      assertParamExists("updatedFileContent", "contentType", contentType);
      // verify required parameter 'file' is not null or undefined
      assertParamExists("updatedFileContent", "file", file);
      const localVarPath = `/files/{fileId}/content`.replace(
        `{${"fileId"}}`,
        encodeURIComponent(String(fileId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)();

      if (ifMatch != null) {
        localVarHeaderParameter["If-Match"] = String(ifMatch);
      }

      if (ifUnmodifiedSince != null) {
        localVarHeaderParameter["If-Unmodified-Since"] =
          String(ifUnmodifiedSince);
      }

      if (contentType != null) {
        localVarHeaderParameter["Content-Type"] = String(contentType);
      }

      if (contentDisposition != null) {
        localVarHeaderParameter["Content-Disposition"] =
          String(contentDisposition);
      }

      if (file !== undefined) {
        localVarFormParams.append("file", file as any);
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApi = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration);
  return {
    /**
     * Copies the file if the user has Read access to the specified file.
     * @summary Copy an existing file
     * @param {FilesApiCreateCopyOfFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createCopyOfFile(
      requestParameters: FilesApiCreateCopyOfFileRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<FileResource>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createCopyOfFile(
          requestParameters.fileId,
          requestParameters.contentDisposition,
          requestParameters.expirationTimeStamp,
          requestParameters.parentFolderUri,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Creates a new file resource by passing file content in the request body.
     * @summary Create new file resource
     * @param {FilesApiCreateNewFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createNewFile(
      requestParameters: FilesApiCreateNewFileRequest = {},
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<FileResource>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createNewFile(
        requestParameters.contentType,
        requestParameters.contentDisposition,
        requestParameters.expirationTimeStamp,
        requestParameters.parentFolderUri,
        requestParameters.searchable,
        requestParameters.typeDefName,
        requestParameters.versioned,
        requestParameters.body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Creates a new file resource by passing a file in the form of a multipart request.
     * @summary Create a new file resource
     * @param {FilesApiCreateNewFileMultiPartRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createNewFileMultiPart(
      requestParameters: FilesApiCreateNewFileMultiPartRequest = {},
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<FileResource>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createNewFileMultiPart(
          requestParameters.contentType,
          requestParameters.contentDisposition,
          requestParameters.expirationTimeStamp,
          requestParameters.parentFolderUri,
          requestParameters.searchable,
          requestParameters.typeDefName,
          requestParameters.versioned,
          requestParameters.recoverable,
          requestParameters.filename,
          requestParameters.file,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Deletes the file resource.
     * @summary Delete a file resource
     * @param {FilesApiDeleteFileResourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFileResource(
      requestParameters: FilesApiDeleteFileResourceRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteFileResource(
          requestParameters.fileId,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Deletes file resources for the specified parentUri. If the user is not authorized to delete all matching files, no files are deleted.
     * @summary Delete file resources
     * @param {FilesApiDeleteFileResourceForGivenParentUriRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFileResourceForGivenParentUri(
      requestParameters: FilesApiDeleteFileResourceForGivenParentUriRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteFileResourceForGivenParentUri(
          requestParameters.parentUri,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Retrieves the file resources that are associated with multiple parentUri specifications. Request the parentUri values in the body. The returned collection is grouped by parentUri.
     * @summary Get file resources for multiple parentUris
     * @param {FilesApiFetchFilesForParentUrisRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fetchFilesForParentUris(
      requestParameters: FilesApiFetchFilesForParentUrisRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<FileResourceCollection>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.fetchFilesForParentUris(
          requestParameters.selection,
          requestParameters.acceptItem,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Retrieves a file resource by specifying a fileId.
     * @summary Get a file resource
     * @param {FilesApiGetFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFile(
      requestParameters: FilesApiGetFileRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<FileResource>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFile(
        requestParameters.fileId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Retrieves file resources for the specified criteria. Standard paging, filtering, and sorting options are available.
     * @summary Get file resources
     * @param {FilesApiGetFileResourceForFilterQueryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFileResourceForFilterQuery(
      requestParameters: FilesApiGetFileResourceForFilterQueryRequest = {},
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<FileResourceCollection>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getFileResourceForFilterQuery(
          requestParameters.acceptItem,
          requestParameters.parentUri,
          requestParameters.start,
          requestParameters.limit,
          requestParameters.filter,
          requestParameters.sortBy,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Retrieves file resources of all the versions of a given fileId. Standard paging, option is available.
     * @summary Get all the versions of a given file id
     * @param {FilesApiGetFileVersionResourceForFilterQueryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFileVersionResourceForFilterQuery(
      requestParameters: FilesApiGetFileVersionResourceForFilterQueryRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<FileResourceCollection>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getFileVersionResourceForFilterQuery(
          requestParameters.fileId,
          requestParameters.start,
          requestParameters.limit,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Retrieves the content of the file resource.
     * @summary Get file resource content
     * @param {FilesApiGetfileContentForGivenIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getfileContentForGivenId(
      requestParameters: FilesApiGetfileContentForGivenIdRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getfileContentForGivenId(
          requestParameters.fileId,
          requestParameters.changeContentDisposition,
          requestParameters.ifRange,
          requestParameters.range,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Retrieves the content of the file resource for a specified version.
     * @summary Get the file resource content for a specified version
     * @param {FilesApiGetfileContentForGivenVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getfileContentForGivenVersion(
      requestParameters: FilesApiGetfileContentForGivenVersionRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getfileContentForGivenVersion(
          requestParameters.fileId,
          requestParameters.fileVersion,
          requestParameters.changeContentDisposition,
          requestParameters.ifRange,
          requestParameters.range,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Retrieves a file resource by specifying fileVersion of a fileId.
     * @summary Get a file resource for specific version
     * @param {FilesApiGetfileIdForGivenVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getfileIdForGivenVersion(
      requestParameters: FilesApiGetfileIdForGivenVersionRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<FileResource>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getfileIdForGivenVersion(
          requestParameters.fileId,
          requestParameters.fileVersion,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * This endpoint returns schema field to be indexed by search service.
     * @summary Get schema for indexing
     * @param {FilesApiGetfileindexschemaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getfileindexschema(
      requestParameters: FilesApiGetfileindexschemaRequest = {},
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Schema>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getfileindexschema(
          requestParameters.accept,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether a file resource exists for the specified fileId.
     * @summary Check if a file resource exists
     * @param {FilesApiHeadersForFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForFile(
      requestParameters: FilesApiHeadersForFileRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.headersForFile(
        requestParameters.fileId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Determines whether a file resource exists for the specified version of fileId.
     * @summary Check if a file resource exists for given fileVersion
     * @param {FilesApiHeadersForfileIdForGivenVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForfileIdForGivenVersion(
      requestParameters: FilesApiHeadersForfileIdForGivenVersionRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForfileIdForGivenVersion(
          requestParameters.fileId,
          requestParameters.fileVersion,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Updates the file resource information. The user can change these attributes: `name`, `description`, `parentUri`, `documentType`, `contentDisposition`, `properties`, `expirationTimeStamp`,`typeDefName` and `searchable`
     * @summary Update a file resource
     * @param {FilesApiPatchFileResourceInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchFileResourceInfo(
      requestParameters: FilesApiPatchFileResourceInfoRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<FileResource>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.patchFileResourceInfo(
          requestParameters.fileId,
          requestParameters.fileToPatch,
          requestParameters.ifMatch,
          requestParameters.ifUnmodifiedSince,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Updates the file resource information. The user can change these attributes: `name`, `description`, `parentUri`, `documentType`, `contentDisposition`, `properties`,`expirationTimeStamp`,`typeDefName` and `searchable`
     * @summary Update a file resource
     * @param {FilesApiUpdateFileResourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateFileResource(
      requestParameters: FilesApiUpdateFileResourceRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<FileResource>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateFileResource(
          requestParameters.fileId,
          requestParameters.fileToPatch,
          requestParameters.ifMatch,
          requestParameters.ifUnmodifiedSince,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Updates the content of the file resource.
     * @summary Update file resource content
     * @param {FilesApiUpdatedFileContentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatedFileContent(
      requestParameters: FilesApiUpdatedFileContentRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<FileResource>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updatedFileContent(
          requestParameters.fileId,
          requestParameters.contentType,
          requestParameters.file,
          requestParameters.ifMatch,
          requestParameters.ifUnmodifiedSince,
          requestParameters.contentDisposition,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },
  };
};

/**
 * Request parameters for createCopyOfFile operation in FilesApi.
 * @export
 * @interface FilesApiCreateCopyOfFileRequest
 */
export interface FilesApiCreateCopyOfFileRequest {
  /**
   * The identifier of the file resource for which to fetch content.
   * @type {string}
   * @memberof FilesApiCreateCopyOfFile
   */
  readonly fileId: string;

  /**
   * The content disposition. The previously assigned value can be changed. This indicates whether the content is expected to be displayed inline in a browser (as a web page or part of a web page) or as an attachment that is downloaded and saved locally. If a filename is specified in the header, it is used as the default name of the file.
   * @type {string}
   * @memberof FilesApiCreateCopyOfFile
   */
  readonly contentDisposition?: string;

  /**
   * The date and time at which a file expires. If not specified, the file never expires.
   * @type {string}
   * @memberof FilesApiCreateCopyOfFile
   */
  readonly expirationTimeStamp?: string;

  /**
   * The URI of the folder in which to add the file.
   * @type {string}
   * @memberof FilesApiCreateCopyOfFile
   */
  readonly parentFolderUri?: string;
}

/**
 * Request parameters for createNewFile operation in FilesApi.
 * @export
 * @interface FilesApiCreateNewFileRequest
 */
export interface FilesApiCreateNewFileRequest {
  /**
   * The actual MIME type of the file.
   * @type {string}
   * @memberof FilesApiCreateNewFile
   */
  readonly contentType?: string;

  /**
   * The content disposition. It indicates whether the content is expected to be displayed inline in a browser (as a web page or part of a web page) or as an attachment that is downloaded and saved locally. If a filename is specified in the header, it is used as the default name of the file.
   * @type {string}
   * @memberof FilesApiCreateNewFile
   */
  readonly contentDisposition?: string;

  /**
   * A timestamp that indicates when a file expires. If this is not specified, the file never expires.
   * @type {string}
   * @memberof FilesApiCreateNewFile
   */
  readonly expirationTimeStamp?: string;

  /**
   * The URI of the folder in which the file should be made a member.
   * @type {string}
   * @memberof FilesApiCreateNewFile
   */
  readonly parentFolderUri?: string;

  /**
   * An indicator specifying if a file is searchable or not. Defaulted to \&#39;true\&#39; indicating file is searchable.
   * @type {string}
   * @memberof FilesApiCreateNewFile
   */
  readonly searchable?: string;

  /**
   * The type definition name of the file. If the file is associated with a folder and the client does not provide the value of this parameter, the file-service tries to find the best possible value using type-registry service. If it fails to find a default value, it defaults to \&quot;file\&quot;.
   * @type {string}
   * @memberof FilesApiCreateNewFile
   */
  readonly typeDefName?: string;

  /**
   * An indicator specifying if a file is a version control file or not. If set to true, the endpoint will return first version of the file.
   * @type {boolean}
   * @memberof FilesApiCreateNewFile
   */
  readonly versioned?: boolean;

  /**
   * The contents of the file to be passed in raw format in the request body.
   * @type {string}
   * @memberof FilesApiCreateNewFile
   */
  readonly body?: string;
}

/**
 * Request parameters for createNewFileMultiPart operation in FilesApi.
 * @export
 * @interface FilesApiCreateNewFileMultiPartRequest
 */
export interface FilesApiCreateNewFileMultiPartRequest {
  /**
   * The MIME type for the multipart request. You must specify \&quot;multipart/form-data; boundary&#x3D;{boundaryString}\&quot;. You can specify the actual MIME type of the file by using Content-Type as form data in the request body.
   * @type {string}
   * @memberof FilesApiCreateNewFileMultiPart
   */
  readonly contentType?: string;

  /**
   * The content disposition. This indicates whether the content is expected to be displayed inline in a browser (as a web page or part of a web page) or as an attachment that is downloaded and saved locally. If a filename is specified in the header, it is used as the default name of the file.
   * @type {string}
   * @memberof FilesApiCreateNewFileMultiPart
   */
  readonly contentDisposition?: string;

  /**
   * A timestamp that indicates when a file expires. If it is not specified, the file never expires.
   * @type {string}
   * @memberof FilesApiCreateNewFileMultiPart
   */
  readonly expirationTimeStamp?: string;

  /**
   * The URI of the folder in which to add the file.
   * @type {string}
   * @memberof FilesApiCreateNewFileMultiPart
   */
  readonly parentFolderUri?: string;

  /**
   * An indicator specifying if a file is searchable or not. Defaulted to \&#39;true\&#39; indicating file is searchable.
   * @type {string}
   * @memberof FilesApiCreateNewFileMultiPart
   */
  readonly searchable?: string;

  /**
   * The type definition name of the file. If the file is associated with folder and the client does not provide the value of this parameter, the  file-service tries to find the best possible value using type-registry service. If it fails to find a default value, it defaults to \&quot;file\&quot;.
   * @type {string}
   * @memberof FilesApiCreateNewFileMultiPart
   */
  readonly typeDefName?: string;

  /**
   * An indicator specifying if a file is a version control file or not. If set to true, the endpoint will return first version of the file.
   * @type {boolean}
   * @memberof FilesApiCreateNewFileMultiPart
   */
  readonly versioned?: boolean;

  /**
   * An indicator specifying if a file is recoverable or not.If a user deleted the file then those files can be recovered.There is a certain retention period till which the file will be retained.
   * @type {boolean}
   * @memberof FilesApiCreateNewFileMultiPart
   */
  readonly recoverable?: boolean;

  /**
   * The name of the file. Clients must specify name of the file as form data in the request body.
   * @type {string}
   * @memberof FilesApiCreateNewFileMultiPart
   */
  readonly filename?: string;

  /**
   * The actual file content. The content should be listed in the format of standard form data in the request body. Only one file is permitted in a multipart request.
   * @type {File}
   * @memberof FilesApiCreateNewFileMultiPart
   */
  readonly file?: File;
}

/**
 * Request parameters for deleteFileResource operation in FilesApi.
 * @export
 * @interface FilesApiDeleteFileResourceRequest
 */
export interface FilesApiDeleteFileResourceRequest {
  /**
   * The identifier of the file resource to delete.
   * @type {string}
   * @memberof FilesApiDeleteFileResource
   */
  readonly fileId: string;
}

/**
 * Request parameters for deleteFileResourceForGivenParentUri operation in FilesApi.
 * @export
 * @interface FilesApiDeleteFileResourceForGivenParentUriRequest
 */
export interface FilesApiDeleteFileResourceForGivenParentUriRequest {
  /**
   * The parent URI that is associated with the file resources to be deleted.
   * @type {string}
   * @memberof FilesApiDeleteFileResourceForGivenParentUri
   */
  readonly parentUri: string;
}

/**
 * Request parameters for fetchFilesForParentUris operation in FilesApi.
 * @export
 * @interface FilesApiFetchFilesForParentUrisRequest
 */
export interface FilesApiFetchFilesForParentUrisRequest {
  /**
   * Multiple parentUri values that are specified as an array of string values. The file resources that are associated with each parentUri are retrieved.
   * @type {Selection}
   * @memberof FilesApiFetchFilesForParentUris
   */
  readonly selection: Selection;

  /**
   * The file resource media type value. If this is not specified, the API returns the latest version.
   * @type {string}
   * @memberof FilesApiFetchFilesForParentUris
   */
  readonly acceptItem?: string;
}

/**
 * Request parameters for getFile operation in FilesApi.
 * @export
 * @interface FilesApiGetFileRequest
 */
export interface FilesApiGetFileRequest {
  /**
   * The identifier of the file resource.
   * @type {string}
   * @memberof FilesApiGetFile
   */
  readonly fileId: string;
}

/**
 * Request parameters for getFileResourceForFilterQuery operation in FilesApi.
 * @export
 * @interface FilesApiGetFileResourceForFilterQueryRequest
 */
export interface FilesApiGetFileResourceForFilterQueryRequest {
  /**
   * The file resource media type value. If this is not specified, the API returns the latest version.
   * @type {string}
   * @memberof FilesApiGetFileResourceForFilterQuery
   */
  readonly acceptItem?: string;

  /**
   * The URI of the associated object or parent object.
   * @type {string}
   * @memberof FilesApiGetFileResourceForFilterQuery
   */
  readonly parentUri?: string;

  /**
   * The offset of the first member to return. The default value is 0.
   * @type {number}
   * @memberof FilesApiGetFileResourceForFilterQuery
   */
  readonly start?: number;

  /**
   * The maximum number of members to return. The default value is 10.
   * @type {number}
   * @memberof FilesApiGetFileResourceForFilterQuery
   */
  readonly limit?: number;

  /**
   * The filter criteria to apply to the returned member collection.
   * @type {string}
   * @memberof FilesApiGetFileResourceForFilterQuery
   */
  readonly filter?: string;

  /**
   * The sort criteria  applies to the returned member collection.
   * @type {string}
   * @memberof FilesApiGetFileResourceForFilterQuery
   */
  readonly sortBy?: string;
}

/**
 * Request parameters for getFileVersionResourceForFilterQuery operation in FilesApi.
 * @export
 * @interface FilesApiGetFileVersionResourceForFilterQueryRequest
 */
export interface FilesApiGetFileVersionResourceForFilterQueryRequest {
  /**
   * The specific field identifier of the file to return.
   * @type {string}
   * @memberof FilesApiGetFileVersionResourceForFilterQuery
   */
  readonly fileId: string;

  /**
   * The offset of the first member to return. The default value is 0.
   * @type {number}
   * @memberof FilesApiGetFileVersionResourceForFilterQuery
   */
  readonly start?: number;

  /**
   * The maximum number of members to return. The default value is 10.
   * @type {number}
   * @memberof FilesApiGetFileVersionResourceForFilterQuery
   */
  readonly limit?: number;
}

/**
 * Request parameters for getfileContentForGivenId operation in FilesApi.
 * @export
 * @interface FilesApiGetfileContentForGivenIdRequest
 */
export interface FilesApiGetfileContentForGivenIdRequest {
  /**
   * The identifier of the file resource for which to fetch content.
   * @type {string}
   * @memberof FilesApiGetfileContentForGivenId
   */
  readonly fileId: string;

  /**
   * Specifies whether to use the persisted content-disposition value. If this is specified to true and the word \&quot;attachment\&quot; appears in the content-disposition, it is changed to \&quot;inline\&quot;. No other changes are made to the content-disposition value.
   * @type {boolean}
   * @memberof FilesApiGetfileContentForGivenId
   */
  readonly changeContentDisposition?: boolean;

  /**
   * A conditional range request. The client must specify the previously returned &#x60;ETag&#x60; as the &#x60;If-Range&#x60; header value. This determines whether the resource has been modified. If it has been modified, the entire file is returned. Otherwise, only partial content is returned using the &#x60;Range&#x60; header.
   * @type {string}
   * @memberof FilesApiGetfileContentForGivenId
   */
  readonly ifRange?: string;

  /**
   * A specific range request. The value specifies the required byte range--for example, bytes&#x3D;0-100.
   * @type {string}
   * @memberof FilesApiGetfileContentForGivenId
   */
  readonly range?: string;
}

/**
 * Request parameters for getfileContentForGivenVersion operation in FilesApi.
 * @export
 * @interface FilesApiGetfileContentForGivenVersionRequest
 */
export interface FilesApiGetfileContentForGivenVersionRequest {
  /**
   * The identifier of the file resource for which to fetch content.
   * @type {string}
   * @memberof FilesApiGetfileContentForGivenVersion
   */
  readonly fileId: string;

  /**
   * The version of the file resource for which to fetch content.
   * @type {string}
   * @memberof FilesApiGetfileContentForGivenVersion
   */
  readonly fileVersion: string;

  /**
   * Specifies whether to use the persisted content-disposition value. If this is specified to true and the word \&quot;attachment\&quot; appears in the content-disposition, it is changed to \&quot;inline\&quot;. No other changes are made to the content-disposition value.
   * @type {boolean}
   * @memberof FilesApiGetfileContentForGivenVersion
   */
  readonly changeContentDisposition?: boolean;

  /**
   * A conditional range request. The client must specify the previously returned &#x60;ETag&#x60; as the &#x60;If-Range&#x60; header value. This determines whether the resource has been modified. If it has been modified, the entire file is returned. Otherwise, only partial content is returned using the &#x60;Range&#x60; header.
   * @type {string}
   * @memberof FilesApiGetfileContentForGivenVersion
   */
  readonly ifRange?: string;

  /**
   * A specific range request. The value specifies the required byte range--for example, bytes&#x3D;0-100.
   * @type {string}
   * @memberof FilesApiGetfileContentForGivenVersion
   */
  readonly range?: string;
}

/**
 * Request parameters for getfileIdForGivenVersion operation in FilesApi.
 * @export
 * @interface FilesApiGetfileIdForGivenVersionRequest
 */
export interface FilesApiGetfileIdForGivenVersionRequest {
  /**
   * The identifier of the file resource.
   * @type {string}
   * @memberof FilesApiGetfileIdForGivenVersion
   */
  readonly fileId: string;

  /**
   * The version of the file resource.
   * @type {number}
   * @memberof FilesApiGetfileIdForGivenVersion
   */
  readonly fileVersion: number;
}

/**
 * Request parameters for getfileindexschema operation in FilesApi.
 * @export
 * @interface FilesApiGetfileindexschemaRequest
 */
export interface FilesApiGetfileindexschemaRequest {
  /**
   * The type specific schema representation media type application/vnd.sas.search.type.schema+json.
   * @type {string}
   * @memberof FilesApiGetfileindexschema
   */
  readonly accept?: string;
}

/**
 * Request parameters for headersForFile operation in FilesApi.
 * @export
 * @interface FilesApiHeadersForFileRequest
 */
export interface FilesApiHeadersForFileRequest {
  /**
   * The identifier of the file resource.
   * @type {string}
   * @memberof FilesApiHeadersForFile
   */
  readonly fileId: string;
}

/**
 * Request parameters for headersForfileIdForGivenVersion operation in FilesApi.
 * @export
 * @interface FilesApiHeadersForfileIdForGivenVersionRequest
 */
export interface FilesApiHeadersForfileIdForGivenVersionRequest {
  /**
   * The identifier of the file resource.
   * @type {string}
   * @memberof FilesApiHeadersForfileIdForGivenVersion
   */
  readonly fileId: string;

  /**
   * The version of the file resource.
   * @type {number}
   * @memberof FilesApiHeadersForfileIdForGivenVersion
   */
  readonly fileVersion: number;
}

/**
 * Request parameters for patchFileResourceInfo operation in FilesApi.
 * @export
 * @interface FilesApiPatchFileResourceInfoRequest
 */
export interface FilesApiPatchFileResourceInfoRequest {
  /**
   * The identifier of the file resource to update.
   * @type {string}
   * @memberof FilesApiPatchFileResourceInfo
   */
  readonly fileId: string;

  /**
   * The file resource to update.
   * @type {FileToPatch}
   * @memberof FilesApiPatchFileResourceInfo
   */
  readonly fileToPatch: FileToPatch;

  /**
   * The entity tag that was obtained from the most recent &#x60;ETag&#x60; response header.
   * @type {string}
   * @memberof FilesApiPatchFileResourceInfo
   */
  readonly ifMatch?: string;

  /**
   * The timestamp that was obtained from the most recent &#x60;Last-Modified&#x60; response header. This is ignored when &#x60;If-Match&#x60; is specified.
   * @type {string}
   * @memberof FilesApiPatchFileResourceInfo
   */
  readonly ifUnmodifiedSince?: string;
}

/**
 * Request parameters for updateFileResource operation in FilesApi.
 * @export
 * @interface FilesApiUpdateFileResourceRequest
 */
export interface FilesApiUpdateFileResourceRequest {
  /**
   * The identifier of the file resource to update.
   * @type {string}
   * @memberof FilesApiUpdateFileResource
   */
  readonly fileId: string;

  /**
   * The file resource to update.
   * @type {FileToPatch}
   * @memberof FilesApiUpdateFileResource
   */
  readonly fileToPatch: FileToPatch;

  /**
   * The entity tag that was obtained from the most recent &#x60;ETag&#x60; response header.
   * @type {string}
   * @memberof FilesApiUpdateFileResource
   */
  readonly ifMatch?: string;

  /**
   * The timestamp that was obtained from the most recent &#x60;Last-Modified&#x60; response header. This is ignored when &#x60;If-Match&#x60; is specified.
   * @type {string}
   * @memberof FilesApiUpdateFileResource
   */
  readonly ifUnmodifiedSince?: string;
}

/**
 * Request parameters for updatedFileContent operation in FilesApi.
 * @export
 * @interface FilesApiUpdatedFileContentRequest
 */
export interface FilesApiUpdatedFileContentRequest {
  /**
   * The identifier of the file resource for which to fetch content.
   * @type {string}
   * @memberof FilesApiUpdatedFileContent
   */
  readonly fileId: string;

  /**
   * The content type. Specify this as \&quot;multipart/form-data\&quot; if you are using a multipart request, or specify the actual MIME type of the file if the request is a raw data upload.
   * @type {string}
   * @memberof FilesApiUpdatedFileContent
   */
  readonly contentType: string;

  /**
   * The file data. If you are using a raw data upload request, the request body should contain only the file data (the actual file content). If you are using a multipart request, the request body should be in multipart or form-data format, where the file data is listed as &#x60;file&#x60; in the form data. Only one file is permitted in a multipart request.
   * @type {File}
   * @memberof FilesApiUpdatedFileContent
   */
  readonly file: File;

  /**
   * The entity tag that was obtained from the most recent &#x60;ETag&#x60; response header.
   * @type {string}
   * @memberof FilesApiUpdatedFileContent
   */
  readonly ifMatch?: string;

  /**
   * The timestamp that was obtained from the most recent &#x60;Last-Modified&#x60; response header. This is ignored when &#x60;If-Match&#x60; is specified.
   * @type {string}
   * @memberof FilesApiUpdatedFileContent
   */
  readonly ifUnmodifiedSince?: string;

  /**
   * The content disposition. The previously assigned value can be changed. This indicates whether the content is expected to be displayed inline in a browser (as a web page or part of a web page) or as an attachment that is downloaded and saved locally. If a filename is specified in the header, it is used as the default name of the file.
   * @type {string}
   * @memberof FilesApiUpdatedFileContent
   */
  readonly contentDisposition?: string;
}

/**
 * IndexApi - axios parameter creator
 * @export
 */
export const IndexApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Retrieves indexable representations of files that are associated with multiple parentUri specifications. Request the parentUri values in the body. The returned collection is grouped by parentUri.
     * @summary Get indexable representations for parentUris
     * @param {string} acceptItem The value of the file resource media type. You must specify this as \&quot;application/vnd.sas.search.indexable.data\&quot;.
     * @param {Selection} selection Multiple parentUri values that are specified as an array of string values. The file resources that are associated with each parentUri are retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchFilesIndexableRepForParentUris: async (
      acceptItem: string,
      selection: Selection,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'acceptItem' is not null or undefined
      assertParamExists(
        "fetchFilesIndexableRepForParentUris",
        "acceptItem",
        acceptItem,
      );
      // verify required parameter 'selection' is not null or undefined
      assertParamExists(
        "fetchFilesIndexableRepForParentUris",
        "selection",
        selection,
      );
      const localVarPath = `/files#fetchIndexableRepresentationCollection`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptItem != null) {
        localVarHeaderParameter["Accept-Item"] = String(acceptItem);
      }

      localVarHeaderParameter["Content-Type"] =
        "application/vnd.sas.selection+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        selection,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves a generic indexable representation of file for the specified identifier.
     * @summary Get a generic indexable representation
     * @param {string} fileId The identifier of the file resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileIndexableRep: async (
      fileId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'fileId' is not null or undefined
      assertParamExists("getFileIndexableRep", "fileId", fileId);
      const localVarPath = `/files/{fileId}#getIndexableRepresentation`.replace(
        `{${"fileId"}}`,
        encodeURIComponent(String(fileId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves indexable representations of file resources for the specified criteria. Standard paging, filtering, and sorting options are available.
     * @summary Get indexable representations for files
     * @param {string} acceptItem The value of the file resource media type. You must specify this as \&quot;application/vnd.sas.search.indexable.data\&quot;.
     * @param {string} [parentUri] The URI of the associated object or parent object.
     * @param {number} [start] The offset of the first member to return. The default is 0.
     * @param {number} [limit] The maximum number of members to return. The default value is 10.
     * @param {string} [filter] The filter criteria to apply to the returned member collection.
     * @param {string} [sortBy] The sort criteria to apply to the returned member collection.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFilesIndexableResource: async (
      acceptItem: string,
      parentUri?: string,
      start?: number,
      limit?: number,
      filter?: string,
      sortBy?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'acceptItem' is not null or undefined
      assertParamExists("getFilesIndexableResource", "acceptItem", acceptItem);
      const localVarPath = `/files#getIndexableRepresentationCollection`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (parentUri !== undefined) {
        localVarQueryParameter["parentUri"] = parentUri;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (filter !== undefined) {
        localVarQueryParameter["filter"] = filter;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter["sortBy"] = sortBy;
      }

      if (acceptItem != null) {
        localVarHeaderParameter["Accept-Item"] = String(acceptItem);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * IndexApi - functional programming interface
 * @export
 */
export const IndexApi = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = IndexApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieves indexable representations of files that are associated with multiple parentUri specifications. Request the parentUri values in the body. The returned collection is grouped by parentUri.
     * @summary Get indexable representations for parentUris
     * @param {IndexApiFetchFilesIndexableRepForParentUrisRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fetchFilesIndexableRepForParentUris(
      requestParameters: IndexApiFetchFilesIndexableRepForParentUrisRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<FileResourceCollection>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.fetchFilesIndexableRepForParentUris(
          requestParameters.acceptItem,
          requestParameters.selection,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Retrieves a generic indexable representation of file for the specified identifier.
     * @summary Get a generic indexable representation
     * @param {IndexApiGetFileIndexableRepRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFileIndexableRep(
      requestParameters: IndexApiGetFileIndexableRepRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<FileResourceIndex>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getFileIndexableRep(
          requestParameters.fileId,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Retrieves indexable representations of file resources for the specified criteria. Standard paging, filtering, and sorting options are available.
     * @summary Get indexable representations for files
     * @param {IndexApiGetFilesIndexableResourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFilesIndexableResource(
      requestParameters: IndexApiGetFilesIndexableResourceRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<FileResourceIndexCollection>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getFilesIndexableResource(
          requestParameters.acceptItem,
          requestParameters.parentUri,
          requestParameters.start,
          requestParameters.limit,
          requestParameters.filter,
          requestParameters.sortBy,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },
  };
};

/**
 * Request parameters for fetchFilesIndexableRepForParentUris operation in IndexApi.
 * @export
 * @interface IndexApiFetchFilesIndexableRepForParentUrisRequest
 */
export interface IndexApiFetchFilesIndexableRepForParentUrisRequest {
  /**
   * The value of the file resource media type. You must specify this as \&quot;application/vnd.sas.search.indexable.data\&quot;.
   * @type {string}
   * @memberof IndexApiFetchFilesIndexableRepForParentUris
   */
  readonly acceptItem: string;

  /**
   * Multiple parentUri values that are specified as an array of string values. The file resources that are associated with each parentUri are retrieved.
   * @type {Selection}
   * @memberof IndexApiFetchFilesIndexableRepForParentUris
   */
  readonly selection: Selection;
}

/**
 * Request parameters for getFileIndexableRep operation in IndexApi.
 * @export
 * @interface IndexApiGetFileIndexableRepRequest
 */
export interface IndexApiGetFileIndexableRepRequest {
  /**
   * The identifier of the file resource.
   * @type {string}
   * @memberof IndexApiGetFileIndexableRep
   */
  readonly fileId: string;
}

/**
 * Request parameters for getFilesIndexableResource operation in IndexApi.
 * @export
 * @interface IndexApiGetFilesIndexableResourceRequest
 */
export interface IndexApiGetFilesIndexableResourceRequest {
  /**
   * The value of the file resource media type. You must specify this as \&quot;application/vnd.sas.search.indexable.data\&quot;.
   * @type {string}
   * @memberof IndexApiGetFilesIndexableResource
   */
  readonly acceptItem: string;

  /**
   * The URI of the associated object or parent object.
   * @type {string}
   * @memberof IndexApiGetFilesIndexableResource
   */
  readonly parentUri?: string;

  /**
   * The offset of the first member to return. The default is 0.
   * @type {number}
   * @memberof IndexApiGetFilesIndexableResource
   */
  readonly start?: number;

  /**
   * The maximum number of members to return. The default value is 10.
   * @type {number}
   * @memberof IndexApiGetFilesIndexableResource
   */
  readonly limit?: number;

  /**
   * The filter criteria to apply to the returned member collection.
   * @type {string}
   * @memberof IndexApiGetFilesIndexableResource
   */
  readonly filter?: string;

  /**
   * The sort criteria to apply to the returned member collection.
   * @type {string}
   * @memberof IndexApiGetFilesIndexableResource
   */
  readonly sortBy?: string;
}

/**
 * RootApi - axios parameter creator
 * @export
 */
export const RootApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Indicates whether the service is available.
     * @summary Check the state of the service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForRoot: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of links to the top-level resources that are available through the API. These top-level links include create and retrieve operations for /files.
     * @summary Get top-level resource links
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    root: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RootApi - functional programming interface
 * @export
 */
export const RootApi = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RootApiAxiosParamCreator(configuration);
  return {
    /**
     * Indicates whether the service is available.
     * @summary Check the state of the service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForRoot(
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForRoot(options);
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns a list of links to the top-level resources that are available through the API. These top-level links include create and retrieve operations for /files.
     * @summary Get top-level resource links
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async root(options?: AxiosRequestConfig): Promise<AxiosResponse<Api>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.root(options);
      return createRequestFunction(localVarAxiosArgs, configuration);
    },
  };
};

/**
 * SecurityApi - axios parameter creator
 * @export
 */
export const SecurityApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Updates the quarantine file resource information. The user can change only `quarantine` status. This end-Point is only accessible to SAS Administrators.
     * @summary Update the quarantine status of file resource
     * @param {string} fileId The identifier of the file resource to update.
     * @param {QuarantineFileToPatch} quarantineFileToPatch The file resource to update for quarantine status.
     * @param {string} [ifMatch] The entity tag that was obtained from the most recent &#x60;ETag&#x60; response header.
     * @param {string} [ifUnmodifiedSince] The timestamp that was obtained from the most recent &#x60;Last-Modified&#x60; response header. This is ignored when &#x60;If-Match&#x60; is specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchFileResourceQuarantine: async (
      fileId: string,
      quarantineFileToPatch: QuarantineFileToPatch,
      ifMatch?: string,
      ifUnmodifiedSince?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'fileId' is not null or undefined
      assertParamExists("patchFileResourceQuarantine", "fileId", fileId);
      // verify required parameter 'quarantineFileToPatch' is not null or undefined
      assertParamExists(
        "patchFileResourceQuarantine",
        "quarantineFileToPatch",
        quarantineFileToPatch,
      );
      const localVarPath = `/files/{fileId}/quarantine`.replace(
        `{${"fileId"}}`,
        encodeURIComponent(String(fileId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (ifMatch != null) {
        localVarHeaderParameter["If-Match"] = String(ifMatch);
      }

      if (ifUnmodifiedSince != null) {
        localVarHeaderParameter["If-Unmodified-Since"] =
          String(ifUnmodifiedSince);
      }

      localVarHeaderParameter["Content-Type"] = "application/vnd.sas.file+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        quarantineFileToPatch,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SecurityApi - functional programming interface
 * @export
 */
export const SecurityApi = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SecurityApiAxiosParamCreator(configuration);
  return {
    /**
     * Updates the quarantine file resource information. The user can change only `quarantine` status. This end-Point is only accessible to SAS Administrators.
     * @summary Update the quarantine status of file resource
     * @param {SecurityApiPatchFileResourceQuarantineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchFileResourceQuarantine(
      requestParameters: SecurityApiPatchFileResourceQuarantineRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<FileResource>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.patchFileResourceQuarantine(
          requestParameters.fileId,
          requestParameters.quarantineFileToPatch,
          requestParameters.ifMatch,
          requestParameters.ifUnmodifiedSince,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },
  };
};

/**
 * Request parameters for patchFileResourceQuarantine operation in SecurityApi.
 * @export
 * @interface SecurityApiPatchFileResourceQuarantineRequest
 */
export interface SecurityApiPatchFileResourceQuarantineRequest {
  /**
   * The identifier of the file resource to update.
   * @type {string}
   * @memberof SecurityApiPatchFileResourceQuarantine
   */
  readonly fileId: string;

  /**
   * The file resource to update for quarantine status.
   * @type {QuarantineFileToPatch}
   * @memberof SecurityApiPatchFileResourceQuarantine
   */
  readonly quarantineFileToPatch: QuarantineFileToPatch;

  /**
   * The entity tag that was obtained from the most recent &#x60;ETag&#x60; response header.
   * @type {string}
   * @memberof SecurityApiPatchFileResourceQuarantine
   */
  readonly ifMatch?: string;

  /**
   * The timestamp that was obtained from the most recent &#x60;Last-Modified&#x60; response header. This is ignored when &#x60;If-Match&#x60; is specified.
   * @type {string}
   * @memberof SecurityApiPatchFileResourceQuarantine
   */
  readonly ifUnmodifiedSince?: string;
}

/**
 * SettingsApi - axios parameter creator
 * @export
 */
export const SettingsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns the possible configuration settings that this API/service shares.
     * @summary Get the API/service configuration settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSettings: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/commons/settings`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApi = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SettingsApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns the possible configuration settings that this API/service shares.
     * @summary Get the API/service configuration settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSettings(
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Settings>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSettings(options);
      return createRequestFunction(localVarAxiosArgs, configuration);
    },
  };
};

/**
 * SummaryApi - axios parameter creator
 * @export
 */
export const SummaryApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Retrieves summary representations of file resources for the specified criteria. Standard paging, filtering, and sorting options are available.
     * @summary Get summary representations
     * @param {string} acceptItem The value of the file resource media type. You must specify this as \&quot;application/vnd.sas.summary\&quot;.
     * @param {string} [parentUri] The URI of the associated object or parent object.
     * @param {number} [start] The offset of the first member to return. The default value is 0.
     * @param {number} [limit] The maximum number of members to return. The default value is 10.
     * @param {string} [filter] The filter criteria to apply to the returned member collection.
     * @param {string} [sortBy] The sort criteria to apply to the returned member collection.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFilesSummaryForFilter: async (
      acceptItem: string,
      parentUri?: string,
      start?: number,
      limit?: number,
      filter?: string,
      sortBy?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'acceptItem' is not null or undefined
      assertParamExists("getFilesSummaryForFilter", "acceptItem", acceptItem);
      const localVarPath = `/files#getSummaryRepresentationCollection`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (parentUri !== undefined) {
        localVarQueryParameter["parentUri"] = parentUri;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (filter !== undefined) {
        localVarQueryParameter["filter"] = filter;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter["sortBy"] = sortBy;
      }

      if (acceptItem != null) {
        localVarHeaderParameter["Accept-Item"] = String(acceptItem);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves a generic summary representation of a file for the specified identifier.
     * @summary Get a generic summary representation
     * @param {string} fileId The identifier of the file resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getfileSummaryRepForGivenId: async (
      fileId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'fileId' is not null or undefined
      assertParamExists("getfileSummaryRepForGivenId", "fileId", fileId);
      const localVarPath = `/files/{fileId}#getSummaryRepresentation`.replace(
        `{${"fileId"}}`,
        encodeURIComponent(String(fileId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SummaryApi - functional programming interface
 * @export
 */
export const SummaryApi = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SummaryApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieves summary representations of file resources for the specified criteria. Standard paging, filtering, and sorting options are available.
     * @summary Get summary representations
     * @param {SummaryApiGetFilesSummaryForFilterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFilesSummaryForFilter(
      requestParameters: SummaryApiGetFilesSummaryForFilterRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<FileResourceSummaryCollection>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getFilesSummaryForFilter(
          requestParameters.acceptItem,
          requestParameters.parentUri,
          requestParameters.start,
          requestParameters.limit,
          requestParameters.filter,
          requestParameters.sortBy,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Retrieves a generic summary representation of a file for the specified identifier.
     * @summary Get a generic summary representation
     * @param {SummaryApiGetfileSummaryRepForGivenIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getfileSummaryRepForGivenId(
      requestParameters: SummaryApiGetfileSummaryRepForGivenIdRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<FileResourceSummary>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getfileSummaryRepForGivenId(
          requestParameters.fileId,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },
  };
};

/**
 * Request parameters for getFilesSummaryForFilter operation in SummaryApi.
 * @export
 * @interface SummaryApiGetFilesSummaryForFilterRequest
 */
export interface SummaryApiGetFilesSummaryForFilterRequest {
  /**
   * The value of the file resource media type. You must specify this as \&quot;application/vnd.sas.summary\&quot;.
   * @type {string}
   * @memberof SummaryApiGetFilesSummaryForFilter
   */
  readonly acceptItem: string;

  /**
   * The URI of the associated object or parent object.
   * @type {string}
   * @memberof SummaryApiGetFilesSummaryForFilter
   */
  readonly parentUri?: string;

  /**
   * The offset of the first member to return. The default value is 0.
   * @type {number}
   * @memberof SummaryApiGetFilesSummaryForFilter
   */
  readonly start?: number;

  /**
   * The maximum number of members to return. The default value is 10.
   * @type {number}
   * @memberof SummaryApiGetFilesSummaryForFilter
   */
  readonly limit?: number;

  /**
   * The filter criteria to apply to the returned member collection.
   * @type {string}
   * @memberof SummaryApiGetFilesSummaryForFilter
   */
  readonly filter?: string;

  /**
   * The sort criteria to apply to the returned member collection.
   * @type {string}
   * @memberof SummaryApiGetFilesSummaryForFilter
   */
  readonly sortBy?: string;
}

/**
 * Request parameters for getfileSummaryRepForGivenId operation in SummaryApi.
 * @export
 * @interface SummaryApiGetfileSummaryRepForGivenIdRequest
 */
export interface SummaryApiGetfileSummaryRepForGivenIdRequest {
  /**
   * The identifier of the file resource.
   * @type {string}
   * @memberof SummaryApiGetfileSummaryRepForGivenId
   */
  readonly fileId: string;
}
