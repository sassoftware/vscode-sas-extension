// Copyright Â© 2023, SAS Institute Inc., Cary, NC, USA.  All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

/**
 * Folders
 * The Folders API provides an organizational structure for SAS and external content. It can also be used for favorites folders or a history of objects accessed. The resources that are stored in folders (members) use a URI to point back to those resources. <H4><strong>Terminology:</strong></H4> <H4>folder</H4>    <p> A virtual container for other folders, or any resource that can be represented with a URI.</p> <H4>member</H4>   <p> A resource contained in a folder. A member can itself be a folder, creating a hierarchical structure for folders and subfolders. Members have two types: child and reference. A child member inherits authorizations from its container, and a given resource can be a child only in a single folder. Reference members do not inherit authorizations, and a resource can have many references in many different folders.
 *
 * The version of the OpenAPI document: 4
 * Contact: devex@sas.com
 *
 * NOTE: This class is auto generated by OpenAPI
 * Do not edit the class manually.
 */

/* tslint:disable */
/* eslint-disable */

import { Configuration } from "./configuration";
import { AxiosResponse, AxiosRequestConfig } from "axios";
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from "url";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  RequestArgs,
  assertParamExists,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";

/**
 * An ancestor entry that is returned from an ancestor\'s request.
 * @export
 * @interface Ancestor
 */
export interface Ancestor {
  /**
   * The URI whose ancestry was requested.
   * @type {string}
   * @memberof Ancestor
   */
  childUri?: string;
  /**
   * An ordered list of the folders that parent the URI, starting with the immediate parent.
   * @type {Array<Folder>}
   * @memberof Ancestor
   */
  ancestors?: Array<Folder>;
  /**
   * This media type\'s schema version number. This representation is version 1.
   * @type {number}
   * @memberof Ancestor
   */
  version?: number;
}
/**
 * A collection of ancestor entries that are returned from an ancestors request.
 * @export
 * @interface AncestorCollection
 */
export interface AncestorCollection {
  /**
   * The name of the collection.
   * @type {string}
   * @memberof AncestorCollection
   */
  name?: string;
  /**
   * The zero-based index of the first item in the collection.
   * @type {number}
   * @memberof AncestorCollection
   */
  start?: number;
  /**
   * The number of items that were requested for the collection.
   * @type {number}
   * @memberof AncestorCollection
   */
  limit?: number;
  /**
   * If populated indicates the number of items in the collection.
   * @type {number}
   * @memberof AncestorCollection
   */
  count?: number;
  /**
   * A space-delimited list of media types from which an `Accept` header can be constructed.
   * @type {string}
   * @memberof AncestorCollection
   */
  accept?: string;
  /**
   * The links that apply to the collection.
   * @type {Array<Link>}
   * @memberof AncestorCollection
   */
  links?: Array<Link>;
  /**
   * The version number of the collection representation. This representation is version 2.
   * @type {number}
   * @memberof AncestorCollection
   */
  version?: number;
  /**
   * The collection of ancestor results.
   * @type {Array<Ancestor>}
   * @memberof AncestorCollection
   */
  items?: Array<Ancestor>;
}
/**
 *
 * @export
 * @interface AncestorCollectionAllOf
 */
export interface AncestorCollectionAllOf {
  /**
   * The collection of ancestor results.
   * @type {Array<Ancestor>}
   * @memberof AncestorCollectionAllOf
   */
  items?: Array<Ancestor>;
}
/**
 * This is a base schema used to define paginated collections of resources. This base schema is extended by other schemas in APIs by adding an \'items\' array property. These extensions define the application/vnd.sas.collection media type (version 2)
 * @export
 * @interface BaseCollection
 */
export interface BaseCollection {
  /**
   * The name of the collection.
   * @type {string}
   * @memberof BaseCollection
   */
  name?: string;
  /**
   * The zero-based index of the first item in the collection.
   * @type {number}
   * @memberof BaseCollection
   */
  start?: number;
  /**
   * The number of items that were requested for the collection.
   * @type {number}
   * @memberof BaseCollection
   */
  limit?: number;
  /**
   * If populated indicates the number of items in the collection.
   * @type {number}
   * @memberof BaseCollection
   */
  count?: number;
  /**
   * A space-delimited list of media types from which an `Accept` header can be constructed.
   * @type {string}
   * @memberof BaseCollection
   */
  accept?: string;
  /**
   * The links that apply to the collection.
   * @type {Array<Link>}
   * @memberof BaseCollection
   */
  links?: Array<Link>;
  /**
   * The version number of the collection representation. This representation is version 2.
   * @type {number}
   * @memberof BaseCollection
   */
  version?: number;
}
/**
 * A representation of a delegate identifier that is recognized by the Folders API.
 * @export
 * @interface Delegate
 */
export interface Delegate {
  /**
   * The delegate name, always starting with \'@\'.
   * @type {string}
   * @memberof Delegate
   */
  name?: string;
  /**
   * The folder name of the delegate, for example, for @myFolder, My Folder.
   * @type {string}
   * @memberof Delegate
   */
  folderName?: string;
  /**
   * The value of the type field for this delegate. For example, for @myFolder, myFolder.
   * @type {string}
   * @memberof Delegate
   */
  folderType?: string;
  /**
   * This media type\'s schema version number. This representation is version 1.
   * @type {number}
   * @memberof Delegate
   */
  version?: number;
}
/**
 * A collection of delegate objects.
 * @export
 * @interface DelegateCollection
 */
export interface DelegateCollection {
  /**
   * The name of the collection.
   * @type {string}
   * @memberof DelegateCollection
   */
  name?: string;
  /**
   * The zero-based index of the first item in the collection.
   * @type {number}
   * @memberof DelegateCollection
   */
  start?: number;
  /**
   * The number of items that were requested for the collection.
   * @type {number}
   * @memberof DelegateCollection
   */
  limit?: number;
  /**
   * If populated indicates the number of items in the collection.
   * @type {number}
   * @memberof DelegateCollection
   */
  count?: number;
  /**
   * A space-delimited list of media types from which an `Accept` header can be constructed.
   * @type {string}
   * @memberof DelegateCollection
   */
  accept?: string;
  /**
   * The links that apply to the collection.
   * @type {Array<Link>}
   * @memberof DelegateCollection
   */
  links?: Array<Link>;
  /**
   * The version number of the collection representation. This representation is version 2.
   * @type {number}
   * @memberof DelegateCollection
   */
  version?: number;
  /**
   * The collection of delegate definitions.
   * @type {Array<Delegate>}
   * @memberof DelegateCollection
   */
  items?: Array<Delegate>;
}
/**
 *
 * @export
 * @interface DelegateCollectionAllOf
 */
export interface DelegateCollectionAllOf {
  /**
   * The collection of delegate definitions.
   * @type {Array<Delegate>}
   * @memberof DelegateCollectionAllOf
   */
  items?: Array<Delegate>;
}
/**
 * The representation of an error.
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
  /**
   * The error message.
   * @type {string}
   * @memberof ErrorResponse
   */
  message?: string;
  /**
   * The string ID for the error.
   * @type {string}
   * @memberof ErrorResponse
   */
  id?: string;
  /**
   * The numeric ID for the error.
   * @type {number}
   * @memberof ErrorResponse
   */
  errorCode?: number;
  /**
   * The HTTP status code for the error.
   * @type {number}
   * @memberof ErrorResponse
   */
  httpStatusCode: number;
  /**
   * Messages that provide additional details about the cause of the error.
   * @type {Array<string>}
   * @memberof ErrorResponse
   */
  details?: Array<string>;
  /**
   * A message that describes how to resolve the error.
   * @type {string}
   * @memberof ErrorResponse
   */
  remediation?: string;
  /**
   * Any additional errors that occurred
   * @type {Array<ErrorResponse>}
   * @memberof ErrorResponse
   */
  errors?: Array<ErrorResponse>;
  /**
   * The links that apply to the error.
   * @type {Array<Link>}
   * @memberof ErrorResponse
   */
  links?: Array<Link>;
  /**
   * The version number of the error representation. This representation is version 2.
   * @type {number}
   * @memberof ErrorResponse
   */
  version: number;
}
/**
 * The full representation of a folder object.
 * @export
 * @interface Folder
 */
export interface Folder {
  /**
   * Folder id.
   * @type {string}
   * @memberof Folder
   */
  id?: string;
  /**
   * Localizable folder name.
   * @type {string}
   * @memberof Folder
   */
  name?: string;
  /**
   * Folder description.
   * @type {string}
   * @memberof Folder
   */
  description?: string;
  /**
   * The URI of this folder\'s parent folder. This is writable by the client. In order to perform a move, PUT this folder with an updated parentFolderUri pointing to the new parent. It is valid for this field to be null, which indicates a root folder.
   * @type {string}
   * @memberof Folder
   */
  parentFolderUri?: string;
  /**
   * Timestamp of folder creation.
   * @type {string}
   * @memberof Folder
   */
  creationTimeStamp?: string;
  /**
   * Timestamp of last folder modification.
   * @type {string}
   * @memberof Folder
   */
  modifiedTimeStamp?: string;
  /**
   * The name of the user who created this folder.
   * @type {string}
   * @memberof Folder
   */
  createdBy?: string;
  /**
   * The name of the last user who modified this object.
   * @type {string}
   * @memberof Folder
   */
  modifiedBy?: string;
  /**
   * The folder type.
   * @type {string}
   * @memberof Folder
   */
  type?: string;
  /**
   * The folder icon URI.
   * @type {string}
   * @memberof Folder
   */
  iconUri?: string;
  /**
   * The number of members in the folder.
   * @type {number}
   * @memberof Folder
   */
  memberCount?: number;
  /**
   * Links that apply to this object. Includes \"self\", \"members\", and \"delete\".
   * @type {Array<Link>}
   * @memberof Folder
   */
  links?: Array<Link>;
  /**
   * A collection of name/value pairs that help describe the folder.
   * @type {{ [key: string]: string; }}
   * @memberof Folder
   */
  properties?: { [key: string]: string };
  /**
   * This media type\'s schema version number. This representation is version 1.
   * @type {number}
   * @memberof Folder
   */
  version?: number;
}
/**
 * A collection of folders.
 * @export
 * @interface FolderCollection
 */
export interface FolderCollection {
  /**
   * The name of the collection.
   * @type {string}
   * @memberof FolderCollection
   */
  name?: string;
  /**
   * The zero-based index of the first item in the collection.
   * @type {number}
   * @memberof FolderCollection
   */
  start?: number;
  /**
   * The number of items that were requested for the collection.
   * @type {number}
   * @memberof FolderCollection
   */
  limit?: number;
  /**
   * If populated indicates the number of items in the collection.
   * @type {number}
   * @memberof FolderCollection
   */
  count?: number;
  /**
   * A space-delimited list of media types from which an `Accept` header can be constructed.
   * @type {string}
   * @memberof FolderCollection
   */
  accept?: string;
  /**
   * The links that apply to the collection.
   * @type {Array<Link>}
   * @memberof FolderCollection
   */
  links?: Array<Link>;
  /**
   * The version number of the collection representation. This representation is version 2.
   * @type {number}
   * @memberof FolderCollection
   */
  version?: number;
  /**
   * The actual results of a query.
   * @type {Array<Folder>}
   * @memberof FolderCollection
   */
  items?: Array<Folder>;
}
/**
 *
 * @export
 * @interface FolderCollectionAllOf
 */
export interface FolderCollectionAllOf {
  /**
   * The actual results of a query.
   * @type {Array<Folder>}
   * @memberof FolderCollectionAllOf
   */
  items?: Array<Folder>;
}
/**
 * The schema for creating a new folder.
 * @export
 * @interface FolderIn
 */
export interface FolderIn {
  /**
   * Localizable folder name.
   * @type {string}
   * @memberof FolderIn
   */
  name: string;
  /**
   * Localizable folder description.
   * @type {string}
   * @memberof FolderIn
   */
  description?: string;
  /**
   * Specialized subtype for this folder. The default value is \'folder\'.
   * @type {string}
   * @memberof FolderIn
   */
  folderType?: string;
  /**
   * The URI of this folder\'s parent folder. This is writable by the client. In order to perform a move, PUT this folder with an updated parentFolderUri pointing to the new parent. It is valid for this field to be null, which indicates a root folder.
   * @type {string}
   * @memberof FolderIn
   */
  parentFolderUri?: string;
  /**
   * This media type\'s schema version number. This representation is version 1.
   * @type {number}
   * @memberof FolderIn
   */
  version?: number;
}
/**
 * A representation of a folder type.
 * @export
 * @interface FolderType
 */
export interface FolderType {
  /**
   * The name of the folder type. This is the value that goes in the folderType field of a folder.
   * @type {string}
   * @memberof FolderType
   */
  name?: string;
  /**
   * The localizable label that can be presented to a user.
   * @type {string}
   * @memberof FolderType
   */
  label?: string;
  /**
   * True if the type is acceptable to use in a folder being created by a client.
   * @type {boolean}
   * @memberof FolderType
   */
  userAssignable?: boolean;
  /**
   * This media type\'s schema version number. This representation is version 1.
   * @type {number}
   * @memberof FolderType
   */
  version?: number;
}
/**
 * A collection of folder types.
 * @export
 * @interface FolderTypeCollection
 */
export interface FolderTypeCollection {
  /**
   * The name of the collection.
   * @type {string}
   * @memberof FolderTypeCollection
   */
  name?: string;
  /**
   * The zero-based index of the first item in the collection.
   * @type {number}
   * @memberof FolderTypeCollection
   */
  start?: number;
  /**
   * The number of items that were requested for the collection.
   * @type {number}
   * @memberof FolderTypeCollection
   */
  limit?: number;
  /**
   * If populated indicates the number of items in the collection.
   * @type {number}
   * @memberof FolderTypeCollection
   */
  count?: number;
  /**
   * A space-delimited list of media types from which an `Accept` header can be constructed.
   * @type {string}
   * @memberof FolderTypeCollection
   */
  accept?: string;
  /**
   * The links that apply to the collection.
   * @type {Array<Link>}
   * @memberof FolderTypeCollection
   */
  links?: Array<Link>;
  /**
   * The version number of the collection representation. This representation is version 2.
   * @type {number}
   * @memberof FolderTypeCollection
   */
  version?: number;
  /**
   * The collection of folder types.
   * @type {Array<FolderType>}
   * @memberof FolderTypeCollection
   */
  items?: Array<FolderType>;
}
/**
 *
 * @export
 * @interface FolderTypeCollectionAllOf
 */
export interface FolderTypeCollectionAllOf {
  /**
   * The collection of folder types.
   * @type {Array<FolderType>}
   * @memberof FolderTypeCollectionAllOf
   */
  items?: Array<FolderType>;
}
/**
 * A link to a related operation or resource.
 * @export
 * @interface Link
 */
export interface Link {
  /**
   * The HTTP method to invoke this endpoint.
   * @type {string}
   * @memberof Link
   */
  method?: string;
  /**
   * The relationship of this URL to the object.
   * @type {string}
   * @memberof Link
   */
  rel?: string;
  /**
   * The relative URI of the REST endpoint.
   * @type {string}
   * @memberof Link
   */
  uri?: string;
  /**
   * The full URL of the REST endpoint.
   * @type {string}
   * @memberof Link
   */
  href?: string;
  /**
   * The media type consumed/produced.
   * @type {string}
   * @memberof Link
   */
  type?: string;
}
/**
 * The full representation of a folder member.
 * @export
 * @interface Member
 */
export interface Member {
  /**
   * Member id.
   * @type {string}
   * @memberof Member
   */
  id?: string;
  /**
   * The URI of the item that the member represents. The service does not make any attempt to validate this field, so it can be anything. However, if this is a folder, it MUST be the folder\'s URI. It should come from the folder\'s \"self\" link, and not be assembled from pieces.
   * @type {string}
   * @memberof Member
   */
  uri?: string;
  /**
   * Timestamp when member was last added to folder.
   * @type {string}
   * @memberof Member
   */
  added?: string;
  /**
   * Must be \"child\" or \"reference\". Child members are deleted when the  parent folder is deleted. Child members that rely on SAS authorization checking inherit authorization settings from the parent folder. An object can be a child of one and only one folder. Reference members have no such restrictions. Any member object can be referenced from an unrestricted number of containers.
   * @type {string}
   * @memberof Member
   */
  type?: string;
  /**
   * The URI of this member\'s parent folder. This is writable by the client. In order to perform a move, PUT this member with an updated parentFolderUri pointing to the new parent.
   * @type {string}
   * @memberof Member
   */
  parentFolderUri?: string;
  /**
   * Localizable name of the member object. This attribute is persisted with the folder for performance reasons. For SAS managed objects, this value is intended to be synchronized with the attribute persisted with the object.
   * @type {string}
   * @memberof Member
   */
  name?: string;
  /**
   * Localizable description of the member object. Member attribute is synchronized with attribute of member object for SAS managed objects.
   * @type {string}
   * @memberof Member
   */
  description?: string;
  /**
   * The user name of the user who created the object represented by this member.
   * @type {string}
   * @memberof Member
   */
  createdBy?: string;
  /**
   * Timestamp of member object creation. Member attribute is synchronized with attribute of member object for SAS managed objects.
   * @type {string}
   * @memberof Member
   */
  creationTimeStamp?: string;
  /**
   * The user name of the user who last modified the object represented by this member.
   * @type {string}
   * @memberof Member
   */
  modifiedBy?: string;
  /**
   * Timestamp of last member object modification. Member attribute is synchronized with attribute of member object for SAS managed objects.
   * @type {string}
   * @memberof Member
   */
  modifiedTimeStamp?: string;
  /**
   * Member object type. Member attribute is synchronized with attribute of member object for SAS managed objects.
   * @type {string}
   * @memberof Member
   */
  contentType?: string;
  /**
   * (version 2) If the resource has a subtype that applies, the client can specify it when creating the member. This gives the client navigating the members more information for filtering, sorting, or searching for matching members.
   * @type {string}
   * @memberof Member
   */
  typeDefName?: string;
  /**
   * Member object icon URI. Member attribute is synchronized with attribute of member object for SAS managed objects.
   * @type {string}
   * @memberof Member
   */
  iconUri?: string;
  /**
   * Optional ordering specifier to provide user ordering of members. When retrieving members, if no other ordering is specified, members are ordered by this field in ascending order. The values do not have to be sequential; the results are ordered according to the values provided. They also do not have to be unique. However, duplicates result in arbitrary ordering of records with duplicate values.
   * @type {number}
   * @memberof Member
   */
  orderNum?: number;
  /**
   * Links that apply to this object. Links for members include \"self\" and \"delete\".
   * @type {Array<Link>}
   * @memberof Member
   */
  links?: Array<Link>;
  /**
   * This media type\'s schema version number. This representation is version 2.
   * @type {number}
   * @memberof Member
   */
  version?: number;
}
/**
 * A collection of folder members.
 * @export
 * @interface MemberCollection
 */
export interface MemberCollection {
  /**
   * The name of the collection.
   * @type {string}
   * @memberof MemberCollection
   */
  name?: string;
  /**
   * The zero-based index of the first item in the collection.
   * @type {number}
   * @memberof MemberCollection
   */
  start?: number;
  /**
   * The number of items that were requested for the collection.
   * @type {number}
   * @memberof MemberCollection
   */
  limit?: number;
  /**
   * If populated indicates the number of items in the collection.
   * @type {number}
   * @memberof MemberCollection
   */
  count?: number;
  /**
   * A space-delimited list of media types from which an `Accept` header can be constructed.
   * @type {string}
   * @memberof MemberCollection
   */
  accept?: string;
  /**
   * The links that apply to the collection.
   * @type {Array<Link>}
   * @memberof MemberCollection
   */
  links?: Array<Link>;
  /**
   * The version number of the collection representation. This representation is version 2.
   * @type {number}
   * @memberof MemberCollection
   */
  version?: number;
  /**
   * The actual results of a query.
   * @type {Array<Member>}
   * @memberof MemberCollection
   */
  items?: Array<Member>;
}
/**
 *
 * @export
 * @interface MemberCollectionAllOf
 */
export interface MemberCollectionAllOf {
  /**
   * The actual results of a query.
   * @type {Array<Member>}
   * @memberof MemberCollectionAllOf
   */
  items?: Array<Member>;
}
/**
 * The schema for creating a new folder member.
 * @export
 * @interface MemberIn
 */
export interface MemberIn {
  /**
   * The URI of the item that the member represents. The service does not make any attempt to validate this field, so it can be anything. However, if this is a folder, it MUST be the folder\'s URI. It should come from the folder\'s \"self\" link, and not be assembled from pieces.
   * @type {string}
   * @memberof MemberIn
   */
  uri: string;
  /**
   * Must be \"child\" or \"reference\". Child members are deleted when the parent folder is deleted. Child members that rely on SAS authorization checking inherit authorization settings from the parent folder. An object can be a child of one and only one folder. Reference members have no such restrictions. Any member object can be referenced from an unrestricted number of containers.
   * @type {string}
   * @memberof MemberIn
   */
  type: string;
  /**
   * The URI of this member\'s parent folder. This is writable by the client. In order to perform a move, PUT this member with an updated parentFolderUri pointing to the new parent.
   * @type {string}
   * @memberof MemberIn
   */
  parentFolderUri?: string;
  /**
   * Localizable name of the member object. This attribute is persisted with the folder for performance reasons. For SAS managed objects, this value is intended to be synchronized with the attribute persisted with the object.
   * @type {string}
   * @memberof MemberIn
   */
  name: string;
  /**
   * Localizable description of the member object. Member attribute is synchronized with attribute of member object for SAS managed objects.
   * @type {string}
   * @memberof MemberIn
   */
  description?: string;
  /**
   * Timestamp of member object creation. Member attribute is synchronized with attribute of member object for SAS managed objects.
   * @type {string}
   * @memberof MemberIn
   */
  creationTimeStamp?: string;
  /**
   * Timestamp of last member object modification. Member attribute is synchronized with attribute of member object for SAS managed objects.
   * @type {string}
   * @memberof MemberIn
   */
  modifiedTimeStamp?: string;
  /**
   * Member object type. Member attribute is synchronized with attribute of member object for SAS managed objects.
   * @type {string}
   * @memberof MemberIn
   */
  contentType?: string;
  /**
   * (version 2) If the resource has a subtype that applies, the client can specify it when creating the member. This gives the client navigating the members more information for filtering, sorting, or searching for matching members.
   * @type {string}
   * @memberof MemberIn
   */
  typeDefName?: string;
  /**
   * Member object icon URI. Member attribute is synchronized with attribute of member object for SAS managed objects.
   * @type {string}
   * @memberof MemberIn
   */
  iconUri?: string;
  /**
   * Optional ordering specifier to provide user ordering of members. When retrieving members, if no other ordering is specified, members are ordered by this field in ascending order. The values do not have to be sequential; the results are ordered according to the values provided. The values also do not have to be unique. However, duplicates result in arbitrary ordering of records with duplicate values.
   * @type {number}
   * @memberof MemberIn
   */
  orderNum?: number;
  /**
   * This media type\'s schema version number. This representation is version 2.
   * @type {number}
   * @memberof MemberIn
   */
  version?: number;
}
/**
 * A representation of a path request.
 * @export
 * @interface Path
 */
export interface Path {
  /**
   * An ordered list of parent folder names, with the desired object\'s name at the end of the list.
   * @type {Array<string>}
   * @memberof Path
   */
  items?: Array<string>;
  /**
   * The content type of the object to return. Must match the content type of the Member entry.
   * @type {string}
   * @memberof Path
   */
  contentType?: string;
  /**
   * The type definition name of the member being requested.
   * @type {string}
   * @memberof Path
   */
  typeDefName?: string;
  /**
   * This media type\'s schema version number. This representation is version 1.
   * @type {number}
   * @memberof Path
   */
  version?: number;
}
/**
 * The summarized representation of a resource. Often used in collection responses when more specific details are not needed.
 * @export
 * @interface Summary
 */
export interface Summary {
  /**
   * The unique identifier for the resource.
   * @type {string}
   * @memberof Summary
   */
  id: string;
  /**
   * The name of the resource.
   * @type {string}
   * @memberof Summary
   */
  name?: string;
  /**
   * The type of the resource.
   * @type {string}
   * @memberof Summary
   */
  type?: string;
  /**
   * The description of the resource.
   * @type {string}
   * @memberof Summary
   */
  description?: string;
  /**
   * The user who created the resource.
   * @type {string}
   * @memberof Summary
   */
  createdBy?: string;
  /**
   * The timestamp in YYYY-MM-DDThh:mm:ss.sssZ format when the resource was created.
   * @type {string}
   * @memberof Summary
   */
  creationTimeStamp?: string;
  /**
   * The user who most recently modified the resource.
   * @type {string}
   * @memberof Summary
   */
  modifiedBy?: string;
  /**
   * The timestamp in YYYY-MM-DDThh:mm:ss.sssZ format when the resource was last modified.
   * @type {string}
   * @memberof Summary
   */
  modifiedTimeStamp?: string;
  /**
   * The links that apply to the resource.
   * @type {Array<Link>}
   * @memberof Summary
   */
  links: Array<Link>;
  /**
   * The version number of the resource. This representation is version 1.
   * @type {number}
   * @memberof Summary
   */
  version: number;
}
/**
 * The response from a pre-flight validation request. For APIs that support validation, the client can run operations (typically on resources in the `/commons/validation`) with `application/vnd.sas.validation+json` as the requested response type (via the `Accept:` request header). The service will validate the request but not execute the request, and return this response to indicate whether the request was valid at the time it was made.
 * @export
 * @interface Validation
 */
export interface Validation {
  /**
   * This media type\'s schema version number. This representation is version 1.
   * @type {number}
   * @memberof Validation
   */
  version: number;
  /**
   * `true` if and only if the validation was successful.
   * @type {boolean}
   * @memberof Validation
   */
  valid: boolean;
  /**
   *
   * @type {ErrorResponse}
   * @memberof Validation
   */
  error?: ErrorResponse;
  /**
   * An array of links to related resources and actions.
   * @type {Array<Link>}
   * @memberof Validation
   */
  links?: Array<Link>;
}

/**
 * FolderApi - axios parameter creator
 * @export
 */
export const FolderApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Creates a new empty folder. Members can be added to the folder using the `/folders/{folderId}/members` endpoint. This service maintains name uniqueness at any given level in the folder structure. In other words, if you try to create a root folder named \"newRootFolder\", and a root folder with that name exists, the operation fails with a 409 status. If you try to create a subfolder using the `?parentFolderUri` parameter, and the parent already has a subfolder with the same name, the operation fails with a 409 status.
     * @summary Create a new folder
     * @param {string} parentFolderUri URI of folder to add new folder as a child. This parameter is required. An explicit value of \&quot;none\&quot; indicates that the client wants to create a root folder.
     * @param {FolderIn} [folderIn] Folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFolder: async (
      parentFolderUri: string,
      folderIn?: FolderIn,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'parentFolderUri' is not null or undefined
      assertParamExists("createFolder", "parentFolderUri", parentFolderUri);
      const localVarPath = `/folders`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (parentFolderUri !== undefined) {
        localVarQueryParameter["parentFolderUri"] = parentFolderUri;
      }

      localVarHeaderParameter["Content-Type"] =
        "application/vnd.sas.content.folder+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        folderIn,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * The specified folder is deleted. If the folder is not empty, a recursive option can be specified to indicate a recursive delete. If the folder is not empty and no recursive option is present, an error response is returned. Any non-folder content will not be deleted.
     * @summary Delete a folder
     * @param {string} folderId The identifier of a specific folder or one of the delegate strings @myFolder, @appDataFolder, @myHistory, @myFavorites, or @public.
     * @param {boolean} [recursive] do a recursive delete of the folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFolder: async (
      folderId: string,
      recursive?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'folderId' is not null or undefined
      assertParamExists("deleteFolder", "folderId", folderId);
      const localVarPath = `/folders/{folderId}`.replace(
        `{${"folderId"}}`,
        encodeURIComponent(String(folderId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (recursive !== undefined) {
        localVarQueryParameter["recursive"] = recursive;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Find an object, if it exists, by path. The client provides an ordered list of parent folder names, the object name, and the object content type.
     * @summary Find an object by path
     * @param {Path} path The set of parent names, the object name, and the object content type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findByPath: async (
      path: Path,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'path' is not null or undefined
      assertParamExists("findByPath", "path", path);
      const localVarPath = `/paths`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] =
        "application/vnd.sas.content.folder.path+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        path,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns the folders for the given set of delegate names, or all delegate folders if no names are provided.
     * @summary Get the folders for a given set of delegate names
     * @param {string} [name] The name of the delegate (including the leading \&#39;@\&#39;) desired. Multiple values of the name parameter can be provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDelegateFolders: async (
      name?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/delegateFolders`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns the specified folder.
     * @summary Get a folder
     * @param {string} folderId The identifier of a specific folder or one of the delegate strings @myFolder, @appDataFolder, @myHistory, @myFavorites, or @public.
     * @param {string} [acceptLanguage] Enumerates the languages that the client prefers to use for the response. This can be used to provide localized data where available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFolder: async (
      folderId: string,
      acceptLanguage?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'folderId' is not null or undefined
      assertParamExists("getFolder", "folderId", folderId);
      const localVarPath = `/folders/{folderId}`.replace(
        `{${"folderId"}}`,
        encodeURIComponent(String(folderId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage != null) {
        localVarHeaderParameter["Accept-Language"] = String(acceptLanguage);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a folder with a resource wildcard. Either a path or a child URI is required. The result must be exactly one matching folder. If the childUri parameter is provided, the parent folder of the member with the matching URI is returned, if it exists. If the path is provided, it must be a slash-delimited path to the desired folder.
     * @summary Get a folder with a path or a child URI
     * @param {string} [childUri] The URI of a resource whose parent folder you want to return. This can be a folder or non-folder resource.
     * @param {string} [path] The slash-delimited path to a folder. For example, &#x60;/root/child/grandchild/greatgrandchild&#x60; would return the folder greatgrandchild.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFolderItem: async (
      childUri?: string,
      path?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/folders/@item`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (childUri !== undefined) {
        localVarQueryParameter["childUri"] = childUri;
      }

      if (path !== undefined) {
        localVarQueryParameter["path"] = path;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of folders. Standard paging, filtering, and sorting options are provided.
     * @summary Get a list of folders
     * @param {number} [start] 0-based offset of first folder to return. The default value is 0.
     * @param {number} [limit] Maximum number of folders to return. The default value is 20.
     * @param {string} [filter] Filter criteria for returned folders. See [Filtering in REST APIs](https://developer.sas.com/apis/rest/Topics/#filters). &lt;br&gt;Any member of the Folder object can be used to filter the results: id, name, description, createdBy, modifiedBy, properties, folderType, or parent. Date fields currently cannot be used to filter results. &lt;br&gt;Sample queries&lt;br&gt; &lt;ul&gt; &lt;li&gt;Get Root Folders: &#x60;/folders?filter&#x3D;isNull(parent)&#x60;&lt;/li&gt; &lt;li&gt;Get folders by name: &#x60;/folders?filter&#x3D;contains(name, \&#39;Sample\&#39;)&#x60;&lt;/li&gt; &lt;li&gt;Get folders by folderType: &#x60;/folders?filter&#x3D;in(folderType, \&#39;history\&#39;, \&#39;favorites\&#39;)&#x60;&lt;/li&gt; &lt;/ul&gt;
     * @param {string} [sortBy] Sort returned folder. See [Sorting in REST APIs](https://developer.sas.com/apis/rest/Topics/#sorting).&lt;br&gt; The default sort order is name:ascending. Other valid sorting options are &lt;ul&gt;&lt;li&gt;&lt;code&gt;orderNum&lt;/code&gt; the order specified by the user&lt;/li&gt; &lt;li&gt;&lt;code&gt;added&lt;/code&gt; the timestamp when the item was added to the folder&lt;/li&gt; &lt;li&gt;&lt;code&gt;name&lt;/code&gt; the folder name &lt;/ul&gt;
     * @param {string} [childUri] Return only folders containing a child member with the specified URI. For now, childUri, referenceUri, memberUri, and filter are mutually exclusive. The childUri has special semantics, because it should return only a single item. The URL form &#x60;/folders/.?childUri&#x3D;{resourceUri}&#x60; can be used to return a single item.
     * @param {string} [referenceUri] Return only folders containing a reference member with the specified URI. For now, childUri, referenceUri, memberUri, and filter are mutually exclusive.
     * @param {string} [memberUri] Return only folders containing any member with the specified URI. For now, childUri, referenceUri, memberUri, and filter are mutually exclusive.
     * @param {string} [acceptLanguage] Enumerates the languages that the client prefers to use for the response. This can be used to provide localized data where available.
     * @param {string} [acceptItem] If provided, this should be an alternative media type that the service recognizes. If the media type is not one that the service can provide, a 406 response is returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFolders: async (
      start?: number,
      limit?: number,
      filter?: string,
      sortBy?: string,
      childUri?: string,
      referenceUri?: string,
      memberUri?: string,
      acceptLanguage?: string,
      acceptItem?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/folders`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (filter !== undefined) {
        localVarQueryParameter["filter"] = filter;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter["sortBy"] = sortBy;
      }

      if (childUri !== undefined) {
        localVarQueryParameter["childUri"] = childUri;
      }

      if (referenceUri !== undefined) {
        localVarQueryParameter["referenceUri"] = referenceUri;
      }

      if (memberUri !== undefined) {
        localVarQueryParameter["memberUri"] = memberUri;
      }

      if (acceptLanguage != null) {
        localVarHeaderParameter["Accept-Language"] = String(acceptLanguage);
      }

      if (acceptItem != null) {
        localVarHeaderParameter["Accept-Item"] = String(acceptItem);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of root folders. Standard paging, filtering, and sorting options are provided.
     * @summary Get a list of root folders
     * @param {number} [start] 0-based offset of first folder to return. The default value is 0.
     * @param {number} [limit] Maximum number of folders to return. The default value is 20.
     * @param {string} [filter] Filter criteria for returned folders. See [Filtering in REST APIs](https://developer.sas.com/apis/rest/Topics/#filters). &lt;br&gt;Any member of the Folder object can be used to filter the results: id, name, description, createdBy, modifiedBy, properties, folderType, or parent. Date fields currently cannot be used to filter results.
     * @param {string} [sortBy] Sort returned folder. See [Sorting in REST APIs](https://developer.sas.com/apis/rest/Topics/#sorting).&lt;br&gt; The default sort order is name:ascending. Other valid sorting options are &lt;li&gt;&lt;code&gt;added&lt;/code&gt; the timestamp when the item was added to the folder&lt;/li&gt; &lt;li&gt;&lt;code&gt;name&lt;/code&gt; the folder name &lt;/ul&gt;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRootFolders: async (
      start?: number,
      limit?: number,
      filter?: string,
      sortBy?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/rootFolders`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (filter !== undefined) {
        localVarQueryParameter["filter"] = filter;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter["sortBy"] = sortBy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns the specified folder.
     * @summary Get a folder
     * @param {string} folderId The identifier of a specific folder or one of the delegate strings @myFolder, @appDataFolder, @myHistory, @myFavorites, or @public.
     * @param {string} [acceptLanguage] Enumerates the languages that the client prefers to use for the response. This can be used to provide localized data where available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForFolder: async (
      folderId: string,
      acceptLanguage?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'folderId' is not null or undefined
      assertParamExists("headersForFolder", "folderId", folderId);
      const localVarPath = `/folders/{folderId}`.replace(
        `{${"folderId"}}`,
        encodeURIComponent(String(folderId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage != null) {
        localVarHeaderParameter["Accept-Language"] = String(acceptLanguage);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates the provided fields of a folder. The client can provide a sparsely populated object, and only the non-null fields contribute to the updates. A body such as { \"name\": \"NewFolderName\" } causes the folder to have its name changed, but no other field is affected. The full resulting object is returned in the response.
     * @summary Make a partial update to a folder
     * @param {string} folderId The identifier of a specific folder, or of one of the delegate strings @myFolder, @appDataFolder, @myHistory, @myFavorites, or @public.
     * @param {string} [ifMatch] The ETag that was returned from a GET, POST, or PUT of this folder.
     * @param {string} [ifUnmodifiedSince] The value of the lastModified date of the folder. If the folder has been updated since this time, the update fails.
     * @param {FolderIn} [folderIn] Folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchFolder: async (
      folderId: string,
      ifMatch?: string,
      ifUnmodifiedSince?: string,
      folderIn?: FolderIn,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'folderId' is not null or undefined
      assertParamExists("patchFolder", "folderId", folderId);
      const localVarPath = `/folders/{folderId}`.replace(
        `{${"folderId"}}`,
        encodeURIComponent(String(folderId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (ifMatch != null) {
        localVarHeaderParameter["If-Match"] = String(ifMatch);
      }

      if (ifUnmodifiedSince != null) {
        localVarHeaderParameter["If-Unmodified-Since"] =
          String(ifUnmodifiedSince);
      }

      localVarHeaderParameter["Content-Type"] =
        "application/vnd.sas.content.folder+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        folderIn,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Move the child member for the resource specified by childUri to the folder specified by parentFolderUri.
     * @summary Move the child member for a resource to a folder specified by the parentFolderUri
     * @param {string} [childUri] The URI of a resource whose parent folder is to be changed.
     * @param {string} [parentFolderUri] The URI of the target folder to move the resource to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchMoveFolderItem: async (
      childUri?: string,
      parentFolderUri?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/folders/@item`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (childUri !== undefined) {
        localVarQueryParameter["childUri"] = childUri;
      }

      if (parentFolderUri !== undefined) {
        localVarQueryParameter["parentFolderUri"] = parentFolderUri;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Replaces an existing folder.
     * @summary Update a folder
     * @param {string} folderId The identifier of a specific folder, or of one of the delegate strings @myFolder, @appDataFolder, @myHistory, @myFavorites, or @public.
     * @param {string} [ifMatch] The ETag that was returned from a GET, POST, or PUT of this folder.
     * @param {string} [ifUnmodifiedSince] The value of the lastModified date of the folder. If the folder has been updated since this time, the update fails.
     * @param {FolderIn} [folderIn] Folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFolder: async (
      folderId: string,
      ifMatch?: string,
      ifUnmodifiedSince?: string,
      folderIn?: FolderIn,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'folderId' is not null or undefined
      assertParamExists("updateFolder", "folderId", folderId);
      const localVarPath = `/folders/{folderId}`.replace(
        `{${"folderId"}}`,
        encodeURIComponent(String(folderId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (ifMatch != null) {
        localVarHeaderParameter["If-Match"] = String(ifMatch);
      }

      if (ifUnmodifiedSince != null) {
        localVarHeaderParameter["If-Unmodified-Since"] =
          String(ifUnmodifiedSince);
      }

      localVarHeaderParameter["Content-Type"] =
        "application/vnd.sas.content.folder+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        folderIn,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FolderApi - functional programming interface
 * @export
 */
export const FolderApi = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FolderApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new empty folder. Members can be added to the folder using the `/folders/{folderId}/members` endpoint. This service maintains name uniqueness at any given level in the folder structure. In other words, if you try to create a root folder named \"newRootFolder\", and a root folder with that name exists, the operation fails with a 409 status. If you try to create a subfolder using the `?parentFolderUri` parameter, and the parent already has a subfolder with the same name, the operation fails with a 409 status.
     * @summary Create a new folder
     * @param {FolderApiCreateFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createFolder(
      requestParameters: FolderApiCreateFolderRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Folder>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createFolder(
        requestParameters.parentFolderUri,
        requestParameters.folderIn,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * The specified folder is deleted. If the folder is not empty, a recursive option can be specified to indicate a recursive delete. If the folder is not empty and no recursive option is present, an error response is returned. Any non-folder content will not be deleted.
     * @summary Delete a folder
     * @param {FolderApiDeleteFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFolder(
      requestParameters: FolderApiDeleteFolderRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFolder(
        requestParameters.folderId,
        requestParameters.recursive,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Find an object, if it exists, by path. The client provides an ordered list of parent folder names, the object name, and the object content type.
     * @summary Find an object by path
     * @param {FolderApiFindByPathRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findByPath(
      requestParameters: FolderApiFindByPathRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Summary>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.findByPath(
        requestParameters.path,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns the folders for the given set of delegate names, or all delegate folders if no names are provided.
     * @summary Get the folders for a given set of delegate names
     * @param {FolderApiGetDelegateFoldersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDelegateFolders(
      requestParameters: FolderApiGetDelegateFoldersRequest = {},
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<FolderCollection>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDelegateFolders(
          requestParameters.name,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns the specified folder.
     * @summary Get a folder
     * @param {FolderApiGetFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFolder(
      requestParameters: FolderApiGetFolderRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Folder>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFolder(
        requestParameters.folderId,
        requestParameters.acceptLanguage,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Get a folder with a resource wildcard. Either a path or a child URI is required. The result must be exactly one matching folder. If the childUri parameter is provided, the parent folder of the member with the matching URI is returned, if it exists. If the path is provided, it must be a slash-delimited path to the desired folder.
     * @summary Get a folder with a path or a child URI
     * @param {FolderApiGetFolderItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFolderItem(
      requestParameters: FolderApiGetFolderItemRequest = {},
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Folder>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderItem(
        requestParameters.childUri,
        requestParameters.path,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns a list of folders. Standard paging, filtering, and sorting options are provided.
     * @summary Get a list of folders
     * @param {FolderApiGetFoldersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFolders(
      requestParameters: FolderApiGetFoldersRequest = {},
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<FolderCollection>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFolders(
        requestParameters.start,
        requestParameters.limit,
        requestParameters.filter,
        requestParameters.sortBy,
        requestParameters.childUri,
        requestParameters.referenceUri,
        requestParameters.memberUri,
        requestParameters.acceptLanguage,
        requestParameters.acceptItem,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns a list of root folders. Standard paging, filtering, and sorting options are provided.
     * @summary Get a list of root folders
     * @param {FolderApiGetRootFoldersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRootFolders(
      requestParameters: FolderApiGetRootFoldersRequest = {},
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<FolderCollection>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRootFolders(
        requestParameters.start,
        requestParameters.limit,
        requestParameters.filter,
        requestParameters.sortBy,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns the specified folder.
     * @summary Get a folder
     * @param {FolderApiHeadersForFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForFolder(
      requestParameters: FolderApiHeadersForFolderRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForFolder(
          requestParameters.folderId,
          requestParameters.acceptLanguage,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Updates the provided fields of a folder. The client can provide a sparsely populated object, and only the non-null fields contribute to the updates. A body such as { \"name\": \"NewFolderName\" } causes the folder to have its name changed, but no other field is affected. The full resulting object is returned in the response.
     * @summary Make a partial update to a folder
     * @param {FolderApiPatchFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchFolder(
      requestParameters: FolderApiPatchFolderRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Folder>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.patchFolder(
        requestParameters.folderId,
        requestParameters.ifMatch,
        requestParameters.ifUnmodifiedSince,
        requestParameters.folderIn,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Move the child member for the resource specified by childUri to the folder specified by parentFolderUri.
     * @summary Move the child member for a resource to a folder specified by the parentFolderUri
     * @param {FolderApiPatchMoveFolderItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchMoveFolderItem(
      requestParameters: FolderApiPatchMoveFolderItemRequest = {},
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Folder>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.patchMoveFolderItem(
          requestParameters.childUri,
          requestParameters.parentFolderUri,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Replaces an existing folder.
     * @summary Update a folder
     * @param {FolderApiUpdateFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateFolder(
      requestParameters: FolderApiUpdateFolderRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Folder>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateFolder(
        requestParameters.folderId,
        requestParameters.ifMatch,
        requestParameters.ifUnmodifiedSince,
        requestParameters.folderIn,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },
  };
};

/**
 * Request parameters for createFolder operation in FolderApi.
 * @export
 * @interface FolderApiCreateFolderRequest
 */
export interface FolderApiCreateFolderRequest {
  /**
   * URI of folder to add new folder as a child. This parameter is required. An explicit value of \&quot;none\&quot; indicates that the client wants to create a root folder.
   * @type {string}
   * @memberof FolderApiCreateFolder
   */
  readonly parentFolderUri: string;

  /**
   * Folder
   * @type {FolderIn}
   * @memberof FolderApiCreateFolder
   */
  readonly folderIn?: FolderIn;
}

/**
 * Request parameters for deleteFolder operation in FolderApi.
 * @export
 * @interface FolderApiDeleteFolderRequest
 */
export interface FolderApiDeleteFolderRequest {
  /**
   * The identifier of a specific folder or one of the delegate strings @myFolder, @appDataFolder, @myHistory, @myFavorites, or @public.
   * @type {string}
   * @memberof FolderApiDeleteFolder
   */
  readonly folderId: string;

  /**
   * do a recursive delete of the folder
   * @type {boolean}
   * @memberof FolderApiDeleteFolder
   */
  readonly recursive?: boolean;
}

/**
 * Request parameters for findByPath operation in FolderApi.
 * @export
 * @interface FolderApiFindByPathRequest
 */
export interface FolderApiFindByPathRequest {
  /**
   * The set of parent names, the object name, and the object content type.
   * @type {Path}
   * @memberof FolderApiFindByPath
   */
  readonly path: Path;
}

/**
 * Request parameters for getDelegateFolders operation in FolderApi.
 * @export
 * @interface FolderApiGetDelegateFoldersRequest
 */
export interface FolderApiGetDelegateFoldersRequest {
  /**
   * The name of the delegate (including the leading \&#39;@\&#39;) desired. Multiple values of the name parameter can be provided.
   * @type {string}
   * @memberof FolderApiGetDelegateFolders
   */
  readonly name?: string;
}

/**
 * Request parameters for getFolder operation in FolderApi.
 * @export
 * @interface FolderApiGetFolderRequest
 */
export interface FolderApiGetFolderRequest {
  /**
   * The identifier of a specific folder or one of the delegate strings @myFolder, @appDataFolder, @myHistory, @myFavorites, or @public.
   * @type {string}
   * @memberof FolderApiGetFolder
   */
  readonly folderId: string;

  /**
   * Enumerates the languages that the client prefers to use for the response. This can be used to provide localized data where available.
   * @type {string}
   * @memberof FolderApiGetFolder
   */
  readonly acceptLanguage?: string;
}

/**
 * Request parameters for getFolderItem operation in FolderApi.
 * @export
 * @interface FolderApiGetFolderItemRequest
 */
export interface FolderApiGetFolderItemRequest {
  /**
   * The URI of a resource whose parent folder you want to return. This can be a folder or non-folder resource.
   * @type {string}
   * @memberof FolderApiGetFolderItem
   */
  readonly childUri?: string;

  /**
   * The slash-delimited path to a folder. For example, &#x60;/root/child/grandchild/greatgrandchild&#x60; would return the folder greatgrandchild.
   * @type {string}
   * @memberof FolderApiGetFolderItem
   */
  readonly path?: string;
}

/**
 * Request parameters for getFolders operation in FolderApi.
 * @export
 * @interface FolderApiGetFoldersRequest
 */
export interface FolderApiGetFoldersRequest {
  /**
   * 0-based offset of first folder to return. The default value is 0.
   * @type {number}
   * @memberof FolderApiGetFolders
   */
  readonly start?: number;

  /**
   * Maximum number of folders to return. The default value is 20.
   * @type {number}
   * @memberof FolderApiGetFolders
   */
  readonly limit?: number;

  /**
   * Filter criteria for returned folders. See [Filtering in REST APIs](https://developer.sas.com/apis/rest/Topics/#filters). &lt;br&gt;Any member of the Folder object can be used to filter the results: id, name, description, createdBy, modifiedBy, properties, folderType, or parent. Date fields currently cannot be used to filter results. &lt;br&gt;Sample queries&lt;br&gt; &lt;ul&gt; &lt;li&gt;Get Root Folders: &#x60;/folders?filter&#x3D;isNull(parent)&#x60;&lt;/li&gt; &lt;li&gt;Get folders by name: &#x60;/folders?filter&#x3D;contains(name, \&#39;Sample\&#39;)&#x60;&lt;/li&gt; &lt;li&gt;Get folders by folderType: &#x60;/folders?filter&#x3D;in(folderType, \&#39;history\&#39;, \&#39;favorites\&#39;)&#x60;&lt;/li&gt; &lt;/ul&gt;
   * @type {string}
   * @memberof FolderApiGetFolders
   */
  readonly filter?: string;

  /**
   * Sort returned folder. See [Sorting in REST APIs](https://developer.sas.com/apis/rest/Topics/#sorting).&lt;br&gt; The default sort order is name:ascending. Other valid sorting options are &lt;ul&gt;&lt;li&gt;&lt;code&gt;orderNum&lt;/code&gt; the order specified by the user&lt;/li&gt; &lt;li&gt;&lt;code&gt;added&lt;/code&gt; the timestamp when the item was added to the folder&lt;/li&gt; &lt;li&gt;&lt;code&gt;name&lt;/code&gt; the folder name &lt;/ul&gt;
   * @type {string}
   * @memberof FolderApiGetFolders
   */
  readonly sortBy?: string;

  /**
   * Return only folders containing a child member with the specified URI. For now, childUri, referenceUri, memberUri, and filter are mutually exclusive. The childUri has special semantics, because it should return only a single item. The URL form &#x60;/folders/.?childUri&#x3D;{resourceUri}&#x60; can be used to return a single item.
   * @type {string}
   * @memberof FolderApiGetFolders
   */
  readonly childUri?: string;

  /**
   * Return only folders containing a reference member with the specified URI. For now, childUri, referenceUri, memberUri, and filter are mutually exclusive.
   * @type {string}
   * @memberof FolderApiGetFolders
   */
  readonly referenceUri?: string;

  /**
   * Return only folders containing any member with the specified URI. For now, childUri, referenceUri, memberUri, and filter are mutually exclusive.
   * @type {string}
   * @memberof FolderApiGetFolders
   */
  readonly memberUri?: string;

  /**
   * Enumerates the languages that the client prefers to use for the response. This can be used to provide localized data where available.
   * @type {string}
   * @memberof FolderApiGetFolders
   */
  readonly acceptLanguage?: string;

  /**
   * If provided, this should be an alternative media type that the service recognizes. If the media type is not one that the service can provide, a 406 response is returned.
   * @type {string}
   * @memberof FolderApiGetFolders
   */
  readonly acceptItem?: string;
}

/**
 * Request parameters for getRootFolders operation in FolderApi.
 * @export
 * @interface FolderApiGetRootFoldersRequest
 */
export interface FolderApiGetRootFoldersRequest {
  /**
   * 0-based offset of first folder to return. The default value is 0.
   * @type {number}
   * @memberof FolderApiGetRootFolders
   */
  readonly start?: number;

  /**
   * Maximum number of folders to return. The default value is 20.
   * @type {number}
   * @memberof FolderApiGetRootFolders
   */
  readonly limit?: number;

  /**
   * Filter criteria for returned folders. See [Filtering in REST APIs](https://developer.sas.com/apis/rest/Topics/#filters). &lt;br&gt;Any member of the Folder object can be used to filter the results: id, name, description, createdBy, modifiedBy, properties, folderType, or parent. Date fields currently cannot be used to filter results.
   * @type {string}
   * @memberof FolderApiGetRootFolders
   */
  readonly filter?: string;

  /**
   * Sort returned folder. See [Sorting in REST APIs](https://developer.sas.com/apis/rest/Topics/#sorting).&lt;br&gt; The default sort order is name:ascending. Other valid sorting options are &lt;li&gt;&lt;code&gt;added&lt;/code&gt; the timestamp when the item was added to the folder&lt;/li&gt; &lt;li&gt;&lt;code&gt;name&lt;/code&gt; the folder name &lt;/ul&gt;
   * @type {string}
   * @memberof FolderApiGetRootFolders
   */
  readonly sortBy?: string;
}

/**
 * Request parameters for headersForFolder operation in FolderApi.
 * @export
 * @interface FolderApiHeadersForFolderRequest
 */
export interface FolderApiHeadersForFolderRequest {
  /**
   * The identifier of a specific folder or one of the delegate strings @myFolder, @appDataFolder, @myHistory, @myFavorites, or @public.
   * @type {string}
   * @memberof FolderApiHeadersForFolder
   */
  readonly folderId: string;

  /**
   * Enumerates the languages that the client prefers to use for the response. This can be used to provide localized data where available.
   * @type {string}
   * @memberof FolderApiHeadersForFolder
   */
  readonly acceptLanguage?: string;
}

/**
 * Request parameters for patchFolder operation in FolderApi.
 * @export
 * @interface FolderApiPatchFolderRequest
 */
export interface FolderApiPatchFolderRequest {
  /**
   * The identifier of a specific folder, or of one of the delegate strings @myFolder, @appDataFolder, @myHistory, @myFavorites, or @public.
   * @type {string}
   * @memberof FolderApiPatchFolder
   */
  readonly folderId: string;

  /**
   * The ETag that was returned from a GET, POST, or PUT of this folder.
   * @type {string}
   * @memberof FolderApiPatchFolder
   */
  readonly ifMatch?: string;

  /**
   * The value of the lastModified date of the folder. If the folder has been updated since this time, the update fails.
   * @type {string}
   * @memberof FolderApiPatchFolder
   */
  readonly ifUnmodifiedSince?: string;

  /**
   * Folder
   * @type {FolderIn}
   * @memberof FolderApiPatchFolder
   */
  readonly folderIn?: FolderIn;
}

/**
 * Request parameters for patchMoveFolderItem operation in FolderApi.
 * @export
 * @interface FolderApiPatchMoveFolderItemRequest
 */
export interface FolderApiPatchMoveFolderItemRequest {
  /**
   * The URI of a resource whose parent folder is to be changed.
   * @type {string}
   * @memberof FolderApiPatchMoveFolderItem
   */
  readonly childUri?: string;

  /**
   * The URI of the target folder to move the resource to.
   * @type {string}
   * @memberof FolderApiPatchMoveFolderItem
   */
  readonly parentFolderUri?: string;
}

/**
 * Request parameters for updateFolder operation in FolderApi.
 * @export
 * @interface FolderApiUpdateFolderRequest
 */
export interface FolderApiUpdateFolderRequest {
  /**
   * The identifier of a specific folder, or of one of the delegate strings @myFolder, @appDataFolder, @myHistory, @myFavorites, or @public.
   * @type {string}
   * @memberof FolderApiUpdateFolder
   */
  readonly folderId: string;

  /**
   * The ETag that was returned from a GET, POST, or PUT of this folder.
   * @type {string}
   * @memberof FolderApiUpdateFolder
   */
  readonly ifMatch?: string;

  /**
   * The value of the lastModified date of the folder. If the folder has been updated since this time, the update fails.
   * @type {string}
   * @memberof FolderApiUpdateFolder
   */
  readonly ifUnmodifiedSince?: string;

  /**
   * Folder
   * @type {FolderIn}
   * @memberof FolderApiUpdateFolder
   */
  readonly folderIn?: FolderIn;
}

/**
 * MemberApi - axios parameter creator
 * @export
 */
export const MemberApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Adds a new member to the folder. If the member type is \'child\' and the object referenced is already a member of any folder (including the specified parent), this operation fails with a 409 status (conflict). If the object being added is a folder, this method checks that the name is unique (among other members that are of the same type). If a name collision occurs, a 409 status is returned.
     * @summary Add a member to a folder
     * @param {string} folderId The identifier of a specific folder, or of one of the delegate strings @myFolder, @appDataFolder, @myHistory, @myFavorites, or @public.
     * @param {boolean} [abortOnMetadataFailure] If true, the member creation is aborted if the GET to retrieve the member metadata fails. If false, the member creation succeeds regardless of the metadata retrieval status. The default value is false.
     * @param {boolean} [forceMove] If true, if this is a creation of a child member and if the URI in the member already exists in another folder, the member is moved to the requested folder. If it is already a member of the requested folder, the request succeeds. The default value is false.
     * @param {MemberIn} [memberIn] Member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFolderMember: async (
      folderId: string,
      abortOnMetadataFailure?: boolean,
      forceMove?: boolean,
      memberIn?: MemberIn,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'folderId' is not null or undefined
      assertParamExists("createFolderMember", "folderId", folderId);
      const localVarPath = `/folders/{folderId}/members`.replace(
        `{${"folderId"}}`,
        encodeURIComponent(String(folderId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (abortOnMetadataFailure !== undefined) {
        localVarQueryParameter["abortOnMetadataFailure"] =
          abortOnMetadataFailure;
      }

      if (forceMove !== undefined) {
        localVarQueryParameter["forceMove"] = forceMove;
      }

      localVarHeaderParameter["Content-Type"] =
        "application/vnd.sas.content.folder.member+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        memberIn,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates the modification date for a history member. If the object URI exists as a reference in the history folder, the information including the added field is updated. If it does not exist, a new member is added, and an eviction is performed if the folder is already at the maximum members threshold.
     * @summary Update the modification date for a history member
     * @param {string} folderId The identifier of a specific history folder, or the delegate string: @myHistory.
     * @param {boolean} [abortOnMetadataFailure] If true, if the GET to retrieve the member metadata fails, abort the member creation. If false, the member creation succeeds regardless of the metadata retrieval status. The default value is false.
     * @param {MemberIn} [memberIn] Member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createHistory: async (
      folderId: string,
      abortOnMetadataFailure?: boolean,
      memberIn?: MemberIn,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'folderId' is not null or undefined
      assertParamExists("createHistory", "folderId", folderId);
      const localVarPath = `/folders/{folderId}/histories`.replace(
        `{${"folderId"}}`,
        encodeURIComponent(String(folderId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (abortOnMetadataFailure !== undefined) {
        localVarQueryParameter["abortOnMetadataFailure"] =
          abortOnMetadataFailure;
      }

      localVarHeaderParameter["Content-Type"] =
        "application/vnd.sas.content.folder.member+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        memberIn,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Removes the specified member from the folder. <b>This does not delete the target resource.</b> The proper way to delete a resource is to use the resource\'s persistence service to delete it. Using that service generates an event that causes the folders service to clean up any members that have that target resource\'s URI.
     * @summary Remove a member from a folder
     * @param {string} folderId The identifier of a specific folder, or of one of the delegate strings @myFolder, @appDataFolder, @myHistory, @myFavorites, or @public.
     * @param {string} memberId Member id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFolderMember: async (
      folderId: string,
      memberId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'folderId' is not null or undefined
      assertParamExists("deleteFolderMember", "folderId", folderId);
      // verify required parameter 'memberId' is not null or undefined
      assertParamExists("deleteFolderMember", "memberId", memberId);
      const localVarPath = `/folders/{folderId}/members/{memberId}`
        .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
        .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns the specified member.
     * @summary Get a folder member
     * @param {string} folderId The identifier of a specific folder, or of one of the delegate strings @myFolder, @appDataFolder, @myHistory, @myFavorites, or @public.
     * @param {string} memberId Member id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFolderMember: async (
      folderId: string,
      memberId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'folderId' is not null or undefined
      assertParamExists("getFolderMember", "folderId", folderId);
      // verify required parameter 'memberId' is not null or undefined
      assertParamExists("getFolderMember", "memberId", memberId);
      const localVarPath = `/folders/{folderId}/members/{memberId}`
        .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
        .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of folder members. Standard paging, filtering, and sorting options are available. The media type of the returned collection items is application/vnd.sas.content.folder.member. Default sorting for this collection is name:ascending, unless the folder is of the history folder type. Default sorting for history folders is added:descending, which orders the elements starting with the most recently added.
     * @summary Get a list of folder members
     * @param {string} folderId The identifier of a specific folder, or of one of the delegate strings @myFolder, @appDataFolder, @myHistory, @myFavorites, or @public.
     * @param {number} [start] Offset of first member to return. The default value is 0.
     * @param {number} [limit] Maximum number of members to return. The default value is 20.
     * @param {string} [filter] Filter criteria for returned members. See [Filtering in REST APIs](https://developer.sas.com/apis/rest/Topics/#filters). For example, you can filter for a member with a given name as a way to test if a folder already has a member with that name: &lt;code&gt;?filter&#x3D;eq(name, \&#39;bobsyouruncle\&#39;)&lt;/code&gt;
     * @param {string} [sortBy] Sort returned collection of members. See [Sorting in REST APIs](https://developer.sas.com/apis/rest/Topics/#sorting). The member collection can be sorted by folders first by using sortBy&#x3D;eq(contentType,\&#39;folder\&#39;):descending Use :ascending to soft by folders last. Specifying sortBy&#x3D;eq(contentType,\&#39;folder\&#39;):descending,name:ascending,type:ascending sorts by folders first, then by name, then by type.
     * @param {boolean} [recursive] If true, the members of the requested folder, plus all of its descendants, are returned in a flat list (no order is guaranteed). Reference members that refer to folders are not followed unless the followReferences parameter is true. The default value of this parameter is false.
     * @param {boolean} [followReferences] If true, references to other folders are followed when returning the recursive list of members. If recursive is false, then the value of this parameter is meaningless. The default value of this parameter is false.
     * @param {string} [acceptLanguage] Enumerates the languages that the client prefers to use for the response. This can be used to provide localized data where available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFolderMembers: async (
      folderId: string,
      start?: number,
      limit?: number,
      filter?: string,
      sortBy?: string,
      recursive?: boolean,
      followReferences?: boolean,
      acceptLanguage?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'folderId' is not null or undefined
      assertParamExists("getFolderMembers", "folderId", folderId);
      const localVarPath = `/folders/{folderId}/members`.replace(
        `{${"folderId"}}`,
        encodeURIComponent(String(folderId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (filter !== undefined) {
        localVarQueryParameter["filter"] = filter;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter["sortBy"] = sortBy;
      }

      if (recursive !== undefined) {
        localVarQueryParameter["recursive"] = recursive;
      }

      if (followReferences !== undefined) {
        localVarQueryParameter["followReferences"] = followReferences;
      }

      if (acceptLanguage != null) {
        localVarHeaderParameter["Accept-Language"] = String(acceptLanguage);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns the specified member.
     * @summary Get a folder member
     * @param {string} folderId The identifier of a specific folder, or of one of the delegate strings @myFolder, @appDataFolder, @myHistory, @myFavorites, or @public.
     * @param {string} memberId Member id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForFolderMember: async (
      folderId: string,
      memberId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'folderId' is not null or undefined
      assertParamExists("headersForFolderMember", "folderId", folderId);
      // verify required parameter 'memberId' is not null or undefined
      assertParamExists("headersForFolderMember", "memberId", memberId);
      const localVarPath = `/folders/{folderId}/members/{memberId}`
        .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
        .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of folder members. Standard paging, filtering, and sorting options are available. The media type of the returned collection items is application/vnd.sas.content.folder.member. Default sorting for this collection is name:ascending, unless the folder is of the history folder type. Default sorting for history folders is added:descending, which orders the elements starting with the most recently added.
     * @summary Get a list of folder members
     * @param {string} folderId The identifier of a specific folder, or of one of the delegate strings @myFolder, @appDataFolder, @myHistory, @myFavorites, or @public.
     * @param {number} [start] Offset of first member to return. The default value is 0.
     * @param {number} [limit] Maximum number of members to return. The default value is 20.
     * @param {string} [filter] Filter criteria for returned members. See [Filtering in REST APIs](https://developer.sas.com/apis/rest/Topics/#filters). For example, you can filter for a member with a given name as a way to test if a folder already has a member with that name: &lt;code&gt;?filter&#x3D;eq(name, \&#39;bobsyouruncle\&#39;)&lt;/code&gt;
     * @param {string} [sortBy] Sort returned collection of members. See [Sorting in REST APIs](https://developer.sas.com/apis/rest/Topics/#sorting). The member collection can be sorted by folders first by using sortBy&#x3D;eq(contentType,\&#39;folder\&#39;):descending Use :ascending to soft by folders last. Specifying sortBy&#x3D;eq(contentType,\&#39;folder\&#39;):descending,name:ascending,type:ascending sorts by folders first, then by name, then by type.
     * @param {boolean} [recursive] If true, the members of the requested folder, plus all of its descendants, are returned in a flat list (no order is guaranteed). Reference members that refer to folders are not followed unless the followReferences parameter is true. The default value of this parameter is false.
     * @param {boolean} [followReferences] If true, references to other folders are followed when returning the recursive list of members. If recursive is false, then the value of this parameter is meaningless. The default value of this parameter is false.
     * @param {string} [acceptLanguage] Enumerates the languages that the client prefers to use for the response. This can be used to provide localized data where available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    headersForFolderMembers: async (
      folderId: string,
      start?: number,
      limit?: number,
      filter?: string,
      sortBy?: string,
      recursive?: boolean,
      followReferences?: boolean,
      acceptLanguage?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'folderId' is not null or undefined
      assertParamExists("headersForFolderMembers", "folderId", folderId);
      const localVarPath = `/folders/{folderId}/members`.replace(
        `{${"folderId"}}`,
        encodeURIComponent(String(folderId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (filter !== undefined) {
        localVarQueryParameter["filter"] = filter;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter["sortBy"] = sortBy;
      }

      if (recursive !== undefined) {
        localVarQueryParameter["recursive"] = recursive;
      }

      if (followReferences !== undefined) {
        localVarQueryParameter["followReferences"] = followReferences;
      }

      if (acceptLanguage != null) {
        localVarHeaderParameter["Accept-Language"] = String(acceptLanguage);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates the provided fields of a member. The client can provide a sparsely populated object, and only the non-null fields contribute to the updates. So, a body like { \"name\": \"NewMemberName\" } causes the member to have its name changed, but no other field is affected. The full resulting object is returned in the response.
     * @summary Make a partial update to a folder member
     * @param {string} folderId The identifier of a specific folder, or of one of the delegate strings @myFolder, @appDataFolder, @myHistory, @myFavorites, or @public.
     * @param {string} memberId Member id.
     * @param {string} [ifMatch] The ETag that was returned from a GET, POST, or PUT of this folder.
     * @param {string} [ifUnmodifiedSince] The value of the lastModified date of the folder. If the folder has been updated since this time, the update fails.
     * @param {MemberIn} [memberIn] Member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchFolderMember: async (
      folderId: string,
      memberId: string,
      ifMatch?: string,
      ifUnmodifiedSince?: string,
      memberIn?: MemberIn,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'folderId' is not null or undefined
      assertParamExists("patchFolderMember", "folderId", folderId);
      // verify required parameter 'memberId' is not null or undefined
      assertParamExists("patchFolderMember", "memberId", memberId);
      const localVarPath = `/folders/{folderId}/members/{memberId}`
        .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
        .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (ifMatch != null) {
        localVarHeaderParameter["If-Match"] = String(ifMatch);
      }

      if (ifUnmodifiedSince != null) {
        localVarHeaderParameter["If-Unmodified-Since"] =
          String(ifUnmodifiedSince);
      }

      localVarHeaderParameter["Content-Type"] =
        "application/vnd.sas.content.folder.member+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        memberIn,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Replaces an existing folder member. Changing the parentUri affects a move operation. Neither the URI or the type of the member can be changed.
     * @summary Update a folder member
     * @param {string} folderId The identifier of a specific folder, or of one of the delegate strings @myFolder, @appDataFolder, @myHistory, @myFavorites, or @public.
     * @param {string} memberId Member id.
     * @param {string} [ifMatch] The ETag that was returned from a GET, POST, or PUT of this folder.
     * @param {string} [ifUnmodifiedSince] The value of the lastModified date of the folder. If the folder has been updated since this time, the update fails.
     * @param {MemberIn} [memberIn] Member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFolderMember: async (
      folderId: string,
      memberId: string,
      ifMatch?: string,
      ifUnmodifiedSince?: string,
      memberIn?: MemberIn,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'folderId' is not null or undefined
      assertParamExists("updateFolderMember", "folderId", folderId);
      // verify required parameter 'memberId' is not null or undefined
      assertParamExists("updateFolderMember", "memberId", memberId);
      const localVarPath = `/folders/{folderId}/members/{memberId}`
        .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
        .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (ifMatch != null) {
        localVarHeaderParameter["If-Match"] = String(ifMatch);
      }

      if (ifUnmodifiedSince != null) {
        localVarHeaderParameter["If-Unmodified-Since"] =
          String(ifUnmodifiedSince);
      }

      localVarHeaderParameter["Content-Type"] =
        "application/vnd.sas.content.folder.member+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        memberIn,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by a client to test whether creating or renaming a member would create a naming conflict before actually attempting the operation. When creating a new member, a memberId of @new indicates that the attempted operation would create a new member, where a folderId of @root is a placeholder representing the root level of the folder hierarchy. For example,<br> PUT /commons/validations/folders/@root/members/@new/name?value=TestFolder1&type=folder<br> would check if one could successfully create a root folder named TestFolder1 and respond appropriately.<br> PUT /commons/validations/folders/@myFolder/members/@new/name?value=TestReport1&type=report<br> would check whether a new member named TestReport1 of type report could be added to the user\'s My Folder.
     * @summary Validate that a member can be named or renamed to the given value without creating a conflict
     * @param {string} folderId The identifier of the folder whose members are to be checked. A value of @root indicates checking a root-level folder, and type must be folder.
     * @param {string} memberId If a rename is being attempted, the identifier of the member being renamed. If a new member is being created, the @new placeholder is used.
     * @param {string} value The name to be tested.
     * @param {string} type The type of the member to be tested. Members of the same type have to be named uniquely, so both the new name and type are required.
     * @param {string} [typeDefName] The Type definition name to test against. This must match exactly with the desired value. A null value is compared with null values in the repository.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateMemberName: async (
      folderId: string,
      memberId: string,
      value: string,
      type: string,
      typeDefName?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'folderId' is not null or undefined
      assertParamExists("validateMemberName", "folderId", folderId);
      // verify required parameter 'memberId' is not null or undefined
      assertParamExists("validateMemberName", "memberId", memberId);
      // verify required parameter 'value' is not null or undefined
      assertParamExists("validateMemberName", "value", value);
      // verify required parameter 'type' is not null or undefined
      assertParamExists("validateMemberName", "type", type);
      const localVarPath =
        `/commons/validations/folders/{folderId}/members/{memberId}/name`
          .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
          .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (value !== undefined) {
        localVarQueryParameter["value"] = value;
      }

      if (type !== undefined) {
        localVarQueryParameter["type"] = type;
      }

      if (typeDefName !== undefined) {
        localVarQueryParameter["typeDefName"] = typeDefName;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MemberApi - functional programming interface
 * @export
 */
export const MemberApi = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = MemberApiAxiosParamCreator(configuration);
  return {
    /**
     * Adds a new member to the folder. If the member type is \'child\' and the object referenced is already a member of any folder (including the specified parent), this operation fails with a 409 status (conflict). If the object being added is a folder, this method checks that the name is unique (among other members that are of the same type). If a name collision occurs, a 409 status is returned.
     * @summary Add a member to a folder
     * @param {MemberApiCreateFolderMemberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createFolderMember(
      requestParameters: MemberApiCreateFolderMemberRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Member>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createFolderMember(
          requestParameters.folderId,
          requestParameters.abortOnMetadataFailure,
          requestParameters.forceMove,
          requestParameters.memberIn,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Updates the modification date for a history member. If the object URI exists as a reference in the history folder, the information including the added field is updated. If it does not exist, a new member is added, and an eviction is performed if the folder is already at the maximum members threshold.
     * @summary Update the modification date for a history member
     * @param {MemberApiCreateHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createHistory(
      requestParameters: MemberApiCreateHistoryRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Member>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createHistory(
        requestParameters.folderId,
        requestParameters.abortOnMetadataFailure,
        requestParameters.memberIn,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Removes the specified member from the folder. <b>This does not delete the target resource.</b> The proper way to delete a resource is to use the resource\'s persistence service to delete it. Using that service generates an event that causes the folders service to clean up any members that have that target resource\'s URI.
     * @summary Remove a member from a folder
     * @param {MemberApiDeleteFolderMemberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFolderMember(
      requestParameters: MemberApiDeleteFolderMemberRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteFolderMember(
          requestParameters.folderId,
          requestParameters.memberId,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns the specified member.
     * @summary Get a folder member
     * @param {MemberApiGetFolderMemberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFolderMember(
      requestParameters: MemberApiGetFolderMemberRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Member>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderMember(
        requestParameters.folderId,
        requestParameters.memberId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns a list of folder members. Standard paging, filtering, and sorting options are available. The media type of the returned collection items is application/vnd.sas.content.folder.member. Default sorting for this collection is name:ascending, unless the folder is of the history folder type. Default sorting for history folders is added:descending, which orders the elements starting with the most recently added.
     * @summary Get a list of folder members
     * @param {MemberApiGetFolderMembersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFolderMembers(
      requestParameters: MemberApiGetFolderMembersRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<MemberCollection>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getFolderMembers(
          requestParameters.folderId,
          requestParameters.start,
          requestParameters.limit,
          requestParameters.filter,
          requestParameters.sortBy,
          requestParameters.recursive,
          requestParameters.followReferences,
          requestParameters.acceptLanguage,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns the specified member.
     * @summary Get a folder member
     * @param {MemberApiHeadersForFolderMemberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForFolderMember(
      requestParameters: MemberApiHeadersForFolderMemberRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForFolderMember(
          requestParameters.folderId,
          requestParameters.memberId,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns a list of folder members. Standard paging, filtering, and sorting options are available. The media type of the returned collection items is application/vnd.sas.content.folder.member. Default sorting for this collection is name:ascending, unless the folder is of the history folder type. Default sorting for history folders is added:descending, which orders the elements starting with the most recently added.
     * @summary Get a list of folder members
     * @param {MemberApiHeadersForFolderMembersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async headersForFolderMembers(
      requestParameters: MemberApiHeadersForFolderMembersRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.headersForFolderMembers(
          requestParameters.folderId,
          requestParameters.start,
          requestParameters.limit,
          requestParameters.filter,
          requestParameters.sortBy,
          requestParameters.recursive,
          requestParameters.followReferences,
          requestParameters.acceptLanguage,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Updates the provided fields of a member. The client can provide a sparsely populated object, and only the non-null fields contribute to the updates. So, a body like { \"name\": \"NewMemberName\" } causes the member to have its name changed, but no other field is affected. The full resulting object is returned in the response.
     * @summary Make a partial update to a folder member
     * @param {MemberApiPatchFolderMemberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchFolderMember(
      requestParameters: MemberApiPatchFolderMemberRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Member>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.patchFolderMember(
          requestParameters.folderId,
          requestParameters.memberId,
          requestParameters.ifMatch,
          requestParameters.ifUnmodifiedSince,
          requestParameters.memberIn,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Replaces an existing folder member. Changing the parentUri affects a move operation. Neither the URI or the type of the member can be changed.
     * @summary Update a folder member
     * @param {MemberApiUpdateFolderMemberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateFolderMember(
      requestParameters: MemberApiUpdateFolderMemberRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Member>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateFolderMember(
          requestParameters.folderId,
          requestParameters.memberId,
          requestParameters.ifMatch,
          requestParameters.ifUnmodifiedSince,
          requestParameters.memberIn,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * This endpoint can be used by a client to test whether creating or renaming a member would create a naming conflict before actually attempting the operation. When creating a new member, a memberId of @new indicates that the attempted operation would create a new member, where a folderId of @root is a placeholder representing the root level of the folder hierarchy. For example,<br> PUT /commons/validations/folders/@root/members/@new/name?value=TestFolder1&type=folder<br> would check if one could successfully create a root folder named TestFolder1 and respond appropriately.<br> PUT /commons/validations/folders/@myFolder/members/@new/name?value=TestReport1&type=report<br> would check whether a new member named TestReport1 of type report could be added to the user\'s My Folder.
     * @summary Validate that a member can be named or renamed to the given value without creating a conflict
     * @param {MemberApiValidateMemberNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async validateMemberName(
      requestParameters: MemberApiValidateMemberNameRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Validation>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.validateMemberName(
          requestParameters.folderId,
          requestParameters.memberId,
          requestParameters.value,
          requestParameters.type,
          requestParameters.typeDefName,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },
  };
};

/**
 * Request parameters for createFolderMember operation in MemberApi.
 * @export
 * @interface MemberApiCreateFolderMemberRequest
 */
export interface MemberApiCreateFolderMemberRequest {
  /**
   * The identifier of a specific folder, or of one of the delegate strings @myFolder, @appDataFolder, @myHistory, @myFavorites, or @public.
   * @type {string}
   * @memberof MemberApiCreateFolderMember
   */
  readonly folderId: string;

  /**
   * If true, the member creation is aborted if the GET to retrieve the member metadata fails. If false, the member creation succeeds regardless of the metadata retrieval status. The default value is false.
   * @type {boolean}
   * @memberof MemberApiCreateFolderMember
   */
  readonly abortOnMetadataFailure?: boolean;

  /**
   * If true, if this is a creation of a child member and if the URI in the member already exists in another folder, the member is moved to the requested folder. If it is already a member of the requested folder, the request succeeds. The default value is false.
   * @type {boolean}
   * @memberof MemberApiCreateFolderMember
   */
  readonly forceMove?: boolean;

  /**
   * Member
   * @type {MemberIn}
   * @memberof MemberApiCreateFolderMember
   */
  readonly memberIn?: MemberIn;
}

/**
 * Request parameters for createHistory operation in MemberApi.
 * @export
 * @interface MemberApiCreateHistoryRequest
 */
export interface MemberApiCreateHistoryRequest {
  /**
   * The identifier of a specific history folder, or the delegate string: @myHistory.
   * @type {string}
   * @memberof MemberApiCreateHistory
   */
  readonly folderId: string;

  /**
   * If true, if the GET to retrieve the member metadata fails, abort the member creation. If false, the member creation succeeds regardless of the metadata retrieval status. The default value is false.
   * @type {boolean}
   * @memberof MemberApiCreateHistory
   */
  readonly abortOnMetadataFailure?: boolean;

  /**
   * Member
   * @type {MemberIn}
   * @memberof MemberApiCreateHistory
   */
  readonly memberIn?: MemberIn;
}

/**
 * Request parameters for deleteFolderMember operation in MemberApi.
 * @export
 * @interface MemberApiDeleteFolderMemberRequest
 */
export interface MemberApiDeleteFolderMemberRequest {
  /**
   * The identifier of a specific folder, or of one of the delegate strings @myFolder, @appDataFolder, @myHistory, @myFavorites, or @public.
   * @type {string}
   * @memberof MemberApiDeleteFolderMember
   */
  readonly folderId: string;

  /**
   * Member id.
   * @type {string}
   * @memberof MemberApiDeleteFolderMember
   */
  readonly memberId: string;
}

/**
 * Request parameters for getFolderMember operation in MemberApi.
 * @export
 * @interface MemberApiGetFolderMemberRequest
 */
export interface MemberApiGetFolderMemberRequest {
  /**
   * The identifier of a specific folder, or of one of the delegate strings @myFolder, @appDataFolder, @myHistory, @myFavorites, or @public.
   * @type {string}
   * @memberof MemberApiGetFolderMember
   */
  readonly folderId: string;

  /**
   * Member id.
   * @type {string}
   * @memberof MemberApiGetFolderMember
   */
  readonly memberId: string;
}

/**
 * Request parameters for getFolderMembers operation in MemberApi.
 * @export
 * @interface MemberApiGetFolderMembersRequest
 */
export interface MemberApiGetFolderMembersRequest {
  /**
   * The identifier of a specific folder, or of one of the delegate strings @myFolder, @appDataFolder, @myHistory, @myFavorites, or @public.
   * @type {string}
   * @memberof MemberApiGetFolderMembers
   */
  readonly folderId: string;

  /**
   * Offset of first member to return. The default value is 0.
   * @type {number}
   * @memberof MemberApiGetFolderMembers
   */
  readonly start?: number;

  /**
   * Maximum number of members to return. The default value is 20.
   * @type {number}
   * @memberof MemberApiGetFolderMembers
   */
  readonly limit?: number;

  /**
   * Filter criteria for returned members. See [Filtering in REST APIs](https://developer.sas.com/apis/rest/Topics/#filters). For example, you can filter for a member with a given name as a way to test if a folder already has a member with that name: &lt;code&gt;?filter&#x3D;eq(name, \&#39;bobsyouruncle\&#39;)&lt;/code&gt;
   * @type {string}
   * @memberof MemberApiGetFolderMembers
   */
  readonly filter?: string;

  /**
   * Sort returned collection of members. See [Sorting in REST APIs](https://developer.sas.com/apis/rest/Topics/#sorting). The member collection can be sorted by folders first by using sortBy&#x3D;eq(contentType,\&#39;folder\&#39;):descending Use :ascending to soft by folders last. Specifying sortBy&#x3D;eq(contentType,\&#39;folder\&#39;):descending,name:ascending,type:ascending sorts by folders first, then by name, then by type.
   * @type {string}
   * @memberof MemberApiGetFolderMembers
   */
  readonly sortBy?: string;

  /**
   * If true, the members of the requested folder, plus all of its descendants, are returned in a flat list (no order is guaranteed). Reference members that refer to folders are not followed unless the followReferences parameter is true. The default value of this parameter is false.
   * @type {boolean}
   * @memberof MemberApiGetFolderMembers
   */
  readonly recursive?: boolean;

  /**
   * If true, references to other folders are followed when returning the recursive list of members. If recursive is false, then the value of this parameter is meaningless. The default value of this parameter is false.
   * @type {boolean}
   * @memberof MemberApiGetFolderMembers
   */
  readonly followReferences?: boolean;

  /**
   * Enumerates the languages that the client prefers to use for the response. This can be used to provide localized data where available.
   * @type {string}
   * @memberof MemberApiGetFolderMembers
   */
  readonly acceptLanguage?: string;
}

/**
 * Request parameters for headersForFolderMember operation in MemberApi.
 * @export
 * @interface MemberApiHeadersForFolderMemberRequest
 */
export interface MemberApiHeadersForFolderMemberRequest {
  /**
   * The identifier of a specific folder, or of one of the delegate strings @myFolder, @appDataFolder, @myHistory, @myFavorites, or @public.
   * @type {string}
   * @memberof MemberApiHeadersForFolderMember
   */
  readonly folderId: string;

  /**
   * Member id.
   * @type {string}
   * @memberof MemberApiHeadersForFolderMember
   */
  readonly memberId: string;
}

/**
 * Request parameters for headersForFolderMembers operation in MemberApi.
 * @export
 * @interface MemberApiHeadersForFolderMembersRequest
 */
export interface MemberApiHeadersForFolderMembersRequest {
  /**
   * The identifier of a specific folder, or of one of the delegate strings @myFolder, @appDataFolder, @myHistory, @myFavorites, or @public.
   * @type {string}
   * @memberof MemberApiHeadersForFolderMembers
   */
  readonly folderId: string;

  /**
   * Offset of first member to return. The default value is 0.
   * @type {number}
   * @memberof MemberApiHeadersForFolderMembers
   */
  readonly start?: number;

  /**
   * Maximum number of members to return. The default value is 20.
   * @type {number}
   * @memberof MemberApiHeadersForFolderMembers
   */
  readonly limit?: number;

  /**
   * Filter criteria for returned members. See [Filtering in REST APIs](https://developer.sas.com/apis/rest/Topics/#filters). For example, you can filter for a member with a given name as a way to test if a folder already has a member with that name: &lt;code&gt;?filter&#x3D;eq(name, \&#39;bobsyouruncle\&#39;)&lt;/code&gt;
   * @type {string}
   * @memberof MemberApiHeadersForFolderMembers
   */
  readonly filter?: string;

  /**
   * Sort returned collection of members. See [Sorting in REST APIs](https://developer.sas.com/apis/rest/Topics/#sorting). The member collection can be sorted by folders first by using sortBy&#x3D;eq(contentType,\&#39;folder\&#39;):descending Use :ascending to soft by folders last. Specifying sortBy&#x3D;eq(contentType,\&#39;folder\&#39;):descending,name:ascending,type:ascending sorts by folders first, then by name, then by type.
   * @type {string}
   * @memberof MemberApiHeadersForFolderMembers
   */
  readonly sortBy?: string;

  /**
   * If true, the members of the requested folder, plus all of its descendants, are returned in a flat list (no order is guaranteed). Reference members that refer to folders are not followed unless the followReferences parameter is true. The default value of this parameter is false.
   * @type {boolean}
   * @memberof MemberApiHeadersForFolderMembers
   */
  readonly recursive?: boolean;

  /**
   * If true, references to other folders are followed when returning the recursive list of members. If recursive is false, then the value of this parameter is meaningless. The default value of this parameter is false.
   * @type {boolean}
   * @memberof MemberApiHeadersForFolderMembers
   */
  readonly followReferences?: boolean;

  /**
   * Enumerates the languages that the client prefers to use for the response. This can be used to provide localized data where available.
   * @type {string}
   * @memberof MemberApiHeadersForFolderMembers
   */
  readonly acceptLanguage?: string;
}

/**
 * Request parameters for patchFolderMember operation in MemberApi.
 * @export
 * @interface MemberApiPatchFolderMemberRequest
 */
export interface MemberApiPatchFolderMemberRequest {
  /**
   * The identifier of a specific folder, or of one of the delegate strings @myFolder, @appDataFolder, @myHistory, @myFavorites, or @public.
   * @type {string}
   * @memberof MemberApiPatchFolderMember
   */
  readonly folderId: string;

  /**
   * Member id.
   * @type {string}
   * @memberof MemberApiPatchFolderMember
   */
  readonly memberId: string;

  /**
   * The ETag that was returned from a GET, POST, or PUT of this folder.
   * @type {string}
   * @memberof MemberApiPatchFolderMember
   */
  readonly ifMatch?: string;

  /**
   * The value of the lastModified date of the folder. If the folder has been updated since this time, the update fails.
   * @type {string}
   * @memberof MemberApiPatchFolderMember
   */
  readonly ifUnmodifiedSince?: string;

  /**
   * Member
   * @type {MemberIn}
   * @memberof MemberApiPatchFolderMember
   */
  readonly memberIn?: MemberIn;
}

/**
 * Request parameters for updateFolderMember operation in MemberApi.
 * @export
 * @interface MemberApiUpdateFolderMemberRequest
 */
export interface MemberApiUpdateFolderMemberRequest {
  /**
   * The identifier of a specific folder, or of one of the delegate strings @myFolder, @appDataFolder, @myHistory, @myFavorites, or @public.
   * @type {string}
   * @memberof MemberApiUpdateFolderMember
   */
  readonly folderId: string;

  /**
   * Member id.
   * @type {string}
   * @memberof MemberApiUpdateFolderMember
   */
  readonly memberId: string;

  /**
   * The ETag that was returned from a GET, POST, or PUT of this folder.
   * @type {string}
   * @memberof MemberApiUpdateFolderMember
   */
  readonly ifMatch?: string;

  /**
   * The value of the lastModified date of the folder. If the folder has been updated since this time, the update fails.
   * @type {string}
   * @memberof MemberApiUpdateFolderMember
   */
  readonly ifUnmodifiedSince?: string;

  /**
   * Member
   * @type {MemberIn}
   * @memberof MemberApiUpdateFolderMember
   */
  readonly memberIn?: MemberIn;
}

/**
 * Request parameters for validateMemberName operation in MemberApi.
 * @export
 * @interface MemberApiValidateMemberNameRequest
 */
export interface MemberApiValidateMemberNameRequest {
  /**
   * The identifier of the folder whose members are to be checked. A value of @root indicates checking a root-level folder, and type must be folder.
   * @type {string}
   * @memberof MemberApiValidateMemberName
   */
  readonly folderId: string;

  /**
   * If a rename is being attempted, the identifier of the member being renamed. If a new member is being created, the @new placeholder is used.
   * @type {string}
   * @memberof MemberApiValidateMemberName
   */
  readonly memberId: string;

  /**
   * The name to be tested.
   * @type {string}
   * @memberof MemberApiValidateMemberName
   */
  readonly value: string;

  /**
   * The type of the member to be tested. Members of the same type have to be named uniquely, so both the new name and type are required.
   * @type {string}
   * @memberof MemberApiValidateMemberName
   */
  readonly type: string;

  /**
   * The Type definition name to test against. This must match exactly with the desired value. A null value is compared with null values in the repository.
   * @type {string}
   * @memberof MemberApiValidateMemberName
   */
  readonly typeDefName?: string;
}

/**
 * MetainfoApi - axios parameter creator
 * @export
 */
export const MetainfoApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get the ancestors of a set of URIs. Each URI is represented in the result as an Ancestor object.
     * @summary Get ancestors for a list of resource URIs
     * @param {Array<string>} requestBody The list of URIs for which to retrieve ancestry.
     * @param {boolean} [allowPartialPath] Allow a partial path from the item if the user does not have access to all the folders in the path.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBulkAncestors: async (
      requestBody: Array<string>,
      allowPartialPath?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("createBulkAncestors", "requestBody", requestBody);
      const localVarPath = `/ancestors`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (allowPartialPath !== undefined) {
        localVarQueryParameter["allowPartialPath"] = allowPartialPath;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the ancestors of a resource by URI as a flat list, ordered starting with the parent folder of the resource, and continuing up to the root folder.
     * @summary Get a resource\'s ancestors
     * @param {string} childUri The URI of the target resource whose ancestry is desired.
     * @param {boolean} [allowPartialPath] Allow a partial path from the item if the user does not have access to all the folders in the path.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAncestors: async (
      childUri: string,
      allowPartialPath?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'childUri' is not null or undefined
      assertParamExists("getAncestors", "childUri", childUri);
      const localVarPath = `/ancestors`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (childUri !== undefined) {
        localVarQueryParameter["childUri"] = childUri;
      }

      if (allowPartialPath !== undefined) {
        localVarQueryParameter["allowPartialPath"] = allowPartialPath;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns the set of delegates known to the folders service.
     * @summary Get a list of known delegate-represented folders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDelegateInfo: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/delegateInfo`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the list of folder types that are recognized by the folders service. Returns a collection of application/vnd.sas.content.folder.type+json objects.
     * @summary Get a list of acceptable folder types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFolderTypes: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/folderTypes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MetainfoApi - functional programming interface
 * @export
 */
export const MetainfoApi = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = MetainfoApiAxiosParamCreator(configuration);
  return {
    /**
     * Get the ancestors of a set of URIs. Each URI is represented in the result as an Ancestor object.
     * @summary Get ancestors for a list of resource URIs
     * @param {MetainfoApiCreateBulkAncestorsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createBulkAncestors(
      requestParameters: MetainfoApiCreateBulkAncestorsRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<AncestorCollection>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createBulkAncestors(
          requestParameters.requestBody,
          requestParameters.allowPartialPath,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Get the ancestors of a resource by URI as a flat list, ordered starting with the parent folder of the resource, and continuing up to the root folder.
     * @summary Get a resource\'s ancestors
     * @param {MetainfoApiGetAncestorsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAncestors(
      requestParameters: MetainfoApiGetAncestorsRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Ancestor>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAncestors(
        requestParameters.childUri,
        requestParameters.allowPartialPath,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Returns the set of delegates known to the folders service.
     * @summary Get a list of known delegate-represented folders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDelegateInfo(
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<DelegateCollection>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDelegateInfo(
        options,
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },

    /**
     * Retrieves the list of folder types that are recognized by the folders service. Returns a collection of application/vnd.sas.content.folder.type+json objects.
     * @summary Get a list of acceptable folder types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFolderTypes(
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<FolderTypeCollection>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderTypes(
        options,
      );
      return createRequestFunction(localVarAxiosArgs, configuration);
    },
  };
};

/**
 * Request parameters for createBulkAncestors operation in MetainfoApi.
 * @export
 * @interface MetainfoApiCreateBulkAncestorsRequest
 */
export interface MetainfoApiCreateBulkAncestorsRequest {
  /**
   * The list of URIs for which to retrieve ancestry.
   * @type {Array<string>}
   * @memberof MetainfoApiCreateBulkAncestors
   */
  readonly requestBody: Array<string>;

  /**
   * Allow a partial path from the item if the user does not have access to all the folders in the path.
   * @type {boolean}
   * @memberof MetainfoApiCreateBulkAncestors
   */
  readonly allowPartialPath?: boolean;
}

/**
 * Request parameters for getAncestors operation in MetainfoApi.
 * @export
 * @interface MetainfoApiGetAncestorsRequest
 */
export interface MetainfoApiGetAncestorsRequest {
  /**
   * The URI of the target resource whose ancestry is desired.
   * @type {string}
   * @memberof MetainfoApiGetAncestors
   */
  readonly childUri: string;

  /**
   * Allow a partial path from the item if the user does not have access to all the folders in the path.
   * @type {boolean}
   * @memberof MetainfoApiGetAncestors
   */
  readonly allowPartialPath?: boolean;
}

/**
 * RootApi - axios parameter creator
 * @export
 */
export const RootApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns a list of links to the top-level collections surfaced through this API. These top-level links include /folders and /ancestors.
     * @summary Get a list of top-level links
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    root: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RootApi - functional programming interface
 * @export
 */
export const RootApi = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RootApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns a list of links to the top-level collections surfaced through this API. These top-level links include /folders and /ancestors.
     * @summary Get a list of top-level links
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async root(
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<FolderCollection>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.root(options);
      return createRequestFunction(localVarAxiosArgs, configuration);
    },
  };
};
