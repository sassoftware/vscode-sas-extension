{"name":"CLP","statements":[{"name":"PROC CLP","description":"The CLP procedure is a finite-domain constraint programming solver for constraint satisfaction problems (CSPs) with linear, logical, global, and scheduling constraints. In addition to having an expressive syntax for representing CSPs, the solver features powerful built-in consistency routines and constraint propagation algorithms, a choice of nondeterministic search strategies, and controls for guiding the search mechanism that enable you to solve a diverse array of combinatorial problems.","help":"PROC CLP <ACTDATA= SAS-data-set | ACTIVITY=SAS-data-set>\n                <CONDATA= SAS-data-set>\n                <DM= m | DEM= m>\n                <DOMAIN= [lb, ub] | DOM=[lb, ub>\n                <DPR= n>\n                <FINDALLSOLNS>\n                <MAXSOLNS=n>\n                <MAXTIME= m>\n                <NOPREPROCESS>\n                <OUT= SAS-data-set>\n                <PREPROCESS>\n                <RESDATA= SAS-data-set>\n                <RESTARTS= n>\n                <SCHEDRES= SAS-data-set (Experimental)>\n                <SCHEDTIME= SAS-data-set (Experimental)>\n                <SCHEDULE=SAS-data-set (Experimental)>\n                <SHOWPROGRESS>\n                <TIMETYPE=CPU | REAL>\n                <USECONDATAVARS=0 | 1>\n                <VARASSIGN= keyword | MIN>\n                <VARASSIGN= keyword | MIN>\n                <VARSELECT=FIFO | MAXCS | MINR                     ... >; \n\tACTIVITY specification <...> ;\n                \n\tALLDIFF (variables) <...> ; | ALLDIFFERENT (variables)                     <...> ;\n                \n\tARRAY specification <...> ;\n                \n\tELEMENT element_constraint-1 <...element_constraint-n>                     ;\n                \n\tFOREACH (array, type, <offset>) ;\n                \n\tGCC global_cardinality_constraint-1                     <...global_cardinality_constraint-n> ;\n                \n\tLINCON linear_constraint <, ...> ; | LINEAR linear_constraint                     <, ...> ;\n                \n\tREIFY variable : (linear_constraint) <...> ;\n                \n\tREQUIRES resource_constraint-1 <...resource_constraint-n>                     ;\n                \n\tRESOURCE specification <...> ; | RES specification <...>                     ;\n                \n\tSCHEDULE <ACTASSIGN= keyword>\n                    <ACTSELECT=<LJRAND | RAND | MAXD>... >\n                    <DURATION= dur | DUR= dur>                      ...;\n                \n\tVARIABLE var_specification-1 <...var_specification-n>                     ;\n            ","arguments":[{"name":"ACTDATA=","optional":true,"aliases":["ACTIVITY="],"description":"Identifies the input data set that defines the activities and temporal constraints. The temporal constraints consist of time alignment-type constraints and precedence-type constraints.","type":"value"},{"name":"CONDATA=","optional":true,"description":"Identifies the input data set that defines the linear constraints, variable types, and variable bounds.","type":"value"},{"name":"DM=","optional":true,"aliases":["DEM="],"description":"Specifies the dead-end multiplier for the CSP. The dead-end multiplier is used to determine the number of dead ends that are permitted before triggering a complete restart of the search technique in a scheduling environment","type":"value"},{"name":"DOMAIN=","optional":true,"aliases":["DOM="],"description":"Specifies the global domain of all variables to be the closed interval [lb, ub].","type":"value"},{"name":"DPR=","optional":true,"description":"Specifies an upper bound on the number of dead ends that are permitted before PROC CLP restarts or terminates the search, depending on whether or not a randomized search strategy is used. In the case of a nonrandomized strategy, n is an upper bound on the number of allowable dead ends before terminating.","type":"value"},{"name":"FINDALLSOLNS","optional":true,"aliases":["ALLSOLNS","FINDALL"],"description":"Attempts to find all possible solutions to the CSP. When a randomized search strategy is used, it is possible to rediscover the same solution and end up with multiple instances of the same solution. This is currently the case when you are solving scheduling-related problems. Therefore, this option is ignored when you are solving a scheduling-related problem.","type":"standalone"},{"name":"MAXSOLNS=","optional":true,"description":"Specifies the number of solution attempts to be generated for the CSP. The default value is 1. It is important to note, especially in the context of randomized strategies, that an attempt could result in no solution, given the current controls on the search mechanism, such as the number of restarts and the number of dead-ends permitted. As a result, the total number of solutions found might not match the MAXSOLNS= parameter.","help":"MAXSOLNS=*n*","type":"value"},{"name":"MAXTIME=","optional":true,"description":"Specifies an upper bound on the number of CPU seconds allocated for solving the problem. Note that the time specified by the MAXTIME= option is checked only once at the end of each iteration. Therefore, the actual running time can be longer than that specified by the MAXTIME= option. The difference depends on how long the last iteration takes. If you do not specify this option, the procedure does not stop based on the amount of time elapsed.","type":"value"},{"name":"NOPREPROCESS","optional":true,"description":"Suppresses any preprocessing that would typically be performed for the problem.","type":"standalone"},{"name":"OUT=","optional":true,"description":"Identifies the output data set that contains the solution(s) to the CSP, if any exist(s).","type":"value"},{"name":"PREPROCESS","optional":true,"description":"Permits any preprocessing that would typically be performed for the problem.","type":"standalone"},{"name":"RESDATA=","optional":true,"aliases":["RESIN="],"description":"Identifies the input data set that defines the resources and their attributes such as capacity and resource pool membership. This information can be used in lieu of, or in combination with, the RESOURCE statement.","type":"value"},{"name":"RESTARTS=","optional":true,"description":"Specifies the number of restarts of the randomized search technique before terminating the procedure. The default value is 3.","type":"value"},{"name":"SCHEDRES=","optional":true,"description":"Identifies the output data set that contains the solutions to scheduling CSPs. This data set contains the resource assignments of activities.","type":"value"},{"name":"SCHEDTIME=","optional":true,"description":"Identifies the output data set that contains the solutions to scheduling CSPs. This data set contains the time assignments of activities.","type":"value"},{"name":"SCHEDULE=","optional":true,"aliases":["SCHEDOUT="],"description":"Identifies the output data set that contains the scheduling-related solution to the CSP, if one exists.","type":"value"},{"name":"SHOWPROGRESS","optional":true,"description":"Prints a message to the log whenever a solution has been found. When a randomized strategy is used, the number of restarts and dead ends that were required are also printed to the log.","type":"standalone"},{"name":"TIMETYPE=","optional":true,"description":"Specifies the units for the value of the MAXTIME= option. The value of this option determines whether such time is CPU time or real time. The default value of this option is CPU.","help":"TIMETYPE=CPU | REAL","type":"choice","arguments":[{"name":"CPU","description":"Specifies CPU time units for the value of the MAXTIME= option.","type":"standalone"},{"name":"REAL","description":"Specifies REAL time units for the value of the MAXTIME= option.","type":"standalone"}]},{"name":"USECONDATAVARS=","optional":true,"description":"Specifies whether the numeric variables in the CONDATA= data set, with the exception of any reserved variables, are implicitly defined or not.","help":"USECONDATAVARS=0 | 1","type":"choice","arguments":[{"name":"0","description":"Indicates that the numeric variables in the CONDATA= data set are not implicitly defined.","type":"standalone"},{"name":"1","description":"Indicates that the numeric variables in the CONDATA= data set are implicitly defined, in which case a VARIABLE statement is not necessary to define the variables in the data set.","type":"standalone"}]},{"name":"VARASSIGN=","optional":true,"description":"Specifies the value selection strategy. Currently there is only one value selection strategy. The MIN strategy selects the minimum value from the domain of the selected variable.","help":"VARASSIGN=MIN","type":"value"},{"name":"VARSELECT=","optional":true,"description":"Specifies the variable selection strategy. Both static and dynamic strategies are available.","help":"VARSELECT=FIFO | MAXCS | MINR | MAXC | MINRMAXC","type":"choice","arguments":[{"name":"FIFO","description":"[Static strategy]--Uses the first-in-first-out ordering of the variables as encountered by the procedure.","type":"standalone"},{"name":"MAXCS","description":"[Static strategy]--Selects the variable with the maximum number of constraints.","type":"standalone"},{"name":"MINR","description":"[Dynamic strategy]--Selects the variable with the smallest range (that is, the minimum value of upper bound minus lower bound).","type":"standalone"},{"name":"MAXC","description":"[Dynamic strategy]--Selects the variable with the largest number of active constraints","type":"standalone"},{"name":"MINRMAXC","description":"[Dynamic strategy]--Selects the variable with the smallest range, breaking ties by selecting one with the largest number of active constraints.","type":"standalone"}]}]},{"name":"ACTIVITY","description":"An ACTIVITY specification can be one of the following types: activity <= ( <DUR=> duration <type=date ...>)> (activity_list) <= ( <DUR=> duration <type=date ...>)> where duration is the activity duration and type is a keyword specifying an alignment-type constraint on the activity (or activities) with respect to the date given by date. The ACTIVITY statement defines one or more activities and the attributes of each activity, such as the duration and any temporal constraints of the time alignment type. The default duration is 0. Valid type keywords are as follows: o SGE, start greater than or equal to date o SLE, start less than or equal to date o FGE, finish greater than or equal to date o FLE, finish less than or equal to date You can specify any combination of the preceding keywords. For example, to define activities A1, A2, A3, B1, and B3 with duration 3, and to set the start time of these activities equal to 10, you would specify the following: activity (A1-A3 B1 B3) = ( dur=3 sge=10 sle=10 );","help":"ACTIVITY specification &lt;...&gt; "},{"name":"ALLDIFF","aliases":["ALLDIFFERENT"],"description":"The ALLDIFF statement can have multiple specifications. Each specification defines a unique global constraint on a set of variables requiring all of them to be different from each other. A global constraint is equivalent to a conjunction of elementary constraints. For example, the statements var (X1-X3) A B; alldiff (X1-X3) (A B); are equivalent to X1 ≠ X2 AND X2 ≠ X3 AND X1 ≠ X3 AND A ≠ B If the variable list is empty, the ALLDIFF constraint applies to all the variables declared in the VAR statement.","help":"ALLDIFF (variables) &lt;...&gt; ; | ALLDIFFERENT (variables)                         &lt;...&gt; "},{"name":"ARRAY","description":"An ARRAY specification is in a form as follows: name[dimension](variables) The ARRAY statement is used to associate a name with a list of variables. Each of the variables in the variable list must be defined using a VAR statement. The ARRAY statement is required when you are specifying a constraint by FOREACH statement.","help":"ARRAY specification &lt;...&gt; "},{"name":"ELEMENT","description":"An element_constraint is specified in the following form: (index variable, (integer list), variable) The ELEMENT statement specifies one or more element constraints. An element constraint enables you to define dependencies, not necessarily functional, between variables.","help":"ELEMENT element_constraint-1 &lt;...element_constraint-n&gt;                     "},{"name":"FOREACH","description":"where array must be defined by using an ARRAY statement, type is a keyword that determines the type of the constraint, and offset is an integer. The FOREACH statement iteratively applies a constraint over an array of variables. The type of the constraint is determined by type. Currently, the only valid type keyword is DIFF. The optional offset parameter is an integer and is interpreted in the context of the constraint type. The default value of offset is zero.","help":"FOREACH (array, type, &lt;offset&gt;) "},{"name":"GCC","description":"where global_cardinality_constraint is specified in the following form: (variables) = ((v1,l1,u1) <...(vn,ln,un)> <DL= dl> <DU= du> ) vi is a value in the domain of one of the variables, and li and ui are the lower and upper bounds on the number of variables assigned to vi. The values of dl and du are the lower and upper bounds on the number of variables assigned to values in D outside of (v1,...,vn). The GCC statement specifies one or more global cardinality constraints. A global cardinality constraint (GCC) is a constraint that consists of a set of variables {xi,...,xn} and for each value v in D=Ui=1,...,nDom(xi), a pair of numbers lv and uv. A GCC is satisfied if and only if the number of times that a value v in D is assigned to the variables x1,...,xn is at least lv and at most uv.","help":"GCC global_cardinality_constraint-1                         &lt;...global_cardinality_constraint-n&gt; "},{"name":"LINCON","aliases":["LINEAR"],"description":"A linear_constraint is specified in the following form: linear_term_1 operator linear_term_2 where a linear_term is of the form ((<+|-> variable | number <* variable >)...) The keyword operator can be one of the following: <, ≤, =, ≥ , >, <>, LE, EQ, GE, LT, GT, NE The LINCON statement allows for a very general specification of linear constraints.","help":"LINCON linear_constraint &lt;, ...&gt; ; | LINEAR linear_constraint                         &lt;, ...&gt; "},{"name":"REIFY","description":"A linear_constraint is specified in the following form: linear_term_1 operator linear_term_2 where a linear_term is of the form ((<+|-> variable | number <* variable >)...) The keyword operator can be one of the following: <, ≤, =, ≥ , >, <>, LE, EQ, GE, LT, GT, NE The REIFY statement associates a binary variable with a linear constraint. The value of the binary variable is 1 or 0 depending on whether the linear constraint is satisfied or not, respectively. The linear constraint is said to be reified, and the binary variable is referred to as the control variable. As with the other variables, the control variable must also be defined in a VAR statement or in the CONDATA= data set.","help":"REIFY variable : (linear_constraint) &lt;...&gt; "},{"name":"REQUIRES","aliases":["REQ"],"description":"where resource_constraint is specified in the following form: activity_specification = (resource_specification) <qty = > where activity_specification: (activity | activity-1 <...activity-m>) and resource_specification: (resource-1 <qty = > <...(, OR) resource- <qty=>>) activity_specification is a single activity or a list of activities that requires q units of the resource identified in resource_specification. resource_specification is a single resource or a list of resources, representing a choice of resource, along with the equivalent required quantities for each resource. The default value of ri is 1. Alternate resource requirements are separated by a comma (,) or the keyword OR. The qty= parameter outside the resource_specification acts as a multiplier to the qty= parameters inside the resource_specification. The REQUIRES statement defines the potential activity assignments with respect to the pool of resources. If an activity is not defined, the REQUIRES statement implicitly defines the activity.","help":"REQUIRES resource_constraint-1 &lt;...resource_constraint-n&gt;                     "},{"name":"RESOURCE","aliases":["RES"],"description":"A RESOURCE specification is a single resource or a list of resources. The RESOURCE statement specifies the names of all resources that are available to be allocated to the activities. The REQUIRES statement is necessary to specify the resource requirements of an activity. Currently all resources are assumed to be unary resources in that their capacity is equal to one and they cannot be assigned to more than one activity at any given time.","help":"RESOURCE specification &lt;...&gt; ; | RES specification                         &lt;...&gt; "},{"name":"SCHEDULE","aliases":["SCHED"],"description":"","help":"SCHEDULE <ACTASSIGN= keyword>\n                        <ACTSELECT=<LJRAND | RAND | MAXD>                             ... >\n                        <DURATION= dur | DUR= dur> ...","arguments":[{"name":"ACTASSIGN=","optional":true,"description":"Specifies the activity assignment strategy subject to the setting of the ACTSELECT= option.","type":"value"},{"name":"ACTSELECT=","optional":true,"description":"Specifies the activity selection strategy.","help":"ACTSELECT=LJRAND | RAND | MAXD | MINA | MINLS | RJRAND | DET | DMNLS","type":"choice","arguments":[{"name":"LJRAND","description":"[Randomized selection strategy] Selects an activity at random from those that begin prior to the earliest early finish time. This is the default strategy.","type":"standalone"},{"name":"RAND","description":"[Randomized selection strategy] See the LJRAND selection strategy.","type":"standalone"},{"name":"MAXD","description":"[Randomized selection strategy] Selects an activity at random from those that begin prior to the earliest early finish time and that have maximum duration.","type":"standalone"},{"name":"MINA","description":"[Randomized selection strategy] Selects an activity at random from those that begin prior to the earliest early finish time and that have the minimum number of resource assignments.","type":"standalone"},{"name":"MINLS","description":"[Randomized selection strategy] Selects an activity at random from those that begin prior to the earliest early finish time and that have a minimum late start date.","type":"standalone"},{"name":"RJRAND","description":"[Randomized selection strategy] Selects an activity at random from those that finish after the latest late start time.","type":"standalone"},{"name":"DET","description":"[Deterministic selection strategy] Selects the first activity that begins prior to the earliest activity finish date.","type":"standalone"},{"name":"DMNLS","description":"[Deterministic selection strategy] Selects the activity with the earliest late start time.","type":"standalone"}]},{"name":"DURATION=","optional":true,"aliases":["SCHEDDUR=","DUR="],"description":"Specifies the duration of the schedule.","type":"value"},{"name":"EDGEFINDER=","optional":true,"aliases":["EDGE="],"description":"Activates the edge-finder consistency routines for scheduling problems. By default, the EDGEFINDER= option is inactive. Specifying the EDGEFINDER= option determines whether an activity must be the first or the last to be processed from a set of activities requiring a given resource or set of resources and prunes the domain of activity as appropriate. Specifying EDGEFINDER by itself is equivalent to specifying EDGEFINDER=LAST.","type":"value"},{"name":"FINISH=","optional":true,"aliases":["END=","FINISHBEFORE="],"description":"Specifies the finish time for the schedule. The schedule finish time is an upper bound on the finish time of each activity (subject to time, precedence, and resource constraints). If you want to impose a tighter upper bound for an activity, you can do so either by using the FLE= specification in an ACTIVITY statement or by using the _ALIGNDATE_ and _ALIGNTYPE_ variables in the ACTDATA= data set.","type":"value"},{"name":"NOTFIRST=","optional":true,"aliases":["NF="],"description":"Activates an extension of the edge-finder consistency routines for scheduling problems. By default, the NOTFIRST= option is inactive. Specifying the NOTFIRST= option determines whether an activity cannot be the first to be processed from a set of activities requiring a given resource or set of resources and prunes its domain as appropriate.","type":"value"},{"name":"NOTLAST=","optional":true,"aliases":["NL="],"description":"Activates an extension of the edge-finder consistency routines for scheduling problems. By default, the NOTLAST= option is inactive. Specifying the NOTLAST= option determines whether an activity cannot be the last to be processed from a set of activities requiring a given resource or set of resources and prunes its domain as appropriate.","type":"value"},{"name":"START=","optional":true,"aliases":["BEGIN=","STARTAFTER="],"description":"Specifies the start time for the schedule. The schedule start time is a lower bound on the start time of each activity (subject to time, precedence, and resource constraints). If you want to impose a tighter lower bound for an activity, you can do so either by using the SGE= specification in an ACTIVITY statement or by using the _ALIGNDATE_ and _ALIGNTYPE_ variables in the ACTDATA= data set.","type":"value"}]},{"name":"VARIABLE","aliases":["VAR"],"description":"A var_specification-1 can be one of the following types: variable <=[lower-bound <, upper-bound>]> (variables) <=[lower-bound <, upper-bound>]> The VARIABLE statement declares all the variables that are to be considered in the CSP and, optionally, defines their domains. Any variable domains defined in a VARIABLE statement override the global variable domains defined using the DOMAIN= option in the PROC CLP statement as well as any bounds defined using the CONDATA= data set. If lower- bound is specified and upper-bound is omitted, the corresponding variables are considered as being assigned to lower-bound. The values of lower-bound and upper-bound can also be specified as missing, in which case the appropriate values from the DOMAIN= specification are substituted.","help":"VARIABLE var_specification-1 &lt;...var_specification-n&gt;                     "}],"supportSiteInformation":{"docsetId":"casmopt","docsetVersion":"v_021","docsetTargetFile":"casmopt_clp_toc.htm"}}