{"name":"CSSM","statements":[{"name":"PROC CSSM","description":"State space models (SSMs) are used for analyzing continuous response variables that are recorded sequentially according to a numeric indexing variable. In many cases, the indexing variable is time and the observations are collected at regular time intervals—for example, hourly, weekly, or monthly. In such cases, the resulting data are called time series data. In other cases, the indexing variable might not be time or the observations might not be equally spaced according to the indexing variable. These more general types of sequential data are called longitudinal data. Because of their sequential nature, these types of data exhibit some characteristic features. For example, chronologically closer measurements tend to be highly correlated while measurements farther apart are essentially uncorrelated. Data can be trending in a particular direction and can have seasonal or other periodic patterns. SSMs are specially designed to model such sequential data. They apply to both univariate and multivariate response situations and can easily incorporate predictor (independent variable) information when it is available. The CSSM procedure performs state space modeling of univariate and multivariate time series and longitudinal data.","help":"PROC CSSM <options>;\n\tBY variables;\n\tCOMPONENT name = (variables) * state< / options>;\n\tDEPLAG name(response-variable)lag-term1<lag-term2 ...>;\n\tDISPLAY <table-list>< / options>;\n\tDISPLAYOUT table-spec-list< / options>;\n\tEVAL name = expression< / options>;\n\tID variable<option>;\n\tIRREULAR name<options>;\n\tMODEL response = variables< / options>;\n\tOBSINDEX variable;\n\tOUTPUT <options>;\n\tPARMS variables< / options>;\n\tProgramming Statements ;\n\tSCORE options;\n\tSIMSMOOTH options;\n\tSTATE name(dim)<options>;\n\tTREND name(type)<options>;","arguments":[{"name":"BREAKPEAKS","optional":true,"description":"prints an alternate form of the break summary tables when the CHECKBREAK option is used in the STATE or TREND statement or when the MAXSHOCK option is used in the OUTPUT statement. In this alternate form, the summary tables report the significant peaks of the shock statistics curves; see Example 14.8: Diagnostic Plots and Structural Break Analysis for examples of these curves.","type":"standalone"},{"name":"DATA=","optional":true,"description":"names the input data table for PROC CSSM to use.","help":"DATA= *libref.data-table*","type":"dataSet"},{"name":"LIKE=","optional":true,"description":"specifies the type of likelihood to use for parameter estimation. You can specify the following values:","help":"LIKE= DIFFUSE |  MARGINAL","type":"choice","arguments":[{"name":"DIFFUSE","type":"standalone"},{"name":"MARGINAL","type":"standalone"}]},{"name":"NOPRINT","optional":true,"description":"turns off all the printing and plotting for the procedure. Any subsequent print options are ignored.","type":"standalone"},{"name":"OPTIMIZER","optional":true,"description":"specifies options that are associated with the optimizer used in the maximum likelihood parameter estimation. The default settings of the optimization process are adequate for most problems. However, in some cases it might be useful to change the optimization technique, the Hessian type, or the maximum number of iterations. You can specify one of the following techniques:","help":"OPTIMIZER(&lt;TECHNIQUE=*technique*&gt; &lt;HESSTYPE=*Hessian-type*&gt; &lt;MAXITER=*integer*&gt;)","type":"standaloneOrValue"},{"name":"PLOTS","optional":true,"description":"","help":"PLOTS &lt;(global-plot-options)&gt; = *plot-request* &lt;(options)&gt;","type":"value"},{"name":"PLOTS","optional":true,"description":"controls the plots produced with ODS Graphics. When you specify only one plot-request, you can omit the parentheses around it. If you do not specify any specific plot-request, then by default PROC CSSM produces the plot of standardized residuals against time. For general information about ODS Graphics, see Chapter 24, Statistical Graphics Using ODS (SAS/STAT User's Guide).","help":"PLOTS &lt;(global-plot-options)&gt; = (*plot-request* &lt;(options)&gt;&lt; … *plot-request*&lt;(options)&gt;&gt;","type":"value"},{"name":"PRINTALL","optional":true,"description":"turns on all the printing options for the procedure. All subsequent NOPRINT options in the procedure are ignored.","type":"standalone"},{"name":"STATEINFO","optional":true,"description":"prints two tables that provide information about the composition of the state vector in terms of the components specified in the model. One table describes the composition of state alpha alpha Subscript t, and the other table describes the diffuse vector delta delta and the regressors, which are part of the initial condition specification alpha alpha 1. For more information about the state space model notation, see the section State Space Model and Notation.","type":"standalone"},{"name":"ZSPARSE","optional":true,"description":"enables the exploitation of the sparsity of the bold upper Z Subscript t matrices in the observation equation during the modeling calculations (see the section State Space Model and Notation for further information). The use of this option can improve the computational efficiency of models that have a large state dimension and sparse bold upper Z Subscript t matrices—that is, many of their elements are zero. You should use the ZSPARSE option only when the state dimension is sufficiently large (at least 30) and a good percentage (at least 50%) of bold upper Z Subscript t entries are zero; otherwise, the computational efficiency can in fact degrade.","type":"standalone"}]},{"name":"BY","description":"A BY statement can be used in the CSSM procedure to process a data set in groups of observations that are defined by the BY variables. The model specified by using the MODEL and other statements is applied to all the groups defined by the BY variables. The BY variables are one or more variables in the input data set. The BY variables cannot be used in the model specification; in particular, they cannot be used as response variables or regressors in a MODEL statement.","help":"BY *variables*;"},{"name":"COMPONENT","description":"The COMPONENT statement specifies a component (a linear combination of state elements), named name. You can use name later as a term in the right-hand side of the MODEL statement, which defines the observation equation. The estimate of name is output to the OUT= data set that is specified in the OUTPUT statement. In addition, you can print the component estimate by using the PRINT= option.","help":"COMPONENT name = (var1 var2 … | number1 number2 ...) * state</ options>;\nCOMPONENT name = state [ integer ]</ options>;\nCOMPONENT name = (Variable | Number) * state [ integer ]</ options>;","arguments":[{"name":"name=","description":"The COMPONENT statement specifies a component (a linear combination of state elements), named name. You can use name later as a term in the right-hand side of the MODEL statement, which defines the observation equation. The estimate of name is output to the OUT= data set that is specified in the OUTPUT statement. In addition, you can print the component estimate by using the PRINT= option.","help":"name=*component*","type":"value"},{"name":"PRINT","optional":true,"followsDelimiter":"/","description":"requests printing of the filtered or smoothed estimate of the specified component.","help":"PRINT = FILTER | SMOOTH | (FILTER SMOOTH)","type":"choice","arguments":[{"name":"FILTER","type":"standalone"},{"name":"SMOOTH","type":"standalone"},{"name":"(FILTER SMOOTH)","type":"standalone"}]}]},{"name":"DEPLAG","description":"The DEPLAG statement defines a term, named name, that consists of a linear combination of lagged response variables. You can use name later as a right-hand-side term in the MODEL statement for the response variable, as specified in name(response-variable). For a multivariate model, a separate DEPLAG statement is needed for each MODEL statement that has a right-hand-side term that involves lagged response variables. The linear combination of lagged response variables is specified by using one or more lag-terms. Each lag-term specifies the lags that are associated with one of the response variables.","help":"DEPLAG *name(response-variable)**lag-term1*&lt;lag-term2 ...&gt;","arguments":[{"name":"name","description":"The DEPLAG statement defines a term, named name, that consists of a linear combination of lagged response variables.","help":"name(*response-variable*)","type":"value"},{"name":"lag-term1","description":"A lag-term is specified in one of the following forms:","type":"standalone"}]},{"name":"DISPLAY","description":"The DISPLAY statement enables you to specify a list of display tables to display or exclude. This statement is similar to the ODS SELECT, ODS EXCLUDE, and ODS TRACE statements. However, the DISPLAY statement can improve performance when a large number of tables could be generated (such as in BY-group processing). The procedure processes the DISPLAY statement on a CAS server and thus sends only a subset of ODS tables to the SAS client. Because ODS statements are processed on a SAS client, first all the generated display tables are sent to the client, and then the client creates a subset. If you use both DISPLAY and ODS statements together, the DISPLAY statement takes precedence over the ODS statements. Note that the ODS EXCLUDE statement processes tables that are sent to the client after they have been filtered by the DISPLAY statement. In some cases, it might appear that the ODS EXCLUDE statement is taking precedence because it can further filter the tables. For more information about ODS, see SAS Output Delivery System: Procedures Guide.","help":"DISPLAY &lt;table-list&gt;&lt;/ options&gt;;","arguments":[{"name":"table-list","description":"You can specify the table-list as a list of table names, paths, partial pathnames, and regular expressions.","type":"standaloneOrValue"},{"name":"CASESENSITIVE","optional":true,"followsDelimiter":"/","description":"performs a case-sensitive comparison of table names in the table-list to display table names when tables are subsetted for display. To preserve case, you must enclose table names in the table-list in quotation marks.","type":"standalone"},{"name":"EXCLUDE","optional":true,"followsDelimiter":"/","description":"displays all display tables except those that you specify in the table-list.","type":"standalone"},{"name":"EXCLUDEALL","optional":true,"followsDelimiter":"/","description":"suppresses display of all tables. This option takes precedence over the other options.","type":"standalone"},{"name":"TRACE","optional":true,"followsDelimiter":"/","description":"displays the display table names, labels, and paths.","type":"standalone"}]},{"name":"DISPLAYOUT","description":"The DISPLAYOUT statement enables you to create output tables from your displayed output. This statement is similar to the ODS OUTPUT statement. For more information about ODS, see SAS Output Delivery System: Procedures Guide.","help":"DISPLAYOUT *table-spec-list*&lt;/ options&gt;","arguments":[{"name":"table-spec-list","placeholder":true,"description":"The table-spec-list specifies a list of output tables to create. Each entry in the list has either a key=value format or a key format:","type":"dataSet"},{"name":"INCLUDEALL","optional":true,"followsDelimiter":"/","description":"creates output tables for all display tables. The name of the created output table is the same as the name of the corresponding display table. If you specify this option, the table-spec-list specification is ignored.","type":"standalone"},{"name":"NOREPLACE","optional":true,"followsDelimiter":"/","description":"does not replace any existing output table of the same name.","type":"standalone"},{"name":"REPEATED","optional":true,"followsDelimiter":"/","description":"replicates all output tables on all nodes.","type":"standalone"}]},{"name":"EVAL","description":"The EVAL statement defines a linear combination, named name, of the terms used in the right-hand side of a MODEL statement. You can specify any variables (for example, predictor variables and names of components) in the expression of the EVAL statement; however, you cannot specify in this expression any observation disturbances that are specified by the IRREGULAR statement and any model terms that are specified by the DEPLAG statement.","help":"EVAL *name= number1*variable1 + number2*variable2 + ...*&lt;/ options&gt;;","arguments":[{"name":"name=","description":"defines a linear combination, named name, of the terms used in the right-hand side of a MODEL statement.","type":"value"},{"name":"PRINT","optional":true,"followsDelimiter":"/","description":"requests printing of the filtered or smoothed estimate of the specified linear combination.","help":"PRINT = FILTER | SMOOTH | (FILTER SMOOTH)","type":"choice","arguments":[{"name":"FILTER","type":"standalone"},{"name":"SMOOTH","type":"standalone"},{"name":"(FILTER SMOOTH)","type":"standalone"}]}]},{"name":"ID","description":"The ID statement names a numeric variable to associate a sequence value—usually related to a timestamp—with the observations in the input data set. The ID statement is required. Internally, the CSSM procedure sorts the observations in ascending order by the ID variable within a BY group. If you also supply an OBSINDEX variable, the observations are sorted by both the ID variable and the OBSINDEX variable. Often the ID variable’s values are SAS date, time, or datetime values, and each observation within a BY group has a unique ID value. Generally, however, the ID variable can be any numeric variable, and there can be multiple observations with the same ID value. If the ID values are SAS date, time, or datetime values, you can specify the associated unit of time—for example, day, week or month—by using the INTERVAL= option. A variable, _ID_DELTA_, is automatically created that can be used as any input data set variable in the programming statements. _ID_DELTA_ contains the distance between two successive ID values. The first _ID_DELTA_ value is arbitrarily taken as 1. If the INTERVAL= option is specified, the distance between the ID values is measured in terms of the number of intervals; therefore, for regularly spaced data, _ID_DELTA_ is identically equal to 1.","help":"ID *variable*&lt;option&gt;;","arguments":[{"name":"variable","placeholder":true,"description":"The ID statement names a numeric variable to associate a sequence value—usually related to a timestamp—with the observations in the input data set.","type":"value"},{"name":"INTERVAL=","optional":true,"description":"specifies the unit of time interval that is used to measure the ID values. INTERVAL=value is used in conjunction with the ID variable to verify that the input data are in the proper order. For a complete discussion of the supported intervals, see Chapter 4, Date Intervals, Formats, and Functions (SAS/ETS User's Guide).","help":"INTERVAL= *value*","type":"value"}]},{"name":"IRREGULAR","description":"The IRREGULAR statement specifies a one-dimensional white noise component, which can be used to specify the observation error in a MODEL statement.","help":"IRREGULAR *name*&lt;options&gt;;","arguments":[{"name":"PRINT=","optional":true,"description":"requests printing of the smoothed estimate of the specified irregular component.","help":"PRINT=SMOOTH","type":"value"},{"name":"VARIANCE=","optional":true,"description":"specifies the variance of the white noise. Any nonnegative value, including 0, is permissible. If the variable contains unknown parameters, they are estimated from the data. Similarly, if the VARIANCE= option is not specified, the variance is estimated from the data.","help":"VARIANCE= *variable* | *number*","type":"choice","arguments":[{"name":"variable","placeholder":true,"type":"value"},{"name":"number","placeholder":true,"type":"value"}]}]},{"name":"MODEL","description":"A MODEL statement specifies an observation equation that describes a response variable as a sum of regression effects and components that are defined in the program. The response variable must be a numeric variable from the input data set. The variables used in the right-hand side of the model expression can be numeric variables from the input data set, numeric variables defined by using programming statements, or names of components that are specified in the COMPONENT, DEPLAG, TREND, or IRREGULAR statements. For a multivariate model, a separate MODEL statement is needed for each of the response variables. In this case, the observation errors, which are specified in an IRREGULAR statement, must be different in each MODEL statement. The components that are specified in a given MODEL statement must correspond to distinct state subsections. This requirement is imposed only to simplify the overall readability of the program and does not limit the type of models that can be specified; if two components on the right-hand side of a MODEL statement share the same state subsection, a new component that combines the effect of these two components can always be defined.","help":"MODEL *response = variables*&lt;options&gt;;","arguments":[{"name":"response = variables","placeholder":true,"description":"The response variable must be a numeric variable from the input data set. The variables used in the right-hand side of the model expression can be numeric variables from the input data set, numeric variables defined by using programming statements, or names of components that are specified in the COMPONENT, DEPLAG, TREND, or IRREGULAR statements.","help":" *response = variables*","type":"value"},{"name":"AGGREGATE","optional":true,"description":"produces a table of full-sample predictions of the temporally aggregated values of the response variable that is specified in the MODEL statement. The variable that you specify in the START= option, startFlag, must be a zero-one variable that flags the start of an aggregation interval—equal to 1 at the start of an interval and 0 otherwise. For example, you can use this option to obtain the forecasts of weekly (or monthly) totals from a daily series. In this case, the value of startFlag is 1 at the start of the week (or month) and 0 otherwise. For more information, see the section Temporal Aggregation and Temporal Distribution. This option is valid only if the data form a time series (either univariate or multivariate). If you use the AGGREGATE option in a MODEL statement, you cannot use the DISTRIBUTE option in the same statement or in another MODEL statement.","help":"AGGREGATE(START=*startFlag*) | SUM(START=*startFlag*)","type":"choice","arguments":[{"name":"AGGREGATE","type":"value"},{"name":"SUM","type":"value"}]},{"name":"DISTRIBUTE","optional":true,"description":"indicates that the response variable that is specified in the MODEL statement is a temporally aggregated version of an unobserved variable. The variable that you specify in the START= option, startFlag, must be a zero-one variable that flags the start of an aggregation interval—equal to 1 at the start of an interval and 0 otherwise. This option can be used only when the data form a time series (either univariate or multivariate) and when the overall model specification does not contain terms that involve lagged response variables (that is, the model specification does not involve the use of DEPLAG statements). If you use the DISTRIBUTE option in a MODEL statement, you cannot use the AGGREGATE option in the same statement or in another MODEL statement. For more information, see the section Temporal Aggregation and Temporal Distribution.","help":"DISTRIBUTE(START=*startFlag*)","type":"value"},{"name":"PRINT","optional":true,"description":"requests printing of the filtered or smoothed estimate of the specified response variable. The filtered estimate is produced during the filtering phase, and the smoothed estimate is produced by the smoothing phase of the Kalman filter and smoother algorithm. The filtered estimate is also called the one-step-ahead forecast of the response variable. The smoothed estimate corresponds to the full-sample prediction of the response variable. Because the full-sample prediction of a nonmissing response value is that value itself, full-sample predictions are printed only for the missing response values.","help":"PRINT = FILTER | SMOOTH | (FILTER SMOOTH)","type":"choice","arguments":[{"name":"FILTER","type":"standalone"},{"name":"SMOOTH","type":"standalone"},{"name":"(FILTER SMOOTH)","type":"standalone"}]}]},{"name":"OBSINDEX","description":"The OBSINDEX statement specifies a numeric input data variable that, together with the ID variable, uniquely identifies the observations within a BY group. This statement is essential for the reproducibility of the computations in situations where there can be multiple observations in a given BY group that have the same ID value. These types of situations arise when you are analyzing panels of time series or when the data are longitudinal.","help":"OBSINDEX *variables*;"},{"name":"OUTPUT","description":"The OUTPUT statement creates an optional output data set and also provides options to control certain aspects of the procedure output. If the OUT= option is specified, then an output data set is created to store estimates of the model components and series forecasts. If the OUT= option is omitted, then no data set is created by the OUTPUT statement. Other options in the OUTPUT statement produce additional information in the printed output generated by the procedure.","help":"OUTPUT &lt;options&gt; ;","arguments":[{"name":"AO","optional":true,"description":"controls the additive outlier search (see the section Delete-One Cross Validation and the Additive Outlier Detection for more information). The ALPHA= suboption specifies the significance level for reporting the outliers. The default is ALPHA=0.05. The MAXNUM= suboption limits the number of outliers to search. The default is MAXNUM=5. The MAXPCT= suboption is similar to the MAXNUM= suboption. In the MAXPCT= option you can limit the number of outliers to search for according to a percentage of the series length. The default is MAXPCT=1. When you specify both of these options, the lesser of the two search numbers is used.","help":"AO(&lt;*number*&gt; &lt;*number*&gt; &lt;*number*&gt;)","type":"standaloneOrValue"},{"name":"ALPHA=","optional":true,"description":"specifies the significance level of the forecast confidence intervals. For example, ALPHA=0.05, which is the default, results in a 95% confidence interval.","help":"ALPHA=*number*","type":"value"},{"name":"BREAK","optional":true,"description":"controls the structural break search (for more information, see the section Structural Breaks in the State Evolution). In order for this option to have any effect, the CHECKBREAK option in one of the STATE or TREND statements, or the MAXSHOCK option in the OUTPUT statement, must be turned on. The ALPHA= suboption specifies the significance level for reporting the breaks. The default is ALPHA=0.05. The MAXNUM= suboption limits the number of breaks to search. The default is MAXNUM=5. The MAXPCT= suboption is similar to the MAXNUM= suboption. In the MAXPCT= option, you can limit the number of breaks to search for according to a percentage of the number of distinct time points in the data. The default is MAXPCT=1. When you specify both of these options, the lesser of the two search numbers is used.","help":"BREAK(&lt;*number*&gt; &lt;*number*&gt; &lt;*number*&gt;)","type":"standaloneOrValue"},{"name":"MAXSHOCK","optional":true,"description":"causes the computation of the maximal state shock chi-square statistic at each distinct time point in the input data set. These statistics are output to the data set that is specified in the OUT= option. A time series plot of these statistics is produced if the PLOTS=MAXSHOCK option is specified in the PROC CSSM statement. These statistics are useful for detecting structural breaks in the state evolution process. This option can be computationally expensive for a model with large state size.","type":"standalone"},{"name":"OUT=","optional":true,"description":"specifies an output data set for the forecasts. The output data set contains the ID variable, the OBSINDEX variable (if specified), the response variables, the one-step-ahead and out-of-sample response variable forecasts, the forecast confidence intervals, the smoothed values of the response series, and the one-step-ahead and smoothed estimates of the model components—including expressions that are defined by using the EVAL statement.","help":"OUT=*libref.data-table*","type":"dataSet"},{"name":"PDV","optional":true,"description":"causes the inclusion of the variables (variables in the program data vector) that are defined by using the programming statements in the CSSM procedure in the OUT= data set. The parameters defined by the PARMS statement are also included. The output data set contains the values of these variables evaluated for all the rows in the input data set that is specified in the DATA= option. The parameters in the PARMS statement contain their estimated values.","type":"standalone"},{"name":"PRESS","optional":true,"description":"prints the prediction error sum of squares (PRESS) and the generalized cross validation error sum of squares (GCV). The PRESS table also reports the number of summands that are used in these sums of squares.","type":"standalone"}]},{"name":"PARMS","description":"The PARMS statement declares the parameters of a model and optionally sets their initial values. You can also specify the lower and upper limits of their validity range. The parameters declared by using the PARMS statement are called named parameters throughout this chapter. A model can have additional parameters: any unspecified quantity in the model specification becomes part of the parameter vector.","help":"PARMS *variable*&lt;=number&gt;*variable*&lt;=number&gt;&lt;/ options&gt;;","arguments":[{"name":"LOWER=","optional":true,"followsDelimiter":"/","description":"specifies the lower bounds for the specified parameters. The list can contain exactly one number, which is taken to be the lower bound for all the listed parameters in the statement, or it must contain as many values as the number of parameters specified. A missing value, denoted by ., is a permissible value, which signifies that the parameter has no lower bound.","help":"LOWER=(*number*) |  LOWER=(*number1 number2 ...*)","type":"choice","arguments":[{"name":"LOWER=","type":"value"},{"name":"LOWER=","type":"value"}]},{"name":"UPPER=","optional":true,"followsDelimiter":"/","description":"specifies the upper bounds for the specified parameters. The list can contain exactly one number, which is taken to be the upper bound for all the listed parameters in the statement, or it must contain as many values as the number of parameters specified. A missing value, denoted by ., is a permissible value, which signifies that the parameter has no upper bound.","help":"UPPER=(*number*) |  UPPER=(*number1 number2 ...*)","type":"choice","arguments":[{"name":"UPPER=","type":"value"},{"name":"UPPER=","type":"value"}]}]},{"name":"Programming Statements","description":"To define the model, you can use most of the programming statements that are allowed in the SAS DATA step. For more information, see the SAS DATA Step Statements: Reference. For the most part, the syntax of programming statements used in PROC CSSM is identical to that used in the MODEL procedure (see Chapter 24, MODEL Procedure (SAS/ETS User's Guide)) and the NLMIXED procedure (see Chapter 89, The NLMIXED Procedure (SAS/STAT User's Guide)). However, there are some restrictions: the DATA step lagging and differencing functions are not allowed, and the use of character variables in the DATA step expressions is not permitted. These are not serious restrictions; usually you can overcome them by adding the variables that are created by such operations to the input data set before its use in the CSSM procedure."},{"name":"SCORE","description":"The SCORE statement enables you to use the fitted model for scoring. By using the IN= and OUT= options in the SCORE statement, you can create, reuse, and update a score store. The score store contains sufficient context information so that you can perform many tasks, such as scenario analysis and forecasting for streaming data, without having to fit the model again. The score store is a binary large object (BLOB) table, which uses a binary file format that cannot be edited or viewed like a typical data table.","help":"SCORE &lt;IN= *score-table*&gt;&lt;OUT=*score-table* ; &gt;","arguments":[{"name":"IN=","optional":true,"description":"specifies a previously created score store to score the rows in the input data table. The rows in the input data table must represent a continuation of the sequential observation process that was used to create the specified score store. In particular, for a given BY group, the smallest value of the ID variable in the current input data table must be the same as or larger than the largest value of the ID variable in the data table that you used to create the score store. When you specify the IN= option in the SCORE statement, the statements that are used for model specification (such as the MODEL, STATE, and TREND statements, and so on) are not needed; in addition to the PROC CSSM statement and the SCORE statement, only the BY and OUTPUT statements are used when needed.","help":"IN=*score-table*","type":"dataSet"},{"name":"OUT=","optional":true,"description":"specifies an output score-store table for storing the context information. The score store contains all the information that is needed for resuming the forecasting process from the last observation of a given BY group. If the OUT(k)= form of the option is used (where k is some positive integer), the score store keeps additional historical information so that the forecasting begins k time instances before the last observation. If k is larger than the total number of time points in a BY group, it is appropriately reduced. You should use the OUT(k)= form only at the time of score-store creation. In subsequent calls, the value of k that you specify at creation time remains in effect and cannot be changed. That is, k in OUT(k) is ignored when you also specify the IN= option.","help":"OUT&lt;(*positive-integer*)&gt;= *score-table*","type":"dataSet"}]},{"name":"SIMSMOOTH","description":"The SIMSMOOTH statement enables you to use the fitted model for simulation smoothing. (For more information, see the section Simulation Smoothing.) The OUTMODEL= option enables you to store the fitted model in a binary large object (BLOB) table to use later for simulation smoothing. The INMODEL= option enables you to load a previously stored fitted model and use it for simulation smoothing. The other options in this statement enable you to control different parts of the simulation smoothing process.","help":"SIMSMOOTH &lt;INMODEL= *blob-table*&gt;&lt;OUTMODEL= *blob-table*&gt;&lt;options&gt;;","arguments":[{"name":"INMODEL=","optional":true,"description":"specifies a previously created BLOB table that contains the fitted model for the input data table. When you specify this option in the SIMSMOOTH statement, the statements that are used for model specification (such as the MODEL, STATE, and TREND statements) are not needed. In addition to the PROC CSSM and SIMSMOOTH statements, only the options that control the simulation smoothing steps, such as the NSIM=, SEED=, and OUTPRED= options, are used.","help":"INMODEL=*blob-table*","type":"dataSet"},{"name":"NSIM=","optional":true,"description":"specifies the number of simulations to generate, where number is a positive integer. By default, NSIM=1.","help":"NSIM=*number*","type":"value"},{"name":"OUTCOMP=","optional":true,"description":"specifies an output data table to store the simulated components. This table contains the ID statement variable, the OBSINDEX statement variable (if specified), and the simulated components.","help":"OUTCOMP=*libref.data-table*","type":"dataSet"},{"name":"OUTMODEL=","optional":true,"description":"specifies a BLOB table to store the fitted model specification for later use in simulation smoothing. When you specify this option in the SIMSMOOTH statement, other options in this statement (such as the INMODEL= or NSIM= option) are ignored.","help":"OUTMODEL=*blob-table*","type":"dataSet"},{"name":"OUTPRED=","optional":true,"description":"specifies an output data table to store the simulated predictions of the missing response values. This table contains the ID statement variable, the OBSINDEX statement variable (if specified), and the simulated predictions of the missing response values.","help":"OUTPRED=*libref.data-table*","type":"dataSet"},{"name":"OUTSTATE=","optional":true,"description":"specifies an output data table to store the simulated latent states. This table contains the ID statement variable, the OBSINDEX statement variable (if specified), and the simulated states.","help":"OUTSTATE=*libref.data-table*","type":"dataSet"},{"name":"SEED=","optional":true,"description":"specifies the start of the set of random number seeds to use during the simulation process. As an example, if the number of simulations that you specify in the NSIM= option is 100 and SEED=5, then the seeds between 5 and 104 are sequentially used for random number generation during the 100 simulations. By default, SEED=1.","help":"SEED=*seed*","type":"value"}]},{"name":"STATE","description":"The STATE statement specifies a subsection of alpha alpha Subscript t, the overall state vector at time t (for more information, see the section State Space Model and Notation). You can specify multiple STATE statements, each specifying a separate subsection. It is assumed that the subsections that are specified by using different STATE statements are mutually independent. This independence assumption implies a block-diagonal structure for the transition matrices Tt and the disturbance covariances Qt for all t greater-than-or-equal-to 1. An appropriate block structure also applies to Wt and A1. The options in the STATE statement provide complete control over the description of the relevant blocks of Tt, Qt, Wt, and At. The argument dim (a positive integer in name (dim)) specifies the nominal dimension of this subsection. In most situations, the nominal dimension and the actual dimension of the state subsection are the same. However, when you specify the TYPE= option, the actual dimension of the state subsection can be different from the nominal dimension. The TYPE= option simplifies the state specification task for some commonly needed models.","help":"STATE *name(dim)*&lt;options&gt;;","arguments":[{"name":"A1","optional":true,"description":"treats the last nd elements of the state subsection as diffuse. This becomes the dimension of the relevant subsection of the diffuse vector delta. The A1 block is created by using appropriate columns of the identity matrix. The value of nd must lie between 1 and the nominal dimension, dim. The absence of this option signifies that this subsection of alphat is nondiffuse. If both the COV1 and A1 options are specified, the last nd rows and columns of the matrix specified in the COV1 option are taken to be 0. This option cannot be used together with the RANK= option of the COV1 option.","help":"A1(*nd*)","type":"value"},{"name":"CHECKBREAK","optional":true,"description":"turns on the checking of breaks for this state subsection. The ELEMENTWISE suboption requests the elementwise checking of any unexpected change in the state subsection as it evolves from one time point to the next. The OVERALL suboption requests a similar check for the entire state subsection—that is, in this case the change is measured as a multidimensional change. The ELEMENTWISE suboption is the default. Unless the PRINT=BREAKDETAIL option is specified, only a summary of the most significant breaks is produced. If the PRINT=BREAKDETAIL is specified, tables that contain the break significance statistics at every distinct time point are produced—one for the ELEMENTWISE suboption and one for the OVERALL suboption.","help":"CHECKBREAK &lt;ELEMENTWISE | OVERALL&gt;","type":"standaloneOrValue"},{"name":"COV","optional":true,"description":"specifies the relevant block of the disturbance covariance Qt (for t greater-than-or-equal-to 2) in the transition equation. As with the T option, the absence of this option signifies that this Q-block consists of only zeros. The structure of the Q-block is also similarly specified. However, the following differences exist: The list that is specified to form the covariance must result in a symmetric, positive semidefinite matrix; You can specify a rank constraint on the Q-block by specifying COV(RANK=integer), where the specified integer must lie between 1 and dim. A rank constraint is permissible only for the general form and only when its elements are not specified by using a list; The convention of treating unset variables as structural zeros, which is used in specifying sparsity of the T-block, is not used in the Q-block specification. Whenever you explicitly specify the entries of the Q-block by specifying a list of variables in parentheses, all variables in the list must evaluate to nonmissing values.","help":"COV(D) &lt;= *(var1 var2 …)* | *(number1 number2 …)*&gt; | COV(G) &lt;= *(var1 var2 …)* | *(number1 number2 …)*&gt; | COV(I) &lt;= *(variable)* | *(number)*&gt; | COV(RANK=*integer*)","type":"choice","arguments":[{"name":"COV","type":"standaloneOrValue"},{"name":"COV","type":"standaloneOrValue"},{"name":"COV","type":"standaloneOrValue"},{"name":"COV","type":"value"}]},{"name":"COV1","optional":true,"description":"specifies the relevant block of the initial state covariance Q1. The different options in this case have the same meaning as the options of the COV option. However, the following differences exist: If the elements of Q1 are specified by a list of variables in parentheses, then these variables must evaluate to constant values. In particular, they can depend on parameters that are specified by the PARMS statements; however, they cannot depend on any of the input data columns; If the initial condition is partially diffuse (that is, the diffuse dimension nd specified in the A1 option is nonzero), the last nd rows and columns of the matrix specified in COV1 are taken to be zero. Moreover, if the elements of Q1 are specified by a list, its number of elements must correspond to a matrix of dimension (dim – nd).","help":"COV1(D) &lt;= *(var1 var2 …)* | *(number1 number2 …)*&gt; | COV1(G) &lt;= *(var1 var2 …)* | *(number1 number2 …)*&gt; | COV1(I) &lt;= *(variable)* | *(number)*&gt; | COV1(RANK=*integer*)","type":"choice","arguments":[{"name":"COV1","type":"standaloneOrValue"},{"name":"COV1","type":"standaloneOrValue"},{"name":"COV1","type":"standaloneOrValue"},{"name":"COV1","type":"value"}]},{"name":"PRINT=","optional":true,"description":"requests printing of the respective system matrices and the printing of the break statistics at each distinct time point. You can specify PRINT=AR or PRINT=MA only if you specify the TYPE=VARMA option. If any of these matrices are time-varying, the matrix that corresponds to the first time instance is printed. For the BREAKDETAIL suboption to have any effect, the CHECKBREAK option must be turned on. If TYPE= option is used, the result of PRINT=COV can be different than the matrix supplied in the COV= option.","help":"PRINT= AR | BREAKDETAIL | COV | COV1 | MA | T | (&lt;AR&gt; | &lt;BREAKDETAIL&gt; | &lt;COV&gt; | &lt;COV1&gt; | &lt;MA&gt; | &lt;T&gt;","type":"choice","arguments":[{"name":"AR","type":"standalone"},{"name":"BREAKDETAIL","type":"standalone"},{"name":"COV","type":"standalone"},{"name":"COV1","type":"standalone"},{"name":"MA","type":"standalone"},{"name":"T","type":"standalone"},{"name":"(AR | BREAKDETAIL | COV | COV1 | MA | T","type":"standaloneOrValue"}]},{"name":"SINPUT","optional":true,"description":"specifies the relevant dim-dimensional block of the state input vector ct. The absence of this option signifies that this block of the ct vector consists of only zeros. If the elements of ct are specified by a list of variables in parentheses, then these variables must be independent of unknown parameters. In particular, they cannot be functions of parameters that are defined by the PARMS statements.","help":"SINPUT = *(var1 var2 …)* | *(number1 number2 …)*","type":"choice","arguments":[{"name":"(var1 var2 …)","placeholder":true,"type":"value"},{"name":"(number1 number2 …)","placeholder":true,"type":"value"}]},{"name":"T","optional":true,"description":"specifies the relevant block of the transition matrix Tt. The absence of this option signifies that this block consists of only zeros. You can specify the structure of the T-block by specifying T(I) for the identity form, T(D) for the diagonal form, and T(G) for a general unstructured form. In addition, you can explicitly specify the entries of the T-block by specifying a list of numbers in parentheses, or by specifying in parentheses a list of variables that are defined by using the programming statements. The unspecified elements of the T-block are included in the list of parameters to be estimated from the data. If the elements of the T-block are supplied by a list in parentheses, the number of elements in the list depends on its structure. For the diagonal form, the list must contain exactly dim elements. In the case of the identity form—T(I)—the block is already fully specified; however, a specification T(I)=(variable) is understood to mean that the identity block is scaled by the specified variable (or a number). In the general case—T(G)—the list must consist of dimension*dimension elements, specified in a rowwise fashion. An inappropriate number of elements in the list results in a syntax error.","help":"T(D) &lt;= *(var1 var2 …)* | *(number1 number2 …)*&gt; | T(G) &lt;= *(var1 var2 …)* | *(number1 number2 …)*&gt; | T(I) &lt;= *(variable)* | *(number)*&gt;","type":"choice","arguments":[{"name":"T","type":"standaloneOrValue"},{"name":"T","type":"standaloneOrValue"},{"name":"T","type":"standaloneOrValue"}]},{"name":"TYPE=","optional":true,"description":"specifies a state subsection that corresponds to the specified type. You can specify either a number or a variable for the RHO= and PERIOD= suboptions. When TYPE=VARMA, the autoregressive and moving average orders can be at most 1 (0 less-than-or-equal-to p less-than-or-equal-to 1 and 0 less-than-or-equal-to q less-than-or-equal-to 1). Moreover, by using the D and I flags with the order specification, you can impose additional structure on the autoregressive and moving average coefficient matrices—for example, specifying TYPE=VARMA(P=1) implies a VAR(1) model with general autoregressive coefficient matrix, whereas specifying TYPE=VARMA(P(D)=1) implies a VAR(1) model with diagonal autoregressive coefficient matrix. If you specify the TYPE= option, the T, COV1, SINPUT, and A1 options are not needed. In fact they are ignored, since the transition matrix Tt and the matrices in the initial condition (Q1 and A1) are implicitly defined by the choice of the type. However, the COV and W options can be useful. In fact, the specification of the COV option does play a key role in the eventual form of bold upper Q Subscript t—the covariance of the disturbance term in the transition equation. For the types LL, CYCLE, SEASON, and VARMA, the dimension of the resulting state subsection is a certain multiple of dim, the nominal dimension in the STATE statement.","help":"TYPE=WN | TYPE=RW | TYPE=LL &lt;(SLOPECOV( I | D | G)&lt;= (var1, var2, …) | (number1, number2, …)&gt;)&gt; | TYPE=LL (SLOPECOV(RANK=*integer*)) | TYPE=SEASON (LENGTH=*integer*&lt;DROPH=*number-list*&gt;&lt;KEEPH=*number-list*&gt;) | TYPE=CYCLE&lt;( &lt;CT&gt;&lt;RHO=*variable* | *number*&gt;&lt;PERIOD= *variable* | *number*&gt;)&gt; | TYPE=VARMA( &lt;p &lt;(I | D)&gt; =*integer*&gt;&lt;q&lt;(D)&gt;=*integer*&gt;)","type":"choice","arguments":[{"name":"TYPE=","type":"value"},{"name":"TYPE=","type":"value"},{"name":"TYPE=","type":"standaloneOrValue"},{"name":"TYPE=","type":"value"},{"name":"TYPE=","type":"value"},{"name":"TYPE=","type":"standaloneOrValue"},{"name":"TYPE=","type":"standaloneOrValue"}]},{"name":"W","optional":true,"description":"specifies the relevant block of the design matrix Wt in the transition equation. The W-block is of dimension sdim * sg, where sdim denotes the actual dimension of the state subsection (which can be the same as dim, the nominal dimension, or different if the TYPE= option is used) and sg denotes the desired size of the subsection of the overall state regression vector gamma. The absence of this option signifies that the state equation does not contain any regression effects. The number of variables supplied in the W(G)= list option must be a multiple of sdim. For example, if sdim = 4 and the W(G)= list contains 8 variables, then the implied size of gamma subsection is 2. If the W(D)= or W(I)= option is used, then the W-block is assumed to be an sdim-dimensional diagonal matrix and the W(D)= list must contain exactly sdim variables.","help":"W(D) &lt;= *(var1 var2 …)* | *(number1 number2 …)*&gt; | W(G) &lt;= *(var1 var2 …)* | *(number1 number2 …)*&gt; | W(I) &lt;= *(variable)* | *(number)*&gt;","type":"choice","arguments":[{"name":"W","type":"standaloneOrValue"},{"name":"W","type":"standaloneOrValue"},{"name":"W","type":"standaloneOrValue"}]}]},{"name":"TREND","description":"The TREND statement defines a term in the model that follows a stochastic pattern of a certain predefined type. The options in the TREND statement enable you to specify a wide variety of commonly used stochastic patterns. Each TREND statement in effect stands for a special pair of STATE and COMPONENT statements. You can specify more than one TREND statement. Each separate TREND statement defines a component that is assumed to be independent of all other component specifications in the model. Very often the TREND statement is used to specify a component that captures the time-varying level of the data. However, in many cases it is also used to define components of a more general nature; for example, it can be used to define a noise component that follows a stationary ARMA model.","help":"TREND *name**(type)*&lt;options&gt;;","arguments":[{"name":"name","description":"names the trend associated with the TREND statement. You can refer to the state that is associated with a TREND statement by appending the string \"_state_\" to the end of its name. For example, name_state_ is the state that is associated with a trend named name. You can use name_state_ in a COMPONENT statement to define a linear combination of its elements. The estimate of this linear combination can then be printed or output to a data set. The nominal dimension of name_state_ is taken to be 1, or the number of variables in the list that is specified in the CROSS= option in the TREND statement that is used to define name (see Example 14.4: Smoothing of Repeated Measures for Longitudinal Data for an example of such use of the COMPONENT statement).","type":"standalone"},{"name":"type","description":"specifies the type of trend used. The type can be any of the following:","type":"standalone"},{"name":"AR=","optional":true,"description":"lists the values of the coefficients of the nonseasonal autoregressive polynomial, phi(B) = 1 - phi1B - … - phipBp, where the order p is specified in the ARIMA trend specification. The coefficients phi Subscript i must define a stationary autoregressive polynomial.","help":"AR= *phi1 phi2...*","type":"value"},{"name":"CHECKBREAK","optional":true,"description":"turns on the checking of breaks for this trend component. The ELEMENTWISE suboption requests the elementwise checking of any unexpected change in the state subsection that is associated with the trend component. The OVERALL suboption requests a similar check for the entire state subsection—that is, in this case the change is measured as a multidimensional change. The ELEMENTWISE suboption is the default. Unless the PRINT=BREAKDETAIL option is specified, only a summary of the most significant breaks is produced. If the PRINT=BREAKDETAIL is specified, tables that contain the break significance statistics at every distinct time point are produced—one for the ELEMENTWISE suboption and one for the OVERALL suboption. If the CROSS= option is specified and the CROSS= list contains more than one variable, the OVERALL suboption considers subsections that are associated with each CROSS= variable separately.","help":"CHECKBREAK &lt;(ELEMENTWISE | OVERALL)&gt;","type":"standaloneOrValue"},{"name":"CROSS=","optional":true,"description":"creates a linear combination of one or more independent trend components that is based on the variables in the list. If the parameters of the trend are specified by options such as the LEVELVAR= option or the PHI= option, these parameters are shared by these constituent trends. The variables in the CROSS= list must be free of unknown parameters. The CROSS= option can be computationally expensive; computationally it is equivalent to specifying as many separate trends as the number of variables in the specified list.","help":"CROSS=*(var1, var2, …)* | CROSS(MATCHPARM)=*(var1, var2, …)*","type":"choice","arguments":[{"name":"CROSS=","type":"value"},{"name":"CROSS","type":"value"}]},{"name":"LEVELVAR=","optional":true,"description":"specifies the disturbance variance parameter for all the trend types. For trend types LL and DLL, this option specifies sigma1 squared. Any nonnegative value, including 0, is permissible. If variable contains unknown parameters, they are estimated from the data. Similarly, if the LEVELVAR= option is not specified, sigma squared is estimated from the data.","help":"LEVELVAR= *variable* | *number*","type":"choice","arguments":[{"name":"variable","placeholder":true,"type":"value"},{"name":"number","placeholder":true,"type":"value"}]},{"name":"MA=","optional":true,"description":"lists the values of the coefficients of the nonseasonal moving average polynomial, theta(B) = 1 - theta1B - … - thetaqBq, where the order q is specified in the ARIMA trend specification. The coefficients thetai must define an invertible moving average polynomial.","help":"MA= *theta1 theta2 ...*","type":"value"},{"name":"NODIFFUSE","optional":true,"description":"treats the diffuse elements in the initial state of the state subsection underlying the trend component as nondiffuse. This option is applicable to all trend types except ARIMA. For the ARIMA trend type, this option is ignored even if the nonseasonal or seasonal differencing orders are nonzero. The diffuse elements are assumed to be independent, zero-mean, Gaussian variables. Their variances become part of the parameter vector and are estimated by using the data. This option is useful for creating a trend component that can be interpreted as a deviation from an overall trend component (with diffuse initialization), which is defined separately.","type":"standalone"},{"name":"PHI","optional":true,"description":"specifies the value of phi for trend types DLL, DECAY, DECAY(OU), GROWTH, and GROWTH(OU). For the type DLL, the specified value must be between 0.0 and 1.0. For types DECAY and DECAY(OU), phi must be strictly negative. For types GROWTH and GROWTH(OU), phi must be strictly positive. If variable contains unknown parameters, they are estimated from the data. Similarly, if the PHI= option is not specified, phi is estimated from the data.","help":"PHI = *variable* | *number*","type":"choice","arguments":[{"name":"variable","placeholder":true,"type":"value"},{"name":"number","placeholder":true,"type":"value"}]},{"name":"PRINT=","optional":true,"description":"requests printing of the respective system matrices of the state equation that underlies the specified trend, the printing of its filtered and smoothed estimates, and the printing of the break statistics at each distinct time point. For the BREAKDETAIL suboption to have any effect, the CHECKBREAK option must be turned on. If any of these matrices are time-varying, the matrix that corresponds to the first time instance is printed.","help":"PRINT= BREAKDETAIL | COV | COV1 | FILTER | SMOOTH | T | (&lt;BREAKDETAIL&gt; | &lt;COV&gt; | &lt;COV1&gt; | &lt;FILTER&gt; | &lt;SMOOTH&gt; | &lt;T&gt;","type":"choice","arguments":[{"name":"BREAKDETAIL","type":"standalone"},{"name":"COV","type":"standalone"},{"name":"COV1","type":"standalone"},{"name":"FILTER","type":"standalone"},{"name":"SMOOTH","type":"standalone"},{"name":"T","type":"standalone"},{"name":"(BREAKDETAIL | COV | COV1 | FILTER | SMOOTH | T","type":"standaloneOrValue"}]},{"name":"SAR","optional":true,"description":"lists the values of the coefficients of the seasonal autoregressive polynomial, Phi(Bs) = 1 - Phi1Bs - … - PhiPBsP, where the order P is specified by using the SP= option in the ARIMA trend specification and the season length s is specified in the S= option. The coefficients Phii must define a stationary autoregressive polynomial.","help":"SAR = Phi1 Phi2 ...","type":"value"},{"name":"SMA","optional":true,"description":"lists the values of the coefficients of the seasonal moving average polynomial, Theta(Bs) = 1 - Theta1Bs - … - ThetaQBsQ, where the order Q is specified by using the SQ= option in the ARIMA trend specification and the season length s is specified in the S= option. The coefficients Thetai must define an invertible moving average polynomial.","help":"SMA = Theta1 Theta2 ...","type":"value"},{"name":"SLOPEVAR","optional":true,"description":"specifies the second disturbance variance parameter, sigma2 squared, for trend types LL and DLL. Any nonnegative value, including 0, is permissible. If variable contains unknown parameters, they are estimated from the data. Similarly, if the SLOPEVAR= option is not specified, sigma2 squared is estimated from the data.","help":"SLOPEVAR = *variable* | *number*","type":"choice","arguments":[{"name":"variable","placeholder":true,"type":"value"},{"name":"number","placeholder":true,"type":"value"}]}]}],"supportSiteInformation":{"docsetId":"casecon","docsetVersion":"latest","docsetTargetFile":"casecon_cssm_toc.htm"}}