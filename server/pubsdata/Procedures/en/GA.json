{"name":"GA","statements":[{"name":"PROC GA","description":"Genetic algorithms are a family of local search algorithms that seek optimal solutions to problems by applying the principles of natural selection and evolution. Genetic algorithms can be applied to almost any optimization problem and are especially useful for problems where other calculus-based techniques do not work, such as when the objective function has many local optima, when it is not differentiable or continuous, or when solution elements are constrained to be integers or sequences. In most cases genetic algorithms require more computation than specialized techniques that take advantage of specific problem structures or characteristics. However, for optimization problems with no such techniques available, genetic algorithms provide a robust general method of solution.","help":"PROC GA <DATAn=SAS-data-set><FIRSTGEN=SAS-data-set><LASTGEN=SAS-data-set><LIBRARY=library-list><MATRIXn=SAS-data-set><MAXITER=n><NOVALIDATEWARNING=n><SEED=n>;     \n\tABORT;\n\tARRAY <NOSYMBOLS> ;\n\tCALL routine(parameter-1<, ...parameter-n>);\n\tcall ContinueFor( niter );\n\tcall Cross( selected, seg, type<, parameter1, parameter2, ...> );\n\tcall Dynamic_array( arrayname, dim1<, dim2, ..., dim6> );\n\tcall EvaluateLC( lc, results, sum, selected, seg<, child> );\n\tcall GetDimensions( source, dest );\n\tcall GetObjValues( dest, n );\n\tcall GetSolutions( sol, n, seg );\n\tcall Initialize( option, size <,option, size> ... );\n\tcall MarkPareto( result, n, objectives, minmax );\n\tcall Mutate( selected, seg, type<, parameter1, parameter2, ...> );\n\tcall PackBits( array, start, width, value );\n\tcall ReEvaluate( <index>);\n\tcall ReadChild( selected, seg, n, values );\n\tcall ReadCompare( selected, seg, n, values );\n\tcall ReadMember( selected, seg, destination );\n\tcall ReadParent( selected, seg, n, destination );\n\tcall SetBounds( lower, upper <, seg> );\n\tcall SetCross( type<, seg><, pname, pvalue><, pname, pvalue>... );\n\tcall SetCrossProb( p );\n\tcall SetCrossRoutine( 'routine'<, nparents, nchildren>);\n\tcall SetElite( elite );\n\tcall SetEncoding( encoding );\n\tcall SetFinalize( 'routine' );\n\tcall SetMut( type<, seg><, pname, pvalue><, pname, pvalue>... );\n\tcall SetMutProb( p );\n\tcall SetMutRoutine( 'routine' );\n\tcall SetObj( type, minmax, <, seg><, pname, pvalue><, pname, pvalue>... );\n\tcall SetObjFunc( 'fname', minmax );\n\tcall SetProperty( optype <, seg>, pname, pvalue <, pname, pvalue>... );\n\tcall SetSel( selector <, pname, pvalue><, pname, pvalue>... );\n\tcall SetUpdateRoutine( 'routine' );\n\tcall ShellSort( x, <, by<, descend> > );\n\tcall Shuffle( x );\n\tcall UpdateSolutions( sol, n, seg );\n\tcall WriteChild( selected, seg, n, source );\n\tcall WriteMember( selected, seg, source );\n\tDELETE;\n\tDO <OVER><><> ...;\n\tELSE <DO><IF><THEN> ...;\n\tEND;\n\tENDSUB;\n\tFUNCTION <KIND= | GROUP='string'><VARARGS> ;\n\tGOTO label;\n\tIF <DO><NOT><THEN> ...;\n\t;\n\tOUTARGS out-argument-1, ..., out-argument-n;\n\tPUT <_ALL_><_INFILE_><_ODS_> ...;\n\t;\n\t;\n\tSTOP;\n\tSUBROUTINE <KIND= | GROUP='string'><OUTARGS><VARARGS> ...;\n\tWHEN <DO> ;\n\tWHERE where-expression-1;","arguments":[{"name":"DATA=","optional":true,"description":"Specifies a data set containing data required to specify the problem, where n is an integer from 1 to 5.","type":"value"},{"name":"FIRSTGEN=","optional":true,"description":"Specifies a SAS data set containing the initial solution generation.","help":"FIRSTGEN=*SAS-data-set*","type":"dataSet"},{"name":"LASTGEN=","optional":true,"description":"Specifies a SAS data set into which the final solution generation is written.","help":"LASTGEN=*SAS-data-set*","type":"dataSet"},{"name":"LIBRARY=","optional":true,"description":"Specifies a library or group of libraries for the procedure to search to resolve subroutine or function calls.","help":"LIBRARY=*library-list*","type":"dataSet"},{"name":"MATRIX=","optional":true,"description":"Specifies a data set containing two-dimensional matrix data, where n is an integer from 1 to 5. A two-dimensional numeric array with the same name as the option is created and initialized from the data set.","type":"value"},{"name":"MAXITER=","optional":true,"description":"Specifies the maximum number of iterations to permit for the optimization process. A ContinueFor call overrides a limit set by this option.","help":"MAXITER=*n*","type":"value"},{"name":"NOVALIDATEWARNING=","optional":true,"description":"Controls the output of warning messages related to solution validation checking.","help":"NOVALIDATEWARNING=*n*","type":"value"},{"name":"SEED=","optional":true,"description":"Specifies an initial seed to begin random number generation. This option is provided for reproducibility of results. If it is not specified, or if it is set to 0, a seed is chosen based on the system clock.","help":"SEED=*n*","type":"value"}]},{"name":"ABORT","description":"Terminates the current DATA step, job, or SAS session.","help":"ABORT"},{"name":"ARRAY","description":"Associates a name with a list of variables and constants.","help":"ARRAY &lt;NOSYMBOLS&gt;","arguments":[{"name":"NOSYMBOLS","optional":true,"followsDelimiter":"/","description":"Specifies that an array of numeric or character values be created without the associated element variables. In this case, the only way you can access elements in the array is by array subscripting.","type":"standalone"}]},{"name":"CALL","description":"Invokes a SAS CALL routine.","help":"CALL routine(parameter-1&lt;, ...parameter-n&gt;)"},{"name":"CALL ContinueFor","description":"Sets the number of additional iterations for the genetic algorithm optimization. niter specifies that the optimization continue for niter more iterations. To stop at the current iteration, set niter to 0.","help":"call ContinueFor( niter )"},{"name":"CALL Cross","description":"Executes a genetic crossover operator from within a user subroutine. The inputs to the subroutine are as follows: selected is an array that specifies the solutions to be crossed. seg is the desired segment of the solution to which the crossover operator should be applied. type is the type of crossover operator to apply, which also determines the number and type of parameters expected. The accepted values for type and the corresponding parameters are: 'arithmetic' real, integer 'cycle'--sequence 'heuristic'--real 'null'--all encodings 'order'--sequence 'pmatch'--sequence 'simple'--real, integer, Boolean 'twopoint'--real, integer, Boolean 'uniform'--real, integer, Boolean parameter1-n are optional parameters applicable to some operators.","help":"call Cross( selected, seg, type&lt;, parameter1, parameter2, ...&gt; )"},{"name":"CALL Dynamic_array","description":"Allocates a numeric array. The inputs to the Dynamic_array call are as follows: arrayname--is a previously declared array, whose dimensions are to be re-allocated. dim--is the size of the first dimension. dim2,...,dim6--are optional. Up to six dimensions can be specified. The Dynamic_array call is normally used to allocate working arrays when the required size of the array is data-dependent. It is often useful in user routines for genetic operators or objective functions to avoid hard-coding array dimensions that might depend on segment length or population size. The array to be allocated must first be declared in an ARRAY statement with the expected number of dimensions, as in the following example: subroutine sub(nx, ny); array x[1] /nosym; call dynamic_array(x, nx); array xy[1,1] /nosym; call dynamic_array(xy, nx, ny); ...","help":"call Dynamic_array( arrayname, dim1&lt;, dim2, ..., dim6&gt; )"},{"name":"CALL EvaluateLC","description":"Evaluates linear constraints. The inputs to the EvaluateLC subroutine are as follows: lc--is a two-dimensional array representing the linear constraints. results--is a numeric array to receive the magnitude of the constraint violation for each linear constraint. sum--is a variable to receive the sum of the constraint violations over all the constraints. selected--is an array identifying the selected solution. seg--is the segment of the solution to which the linear constraints apply. child--is an optional parameter, and should be specified only when EvaluateLC is called from a user crossover operator.","help":"call EvaluateLC( lc, results, sum, selected, seg&lt;, child&gt; )"},{"name":"CALL GetDimensions","description":"The inputs to the GetDimensions subroutine are as follows: source--is the array variable whose dimensions are desired. dest--is an array to receive the dimensions of source. The GetDimensions subroutine is used to get the dimensions of an array passed into a user subroutine. The input dest should be an array of one dimension, with at least as many elements as there are dimensions in source (a maximum of 6). Any extra elements in dest are filled with zeros.","help":"call GetDimensions( source, dest )"},{"name":"CALL GetObjValues","description":"The inputs to the GetObjValues subroutine are as follows: dest--is an array to receive the objective values. n--is the number of objective values to get. The GetObjValues subroutine is used to retrieve the objective values for the current solution generation. It can be called from a user update routine or finalize routine. If it is called from a finalize routine, and if the elite parameter from a SetElite call is 1 or greater, then the first elite members of the population are the fittest of the population, and they are sorted in order, starting with the most fit. The input dest should be a dimensioned variable, with dimension greater than or equal to n.","help":"call GetObjValues( dest, n )"},{"name":"CALL GetSolutions","description":"The inputs to the GetSolutions subroutine are as follows: sol--is an array to receive the solution elements. n--is the number of solutions to get. seg--is the segment of the solution to retrieve. The GetSolutions subroutine is used to retrieve solutions from the current generation. You would normally call it from an update or finalize subroutine for post processing or analysis. If the elite parameter has been set with a SetElite call, then the first elite members of the population are the fittest, and they are sorted in order, starting with the most fit. The sol variable should have two dimensions, with the first dimension representing the solution number, and the second representing the element within the solution.","help":"call GetSolutions( sol, n, seg )"},{"name":"CALL Initialize","description":"The inputs to the Initialize subroutine are as follows: option--is a string that specifies an initialization option. size--is the number of solutions to create by using a given option. The Initialize subroutine must be called to create the first solution generation, and can be used to reinitialize a solution population during the optimization process. The available options and their effect are as follows: '_uniform_'--generate uniformly distributed solutions '_dataset_'--read solutions from the data set specified in a FIRSTGEN= option. 'default'--read solutions from the data set specified in a FIRSTGEN= option, if one was specified. If none was specified or the data set has fewer observations than requested, fill in the remaining solution population by using the '_uniform_' option. '_retain_'--bring forward the best solutions from the current generation. This option cannot be used for the first initialization. 'user-routine'--Any string not matching the preceding options is interpreted to be a user-defined initialization routine. See the section \"Defining a User Initialization Routine\" for information about defining an initialization subroutine.","help":"call Initialize( option, size &lt;,option, size&gt; ... )"},{"name":"CALL MarkPareto","description":"The MarkPareto call is used to identify the Pareto-optimal subset from a population of solutions. The inputs to the MarkPareto call are as follows: result--is a one-dimensional array to accept the results of the evaluation. Its size should be the same as the size of the population being evaluated; result if solution i is Pareto optimal, and 0 otherwise. n--is a variable to receive the number of Pareto-optimal solutions. objectives--is a two-dimensional array that contains the multiple objective values for each solution. It should be dimensioned [p,q], where p is the size of the population, and q is greater than or equal to the number of objectives to be considered. minmax--is a one-dimensional array to specify how the objective values are to be used. It should be of size q, where q is greater than or equal to the number of objectives to be considered.","help":"call MarkPareto( result, n, objectives, minmax )"},{"name":"CALL Mutate","description":"Executes a genetic mutation operator from within a user subroutine. The inputs to the subroutine are as follows: selected--is an array that specifies the solution to be mutated. seg--is the desired segment of the solution to which the mutation should be applied. type--is the type of mutation operator to apply, which also determines the number and type of parameters expected. parameter1-n--are optional parameters applicable to some operators. The accepted values for type and the corresponding parameters are summarized in Table 1.2. [Type] [Encodings] [Parameters] 'delta' real, integer delta, n 'invert' sequence 'swap' sequence n 'uniform' real, integer, Boolean np The parameters are as follows: delta--is a vector of delta values for each component of the solution, used only for the Delta mutation operator. n--specifies the number of solution elements that should be mutated for the Delta operator, and the number of swaps that should be made for the Swap operator. np--specifies the number of solution elements that should be mutated, if np is integer; specifies the mutation probability for each solution element if 0 < np < 1.","help":"call Mutate( selected, seg, type&lt;, parameter1, parameter2, ...&gt; )"},{"name":"CALL PackBits","description":"The inputs to the PackBits subroutine are as follows: array--is an array to which the value is to be assigned. start--is the starting position for the bit assignments. width--is the number of bits to assign. value--is the value to be assigned to the bits. For a single bit, this should be 0 or 1. The PackBits subroutine facilitates the assignment of bit values into an integer array, effectively using the integer array as an array of bits. One common use for this routine is within a user genetic operator subroutine to pack bit values into an integer vector solution segment. The bit values assigned with the PackBits call can be retrieved with the UnpackBits function. The start parameter is the lowest desired bit position in the bit vector, where the least significant bit of value is to be stored. The start parameter can range in value from 1 to maxbits, where maxbits is the product of 32 times the number of elements in the integer array.","help":"call PackBits( array, start, width, value )"},{"name":"CALL ReEvaluate","description":"The inputs to the ReEvaluate subroutine are as follows: index is a numeric scalar or array that specifies the indices of the solutions to be updated. The indices correspond to the order of the solutions obtained from a GetSolutions call. The ReEvaluate call recomputes the objective values for the current generation. You do not normally need to use this call, because the GA procedure evaluates the objective function during the optimization process in the evaluation phase. This subroutine should be called from a user update or finalize routine if a parameter that affects the objective value or solution is changed. The optional index parameter enables you to restrict the recomputation to the solution or subset of solutions specified. If the index parameter is not supplied, then the objective values of all the solutions will be recomputed.","help":"call ReEvaluate( &lt;index&gt;)"},{"name":"CALL ReadChild","description":"The inputs to the ReadChild subroutine are as follows: selected--specifies the family (parents and children) obtained from the selection process. seg--specifies the solution segment to be read. n--specifies the child in the family from which to read the solution segment. values--specifies an array to receive the solution elements. The ReadChild call is used to obtain the solution values for manipulation within a user crossover operator subroutine.","help":"call ReadChild( selected, seg, n, values )"},{"name":"CALL ReadCompare","description":"The inputs to the ReadCompare subroutine are as follows: selected--specifies the pair of solutions to be compared, obtained from the selection process. seg--specifies the solution segment to be read. n--specifies the solution (1 or 2) from which to read the segment. values--specifies an array to receive the solution elements. The ReadCompare call is used to obtain the solution values for manipulation within a user fitness comparison subroutine, which can be designated in a SetCompareRoutine call.","help":"call ReadCompare( selected, seg, n, values )"},{"name":"CALL ReadMember","description":"The inputs to the ReadMember subroutine are as follows: selected--is a parameter passed to the user subroutine by the GA procedure, which points to the selected solution. seg--specifies which segment of the solution to retrieve. destination--specifies an array in which to store the solution elements. The ReadMember call is used within a user objective function or mutation operator to obtain the elements of a selected solution and write them into a specified vector. They can then be used to compute an objective value, or in the case of a mutation operator, manipulated and written back out with a WriteMember call.","help":"call ReadMember( selected, seg, destination )"},{"name":"CALL ReadParent","description":"The inputs to the ReadParent subroutine are as follows: selected--is a parameter passed to the user subroutine by the GA procedure, which points to the selected solution family. seg--is the segment of the desired parent solution to be obtained. n--is the number of the parent, starting at 1. destination--is an array in which to store the solution elements. The ReadParent subroutine is called inside a user crossover operator subroutine to obtain the elements of selected parent solutions. Normally you would then manipulate and combine the elements of the two parents and use a WriteChild call to create the child offspring and complete the action of the crossover operator.","help":"call ReadParent( selected, seg, n, destination )"},{"name":"CALL SetBounds","description":"The inputs to the SetBounds subroutine are as follows: lower--is a lower bound for the solution components. upper--is an upper bound for the solution components. seg--is optional, and specifies a segment of the solution to which the bounds apply. If seg is not specified, then it defaults to a value of 1. The SetBounds subroutine is used to establish upper and lower bounds on the solution space. It applies only to integer and real encoding.","help":"call SetBounds( lower, upper &lt;, seg&gt; )"},{"name":"CALL SetCross","description":"The inputs to the SetCross subroutine are as follows: type--is the name of the crossover operator to be applied. seg--is optional, and specifies a segment of the solution to which the operator should be applied. If seg is not specified, then it defaults to a value of 1. seg needs to be specified only if multisegment encoding is used. pname--is optional, and specifies the name of a particular property to be set for the crossover operator. pvalue--specifies the value to be assigned to the corresponding property name. The accepted values for type and the corresponding properties are: [type] [encodings] [properties] 'arithmetic' real, integer 'cycle' sequence 'heuristic' real 'order' sequence 'pmatch' sequence 'simple' real, integer, Boolean 'alpha' 'twopoint' real, integer, Boolean 'alpha' 'uniform' real, integer, Boolean 'alpha', 'p' The SetCross routine is used to assign a standard crossover operator. For multisegment encoding, the operator can be assigned to a particular solution segment with the seg parameter; otherwise a default segment of 1 is assumed.","help":"call SetCross( type&lt;, seg&gt;&lt;, pname, pvalue&gt;&lt;, pname, pvalue&gt;... )"},{"name":"CALL SetCrossProb","description":"The input to the SetCrossProb subroutine is as follows: p--is the crossover probability. The SetCrossProb subroutine is used to set the crossover probability for the genetic algorithm optimization process. The crossover probability p should be between 0 and 1. Typical values for this parameter range from 0.6 to 1.0. The crossover probability will be overridden if required by a SetElite call. The elite solutions are passed on to the next generation without undergoing crossover, regardless of the crossover probability.","help":"call SetCrossProb( p )"},{"name":"CALL SetCrossRoutine","description":"The inputs to the SetCrossRoutine subroutine are as follows: routine--is the name of a subroutine you have defined, which is called when the mutation operator is applied. This parameter must be a string literal; a variable is not accepted. nparents--is optional, and specifies the number of parent solutions the operator requires. If not specified, 2 is assumed. nchildren--is optional, and specifies the number of children solutions the operator will generate. If not specified, 2 is assumed. Installs a user subroutine for the crossover operator.","help":"call SetCrossRoutine( 'routine'&lt;, nparents, nchildren&gt;)"},{"name":"CALL SetElite","description":"The input to the SetElite subroutine is as follows: elite--is the number of best solutions to be passed unmodified from the current solution generation to the next. The SetElite subroutine is used to ensure that the best solutions encountered in the optimization are not lost by the random selection process. In pure tournament selection, although better solutions are more likely to be selected, it is also possible that any given solution will not be chosen to participate in a tournament, and even if it is selected, it might be modified by crossover or mutation. The SetElite call modifies the optimization process such that the best elite solutions in the current population are exactly preserved and passed on to the next generation. This behavior is observed regardless of the crossover or mutation settings. When a SetElite call is made, the first elite solutions in the population retrieved by a GetSolutions call or output to a data set are the fittest, and these elite solutions are sorted so that the most fit is first. In general, using the SetElite call speeds the convergence of the optimization process. However, it can also lead to premature convergence before a true global optimum is reached. If no SetElite call is made, a default elite value of 1 is used by the GA procedure to make sure that the best solution encountered in the optimization process is never lost.","help":"call SetElite( elite )"},{"name":"CALL SetEncoding","description":"The input to the SetEncoding subroutine is as follows: encoding--is a string used to specify the form of the solution. The SetEncoding subroutine is used to establish the type of problem solution encoding. The encoding parameter should be a string of letter-number pairs, where the letter determines the type of encoding: I for integer, R for real-valued, S for sequences, and B for Boolean values. Each letter is followed by a number to indicate the number of components for that encoding. Multiple letter-number pairs can be used to specify a multisegment encoding. For example, the following call specifies that solutions be in the form of a 10-member integer vector: call SetEncoding('I10'); The following call specifies that solutions have a 5-component integer segment and a 10-component real-valued segment: call SetEncoding('I5R10');","help":"call SetEncoding( encoding )"},{"name":"CALL SetFinalize","description":"The input to the SetFinalize subroutine is as follows: routine--is the name of a subroutine you have defined, which is called when the optimization process ends. This parameter must be a string literal; a variable is not accepted. The SetFinalize subroutine enables you to define a subroutine to be called at the end of the optimization process. You might use this subroutine to perform additional refinements of the best solution, or you could generate and write out additional data for plots or reports.","help":"call SetFinalize( 'routine' )"},{"name":"CALL SetMut","description":"The inputs to the SetMut subroutine are as follows: type--is the name of the mutation operator to be applied. seg--is optional, and specifies a segment of the solution to which the operator should be applied. If seg is not specified, then it defaults to a value of 1. seg needs to be specified only if multisegment encoding is used. pname--is optional, and specifies the name of a particular property to be set for the mutation operator. pvalue--specifies the value to be assigned to the corresponding property name. The SetMut routine is used to assign a standard mutation operator. For multisegment encoding, the operator can be assigned to a particular solution segment with the seg parameter; otherwise a default segment of 1 is assumed. You can set different mutation operators for different segments with multiple SetMut calls. When a mutation event occurs, all the operators will applied to the same solution. If more than one SetMut call is made for the same segment, then the last call nullifies any previous call for that segment. Also, a SetMutRoutine call nullifies all previous SetMut calls, and a SetMut call nullifies a previous SetMutRoutine call. Properties for the chosen mutation operator can be set with optional pname-pvalue pairs. It is also possible to set or reset operator properties with a SetProperty call. The accepted values for type and the corresponding properties are: [type] [encodings] [properties] 'delta' real, integer 'delta', 'nchange' 'invert' sequence 'null' all encodings 'swap' sequence 'nswap' 'uniform' real, integer, Boolean 'nchange','pchange'","help":"call SetMut( type&lt;, seg&gt;&lt;, pname, pvalue&gt;&lt;, pname, pvalue&gt;... )"},{"name":"CALL SetMutProb","description":"The input to the SetMutProb subroutine is as follows: p--is the mutation probability. The SetMutProb subroutine is used to set the mutation probability for the genetic algorithm optimization. The probability p should be a number between 0 and 1, and is interpreted as the probability that a solution in the next generation should have the mutation operator applied to it. If a SetElite call has been made, then the elite solutions do not undergo mutation. Generally, a high mutation probability degrades the convergence of the genetic algorithm optimization, but some level of mutation is required to assure a thorough search and avoid premature convergence before the global optimum is found. Typical values for p are near 0.05 or less.","help":"call SetMutProb( p )"},{"name":"CALL SetMutRoutine","description":"The input to the SetMutRoutine subroutine is as follows: routine--is the name of a subroutine you have defined, which is called when the mutation operator is applied. This parameter must be a string literal; a variable is not accepted. The SetMutRoutine call enables you to designate a subroutine you have defined to be used for the mutation operator. Your subroutine will be called whenever the mutation operation is performed.","help":"call SetMutRoutine( 'routine' )"},{"name":"CALL SetObj","description":"The inputs to the SetObj subroutine are as follows: type--is the name of the objective function to be used. minmax--is an indicator to maximize or minimize the objective. A value of 0 is used to specify a minimization, and a value of 1 to specify maximizing the objective. seg--is optional, and specifies a segment of the solution to which the objective function should be applied. If seg is not specified, then it defaults to a value of 1. seg needs to be specified only if multisegment encoding is used. pname--is optional, and specifies the name of a particular property to be set for the objective function. pvalue--specifies the value to be assigned to the corresponding property name. The SetObj routine is used to assign a procedure-supplied objective function. For multisegment encoding, the objective can be assigned to a particular solution segment with the seg parameter; otherwise a default segment of 1 is assumed. If more than one SetObj call is made, then the last call nullifies any previous call. Also, a SetObjFunc call nullifies all previous SetObj calls, and a SetObj call nullifies a previous SetObjFunc call. Properties for the chosen objective can be set with optional pname-pvalue pairs. It is also possible to set or reset objective properties with a SetProperty call.","help":"call SetObj( type, minmax, &lt;, seg&gt;&lt;, pname, pvalue&gt;&lt;, pname, pvalue&gt;... )"},{"name":"CALL SetObjFunc","description":"The inputs to the SetObjFunc subroutine are as follows: fname--is the name of a user objective function. This parameter must be a literal string. minmax--is set to 0 to minimize the objective, 1 to maximize. The SetObjFunc subroutine is used to designate a user function to be the objective for the optimization process. The SetObjFunc call accepts a literal string only for the function name; you cannot use a variable or expression.","help":"call SetObjFunc( 'fname', minmax )"},{"name":"CALL SetProperty","description":"The inputs to the SetProperty subroutine are as follows: optype--is the type of operator. It should have a value of 'cross' for a crossover operator, 'mut' for a mutation operator, 'obj' for an objective function, or 'sel' for a selector. seg--is optional, used only for mutation and crossover operators, and specifies the segment in which the operator resides. It is necessary only for multisegment encoding. The default value if seg is not specified is 1. pname--specifies the name of a particular property to be set. pvalue--specifies the value to be assigned to the corresponding property name. Multiple property name-value pairs can be supplied in a SetProperty call. The SetProperty call is used to set or modify properties of a genetic operator, objective function, or a selector. It can be called anytime during the optimization process to dynamically adapt optimization parameters. For example, you might call SetProperty from a user update routine to reduce the magnitude of the delta vector of a delta mutation operator as the optimization progresses to an optimum.","help":"call SetProperty( optype &lt;, seg&gt;, pname, pvalue &lt;, pname, pvalue&gt;... )"},{"name":"CALL SetSel","description":"The inputs to the SetSel subroutine are as follows: selector--is the type of selection strategy to be used. pname--is optional, and specifies the name of a particular property to be set for the selector operator. pvalue--specifies the value to be assigned to the corresponding property name. The supported values for selector and the corresponding selector properties and their default values are: [Selector] [Properties] [Default values] 'tournament' 'size' 2 'duel' 'pbest' 0.8 The SetSel call is used to specify a selector for the regeneration process, which selects members of the current generation to be propagated to the next.","help":"call SetSel( selector &lt;, pname, pvalue&gt;&lt;, pname, pvalue&gt;... )"},{"name":"CALL SetUpdateRoutine","description":"The input to the SetUpdateRoutine subroutine is as follows: routine--is the name of a subroutine you have defined that is called once during each iteration of the optimization process. This parameter must be a string literal; a variable is not accepted. The SetUpdate subroutine enables you to define a subroutine to be called at each iteration of the optimization process, in order to monitor the progress of the genetic algorithm, adjust optimization parameters, or perform calculations that depend on the population as a whole.","help":"call SetUpdateRoutine( 'routine' )"},{"name":"CALL ShellSort","description":"The inputs to the ShellSort subroutine are as follows: x--is a one or two dimensional array to be sorted. by--is an optional numeric scalar or array that specifies the columns by which the array is to be sorted. If not specified, column 1 is the default. descend--is an optional numeric scalar or array used to specify which columns in the by parameter are to be in descending order. Any columns not specified in a descend parameter will be in ascending order. The ShellSort subroutine sorts the x array by the columns specified in the by parameter, with the first column having highest precedence, and subsequent columns applied within the preceding by groups. Sorting will be done in ascending order for each column unless that column is also specified in the descend parameter. In general the ShellSort routine does not preserve the original order in case of ties.","help":"call ShellSort( x, &lt;, by&lt;, descend&gt; &gt; )"},{"name":"CALL Shuffle","description":"The input to the Shuffle subroutine is as follows: x--is a numeric array to be randomly shuffled. The Shuffle subroutine randomly rearranges the elements of the x array. One example of where it might be used is in a user-supplied initialization routine, to generate a random sequence-encoded solution segment.","help":"call Shuffle( x )"},{"name":"CALL UpdateSolutions","description":"The inputs to the UpdateSolutions subroutine are as follows: sol--is an array containing the replacement solution elements. n--is the number of solutions to update. seg--is the segment of the solution to replace. The UpdateSolutions subroutine is used to replace the values of the selected solution segment with new values computed in an update routine. The update routine can be designated in a SetUpdateRoutine call. The UpdateSolutions call is often used to implement advanced strategies such as marking Pareto-optimal sets or employing local optimizations. The sol parameter should have 2 dimensions. The first dimension represents the solution number, and should have a value of n or greater. The second dimension represents the element within the solution seg, and should be equal to the segment size.","help":"call UpdateSolutions( sol, n, seg )"},{"name":"CALL WriteChild","description":"The inputs to the WriteChild subroutine are as follows: selected--is an array specifying the selected family of solutions. The selected array is normally passed into the user subroutine that calls WriteChild, and should be passed unaltered to WriteChild. seg--is the segment to which the elements are to be written. n--is the child within the family to which the elements are to be written. A value of 1 is for the first child, 2 for the second, and so on. source--is an array containing the values to be written. The WriteChild subroutine is called inside a user crossover operator subroutine to assign to the elements of a selected child solution. It is normally used to complete the action of the crossover operator.","help":"call WriteChild( selected, seg, n, source )"},{"name":"CALL WriteMember","description":"The inputs to the WriteMember subroutine are as follows: selected--is an array specifying the selected family of solutions. The selected array is normally passed into the user subroutine that calls WriteMember, and should be passed unaltered to WriteMember. seg--is the segment to which the elements are to be written. source--is an array containing the values to be written. Assigns values to a selected solution from within a user objective function or mutation operator. It is normally used to complete the action of the objective function or mutation operator.","help":"call WriteMember( selected, seg, source )"},{"name":"DELETE","description":"Stops processing the current observation.","help":"DELETE"},{"name":"DO","description":"","help":"DO &lt;OVER&gt;&lt;&gt;&lt;&gt; ...","arguments":[{"name":"BY","optional":true,"description":"Precedes an increment integer (other than 0) or an expression that generates an integer to be added to the value of the index variable in each iteration of the DO loop.","type":"standalone"},{"name":"OVER","optional":true,"description":"","type":"standalone"},{"name":"TO","optional":true,"description":"Separates the start and stop integers or expressions that control the number of times the portion of the DATA step between the iterative DO and END statements is processed.","type":"standalone"},{"name":"UNTIL","optional":true,"description":"...more SAS statements... END","type":"standalone"},{"name":"WHILE","optional":true,"description":"","type":"standalone"}]},{"name":"ELSE","description":"If the condition in an IF-THEN statement is false and an ELSE statement is present, then the ELSE action is carried out.","help":"ELSE &lt;DO&gt;&lt;IF&gt;&lt;THEN&gt; ...","arguments":[{"name":"AND","optional":true,"description":"","type":"standalone"},{"name":"DO","optional":true,"description":"DO statement in an IF-THEN/ELSE construct.","type":"standalone"},{"name":"IF","optional":true,"description":"Executes a SAS statement for observations that meet specific conditions.","type":"standalone"},{"name":"NOT","optional":true,"description":"","type":"standalone"},{"name":"OR","optional":true,"description":"","type":"standalone"},{"name":"THEN","optional":true,"description":"If the conditions that are specified in the IF clause are met, the IF-THEN statement executes a SAS statement for observations that are read from a SAS data set, for records in an external file, or for computed values.","type":"standalone"}]},{"name":"END","description":"Ends a DO group or SELECT group processing.","help":"END"},{"name":"ENDSUB","description":"Ends a FUNCTION or SUBROUTINE statement block.","help":"ENDSUB"},{"name":"FUNCTION","description":"Specifies a subroutine declaration for a routine that returns a value.","help":"FUNCTION &lt;KIND= | GROUP='string'&gt;&lt;VARARGS&gt;","arguments":[{"name":"KIND=","optional":true,"aliases":["GROUP="],"description":"Specifies a collection of items that have specific attributes.","type":"value"},{"name":"VARARGS","optional":true,"description":"Specifies that the function supports a variable number of arguments. If you specify VARARGS, then the last argument in the function must be an array.","type":"standalone"}]},{"name":"GOTO","aliases":["GO TO"],"description":"Jumps to a new statement.","help":"GOTO label"},{"name":"IF","description":"","help":"IF &lt;DO&gt;&lt;NOT&gt;&lt;THEN&gt; ...","arguments":[{"name":"AND","optional":true,"description":"","type":"standalone"},{"name":"DO","optional":true,"description":"DO statement in an IF-THEN construct.","type":"standalone"},{"name":"NOT","optional":true,"description":"","type":"standalone"},{"name":"OR","optional":true,"description":"","type":"standalone"},{"name":"THEN","optional":true,"description":"If the conditions that are specified in the IF clause are met, the IF-THEN statement executes a SAS statement for observations that are read from a SAS data set, for records in an external file, or for computed values.","type":"standalone"}]},{"name":"OTHERWISE","description":">","help":""},{"name":"OUTARGS","description":"Specifies arguments from the argument list that the subroutine should update.","help":"OUTARGS out-argument-1, ..., out-argument-n"},{"name":"PUT","description":"Writes lines to the SAS log, to the SAS output window, or to an external location that is specified in the most recent FILE statement.","help":"PUT &lt;_ALL_&gt;&lt;_INFILE_&gt;&lt;_ODS_&gt; ...","arguments":[{"name":"OVERPRINT","optional":true,"description":"Causes the values that follow the keyword OVERPRINT to print on the most recently written output line.","type":"standalone"},{"name":"_ALL_","optional":true,"description":"Writes the values of all variables, which includes automatic variables, that are defined in the current DATA step by using named output.","type":"standalone"},{"name":"_BLANKPAGE_","optional":true,"description":"Advances the pointer to the first line of a new page, even when the pointer is positioned on the first line and the first column of a new page.","type":"standalone"},{"name":"_INFILE_","optional":true,"description":"Writes the last input data record that is read either from the current input file or from the data lines that follow a DATELINES statement.","type":"standalone"},{"name":"_ODS_","optional":true,"description":"Moves data values for all columns (as defined by the ODS option in the FILE statement) into a special buffer, from which it is eventually written to the data component. The ODS option in the FILE statement defines the structure of the data component that holds the results of the DATA step.","type":"standalone"},{"name":"_PAGE_","optional":true,"description":"Advances the pointer to the first line of a new page. SAS automatically begins a new page when a line exceeds the current PAGESIZE= value.","type":"standalone"}]},{"name":"RETURN","description":"(1) RETURN; Stops executing statements at the current point in the DATA step and returns to a predetermined point in the step. (2) RETURN (expression); Statement within a FUNCTION-ENDSUB block.","help":""},{"name":"SELECT","description":"","help":""},{"name":"STOP","description":"Stops execution of the current DATA step.","help":"STOP"},{"name":"SUBROUTINE","description":"Declares (creates) an independent computational block of code that you can call using a CALL statement.","help":"SUBROUTINE &lt;KIND= | GROUP='string'&gt;&lt;OUTARGS&gt;&lt;VARARGS&gt; ...","arguments":[{"name":"KIND=","optional":true,"aliases":["GROUP="],"description":"Specifies a collection of items that have specific attributes.","type":"value"},{"name":"OUTARGS","optional":true,"description":"Specifies arguments from the argument list that the subroutine should update.","type":"standalone"},{"name":"VARARGS","optional":true,"description":"Specifies that the subroutine has a variable argument length. In this case, the last argument must be an array. The array accepts the variable arguments.","type":"standalone"}]},{"name":"WHEN","description":"","help":"WHEN &lt;DO&gt;","arguments":[{"name":"DO","optional":true,"description":"","type":"standalone"}]},{"name":"WHERE","description":"Selects observations from SAS data sets that meet a particular condition.","help":"WHERE where-expression-1"}],"supportSiteInformation":{"docsetId":"orlsoug","docsetVersion":"v_001","docsetTargetFile":"orlsoug_ga_toc.htm"}}