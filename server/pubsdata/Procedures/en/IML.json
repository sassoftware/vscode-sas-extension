{"name":"IML","statements":[{"name":"PROC IML","description":"where n1 and n2 are specified in kilobytes. † The SYMSIZE= and WORKSIZE= options in the PROC IML statement give you control over the size of memory allocated to the symbol space and the size of each extent of workspace. If you do not specify these options, PROC IML uses host dependent defaults. SAS/IML software gives you access to a powerful and flexible programming language (Interactive Matrix Language) in a dynamic, interactive environment. The fundamental object of the language is a data matrix. You can use SAS/IML software interactively (at the statement level) to see results immediately, or you can store statements in a module and execute them later. The programming is dynamic because necessary activities such as memory allocation and dimensioning of matrices are performed automatically. † SAS/IML software is powerful. You can access built-in operators and call routines to perform complex tasks such as matrix inversion or eigenvector generation. You can define your own functions and subroutines by using SAS/IML modules. You can perform operations on a single value or take advantage of matrix operators to perform operations on an entire data matrix.","help":"PROC IML <SYMSIZE=n1> <WORKSIZE=n2>;     \n\tABORT ;\n    \n\tAPPEND <FROM matrix-name> <VAR operand> <_ALL_> ...;\n    \n\tCALL name <(arguments)> ;\n    \n\tCLOSE <SAS-data-set>;\n    \n\tCLOSEFILE files;\n    \n\tCREATE <FROM matrix-name> <VAR operand> <_ALL_> ...;\n    \n\tDELETE <ALL> <CURRENT> <WHERE(expression)> ...;\n    \n\tDISPLAY <BELL> <NOINPUT> <REPEAT> ...;\n    \n\tDO <OVER> <> <> ...;\n    \n\tDO DATA <TO> ;\n    \n\t;\n    \n\t;\n    \n\tEDIT <NOBS> <VAR> ;\n    \n\tELSE <DO> <IF> <THEN> ...;\n    \n\tEND;\n    \n\tENDSUBMIT ;\n    \n\tFILE <LRECL=operand> <RECFM=N> ;\n    \n\tFIND <ALL> <INTO> <WHERE(expression)> ...;\n    \n\tSTART <name> <(arguments)> <GLOBAL(arguments)>;\n    \n\tFREE matrices; | FREE / <matrices>;\n    \n\tGO TO label | GOTO label;\n    \n\tIF <DO> <THEN> <WHEN> ...;\n    \n\tINDEX <NONE> ;\n    \n\tINFILE <FLOWOVER> <LENGTH=variable> <RECFM=N> ...;\n    \n\tINPUT <variables> <informats> <record-directives> <positionals>;\n    \n\tLINK label;\n    \n\tLIST <ALL> <VAR operand> <WHERE(expression)> ...;\n    \n\tLOAD <MODULE=(module-list)> <_ALL_> ;\n    \n\tMATTRIB <COLNAME=column-name> <LABEL=label> <ROWNAME=row-name> ...;\n    \n\tPACKAGE HELP packagename<(collection )>;\n    \n\tPACKAGE INFO packagename<(collection )> …;\n    \n\tPACKAGE INSTALL <PARSETIME> ;\n    \n\tPACKAGE LIBNAME libref packagename;\n    \n\tPACKAGE LIST <collection> ;\n    \n\tPACKAGE LOAD <VERSION=> ;\n    \n\tPACKAGE UNINSTALL <NOWARN> <PARSETIME> ;\n    \n\tPAUSE <expression> <*>;\n    \n\tPRINT <COLNAME=> <FORMAT=> <LABEL=> ...;\n    \n\tPURGE;\n    \n\tPUT <operand> <record-directives> <positionals> <format>;\n    \n\tQUIT ;\n    \n\tREAD <ALL> <VAR> <WHERE(variable comparison-op operand)> ...;\n    \n\tREMOVE <MODULE=(module-list)> <_ALL_> ;\n    \n\tREPLACE <ALL> <VAR> <WHERE(expression)> ...;\n    \n\tRESET <AUTONAME> <CENTER> <NOAUTONAME> ...;\n    \n\tRESUME;\n    \n\tRETURN <(operand)>;\n    \n\tRUN <name> <(arguments)>;\n    \n\tSAVE ;\n    \n\tSETIN <NOBS> <POINT> ;\n    \n\tSETOUT <NOBS name> <POINT operand> ;\n    \n\tSHOW <ALL> <ALLNAMES> <CONTENTS> ...;\n    \n\tSORT <BY variables> <DATA=SAS-data-set> <OUT=SAS-data-set> ...;\n    \n\tSTART <GLOBAL(arguments)> ;\n    \n\tSTOP ;\n    \n\tSTORE <MODULE=(module-list)> <_ALL_> ;\n    \n\tSUBMIT <OK=ok-matrix> <R> ;\n    \n\tSUMMARY <CLASS operand> <VAR operand> <WEIGHT operand> ...;\n    \n\tUSE <NOBS name> <VAR operand> <WHERE(expression)> ...;\n    \n\tWINDOW <CLOSE=window-name> <CMNDLINE=name> <GROUP=group-name> ...;\n","arguments":[{"name":"SYMSIZE=","optional":true,"description":"Gives you control over the size of memory allocated to the symbol space.","help":"SYMSIZE=*n1*","type":"value"},{"name":"WORKSIZE=","optional":true,"description":"Gives you control over the size of each extent of workspace.","help":"WORKSIZE=*n2*","type":"value"}]},{"name":"ABORT","description":"The ABORT statement instructs IML to stop executing statements. It also stops IML from parsing any further statements, causing IML to close its files and exit.","help":"ABORT "},{"name":"APPEND","description":"where: operand can be specified as one of the following: o a literal containing variable names o a character matrix containing variable names o an expression in parentheses yielding variable names o one of the keywords described in the following list: _ALL_ -- for all variables _CHAR_ -- for all character variables _NUM_ -- for all numeric variables from-name -- is the name of a matrix containing data to append. row-name -- is a character matrix or quoted literal containing descriptive row names. Use the APPEND statement to add data to the end of the current output data set. The appended observations are from either the variables specified in the VAR clause or variables created from the columns of the FROM matrix. The FROM clause and the VAR clause should not be specified together. You can specify a set of variables to use with the VAR clause.","help":"APPEND &lt;FROM matrix-name&gt; &lt;VAR operand&gt; &lt;_ALL_&gt; ...","arguments":[{"name":"FROM","optional":true,"description":"The variables in the new SAS data set are variables created from the columns of the FROM matrix.","type":"standalone"},{"name":"VAR","optional":true,"description":"where","type":"standalone"},{"name":"_ALL_","optional":true,"description":"For all variables","type":"standalone"},{"name":"_CHAR_","optional":true,"description":"For all character variables","type":"standalone"},{"name":"_NUM_","optional":true,"description":"For all numeric variables","type":"standalone"}]},{"name":"CALL","description":"The inputs to the CALL statement are as follows: name is the name of a user-defined module or an IML subroutine or function. arguments are arguments to the module or subroutine. The CALL statement executes a subroutine. The order of resolution for the CALL statement is as follows: 1.IML built-in subroutine 2. user-defined module This resolution order needs to be considered only if you have defined a module with the same name as an IML built-in subroutine.","help":"CALL name &lt;(arguments)&gt; "},{"name":"CLOSE","description":"where SAS-data-set can be specified with a one-level name (for example, A) or a two-level name (for example, SASUSER.A). More than one SAS data set can be listed in a CLOSE statement. The CLOSE statement is used to close one or more SAS data sets opened with the USE, EDIT, or CREATE statement. To find out which data sets are open, use the SHOW DATASETS statement; see also the section on the SAVE statement later in this chapter. IML automatically closes all open data sets when a QUIT statement is executed.","help":"CLOSE &lt;SAS-data-set&gt;"},{"name":"CLOSEFILE","description":"where files can be names (for defined filenames), literals, or expressions in parentheses (for pathnames). The CLOSEFILE statement is used to close files opened by the INFILE or FILE statement. The file specification should be the same as when the file was opened. File specifications are either a name (for a defined filename), a literal, or an expression in parentheses (for a pathname). To find out what files are open, use the SHOW FILES statement. For further information, consult Chapter 7. See also the description of the SAVE statement. IML automatically closes all files when a QUIT statement is executed.","help":"CLOSEFILE files"},{"name":"CREATE","description":"where: SAS-data-set -- can be specified with a one-level name (for example, A) or a two-level name (for example, SASUSER.A). operand -- gives a set of existing IML variables to become data set variables. matrix-name -- names a matrix containing the data. column-name is a character matrix or quoted literal containing descriptive names to associate with data set variables. row-name is a character matrix or quoted literal containing descriptive names to associate with observations on the data set. The CREATE statement creates a new SAS data set and makes it both the current input and output data sets. The variables in the new SAS data set are either the variables listed in the VAR clause or variables created from the columns of the FROM matrix. The FROM clause and the VAR clause should not be specified together.","help":"CREATE &lt;FROM matrix-name&gt; &lt;VAR operand&gt; &lt;_ALL_&gt; ...","arguments":[{"name":"COLNAME=","optional":true,"description":"","type":"value"},{"name":"FROM","optional":true,"description":"The variables in the new SAS data set are variables created from the columns of the FROM matrix.","type":"standalone"},{"name":"ROWNAME=","optional":true,"description":"","type":"value"},{"name":"VAR=","optional":true,"description":"You can specify a set of variables to use with the VAR clause, where operand can be specified as one of the following:","help":"VAR=_ALL_ | _CHAR_ | _NUM_","type":"choice","arguments":[{"name":"_ALL_","type":"standalone"},{"name":"_CHAR_","type":"standalone"},{"name":"_NUM_","type":"standalone"}]},{"name":"_ALL_","optional":true,"description":"For all variables","type":"standalone"},{"name":"_CHAR_","optional":true,"description":"For all character variables","type":"standalone"},{"name":"_NUM_","optional":true,"description":"For all numeric variables","type":"standalone"}]},{"name":"DELETE","description":"The inputs to the DELETE statement are as follows: range specifies a range of observations. expression is an expression that is evaluated for being true or false. Use the DELETE statement to mark records for deletion in the current output data set. To delete records and renumber the remaining observations, use the PURGE statement.","help":"DELETE &lt;ALL&gt; &lt;CURRENT&gt; &lt;WHERE(expression)&gt; ...","arguments":[{"name":"AFTER","optional":true,"description":"[range] Specifies all observations after the current one.","type":"standalone"},{"name":"ALL","optional":true,"description":"[range] Specifies all observations.","type":"standalone"},{"name":"CURRENT","optional":true,"description":"[range] Specifies the current observation.","type":"standalone"},{"name":"NEXT","optional":true,"description":"Specifies the next observation or the next number of observations.","type":"standalone"},{"name":"POINT","optional":true,"description":"specifies observations by number, where operand is one of the following:","type":"standalone"},{"name":"WHERE","optional":true,"description":"The WHERE clause conditionally selects observations that are contained within the range specification. The general form of the WHERE clause is WHERE(variable comparison-op operand) where:","type":"standalone"}]},{"name":"DISPLAY","description":"The inputs to the DISPLAY statement are as follows: group-spec specifies a group. It can be specified as either a compound name of the form windowname.groupname or a window name followed by a group of the form window-name (field-specs), where field-specs is as defined for the WINDOW statement. group-options can be any of the following: NOINPUT displays the group with all fields protected so that no data can be entered in the fields. REPEAT repeats the group for each element of the matrices specified as field operands. BELL rings the bell, sounds the alarm, or causes the speaker in your workstation to beep when the window is displayed. The DISPLAY statement directs IML to gather data into fields defined in the window for purposes of display, data entry, or menu selection. The DISPLAY statement always refers to a window that has been previously opened by a WINDOW statement.","help":"DISPLAY &lt;BELL&gt; &lt;NOINPUT&gt; &lt;REPEAT&gt; ...","arguments":[{"name":"BELL","optional":true,"description":"Repeats the group for each element of the matrices specified as field operands.","type":"standalone"},{"name":"NOINPUT","optional":true,"description":"Displays the group with all fields protected so that no data can be entered in the fields.","type":"standalone"},{"name":"REPEAT","optional":true,"description":"Repeats the group for each element of the matrices specified as field operands.","type":"standalone"}]},{"name":"DO","description":"","help":"DO &lt;OVER&gt; &lt;&gt; &lt;&gt; ...","arguments":[{"name":"BY","optional":true,"description":"Precedes an increment integer (other than 0) or an expression that generates an integer to be added to the value of the index variable in each iteration of the DO loop.","type":"standalone"},{"name":"OVER","optional":true,"description":"","type":"standalone"},{"name":"TO","optional":true,"description":"Separates the start and stop integers or expressions that control the number of times the portion of the DATA step between the iterative DO and END statements is processed.","type":"standalone"},{"name":"UNTIL","optional":true,"description":"...more SAS statements... END","type":"standalone"},{"name":"WHILE","optional":true,"description":"","type":"standalone"}]},{"name":"DO DATA","description":"The inputs to the DO DATA statement are as follows: variable is the name of a variable indexing the loop. start is the starting value for the looping variable. stop is the stopping value for the looping variable. The DO DATA statement is used for repetitive DO loops that need to be exited upon the occurrence of an end of file for an INPUT, READ, or other I/O statement. This form is common for loops that read data from either a sequential file or a SAS data set. When an end of file is reached inside the DO DATA group, IML immediately jumps from the group and starts executing the statement following the END statement. DO DATA groups can be nested, where each end of file causes a jump from the most local DO DATA group. The DO DATA loop simulates the end-of-file behavior of the SAS DATA step. You should avoid using GOTO and LINK statements to jump out of a DO DATA group.","help":"DO DATA &lt;TO&gt; ","arguments":[{"name":"TO","optional":true,"description":"","type":"standalone"}]},{"name":"DO UNTIL","description":"...more SAS statements... END","help":""},{"name":"DO WHILE","description":"","help":""},{"name":"EDIT","description":"The inputs to the EDIT statement are as follows: SAS-data-set can be specified with a one-level name (for example, A) or a two-level name (for example, SASUSER.A). For more information about specifying SAS data sets, refer to the chapter on SAS data sets in SAS Language Reference: Concepts. operand selects a set of variables. expression selects observations conditionally. name names a variable to contain the number of observations. The EDIT statement opens a SAS data set for reading and updating. If the data set has already been opened, the EDIT statement makes it the current input and output data sets.","help":"EDIT &lt;NOBS&gt; &lt;VAR&gt; ","arguments":[{"name":"NOBS","optional":true,"description":"Names a variable to contain the number of observations.","type":"standalone"},{"name":"VAR","optional":true,"description":"Selects a set of variables.","type":"standalone"}]},{"name":"ELSE","description":"If the condition in an IF-THEN statement is false and an ELSE statement is present, then the ELSE action is carried out.","help":"ELSE &lt;DO&gt; &lt;IF&gt; &lt;THEN&gt; ...","arguments":[{"name":"AND","optional":true,"description":"","type":"standalone"},{"name":"DO","optional":true,"description":"Action statement in an IF-THEN-ELSE construct.","type":"standalone"},{"name":"IF","optional":true,"description":"Executes a SAS statement for observations that meet specific conditions.","type":"standalone"},{"name":"NOT","optional":true,"description":"","type":"standalone"},{"name":"OR","optional":true,"description":"","type":"standalone"},{"name":"OUTPUT","optional":true,"description":"Action statement in an IF-THEN-ELSE construct.","type":"standalone"},{"name":"THEN","optional":true,"description":"If the conditions that are specified in the IF clause are met, the IF-THEN statement executes a SAS statement for observations that are read from a SAS data set, for records in an external file, or for computed values.","type":"standalone"}]},{"name":"END","description":"Ends a DO group/loop/statement or SELECT group processing.","help":"END"},{"name":"ENDSUBMIT","description":"You can use the ENDSUBMIT statement in conjunction with the SUBMIT statement to submit SAS statements for processing from within a SAS/IML program. All statements between the SUBMIT and the ENDSUBMIT statements are referred to as a SUBMIT block. The SUBMIT block is processed by the SAS language processor.","help":"ENDSUBMIT "},{"name":"FILE","description":"The inputs to the FILE statement are as follows: file-name is a name (for defined filenames), a quoted literal, or an expression in parentheses (for pathnames). RECFM=N specifies that the file is to be written as a pure binary file without record-separator characters. LRECL=operand specifies the record length of the output file. The default record length is 512.","help":"FILE &lt;LRECL=operand&gt; &lt;RECFM=N&gt; ","arguments":[{"name":"LRECL=","optional":true,"description":"Specifies the record length of the output file. The default record length is 512.","help":"LRECL=*operand*","type":"value"},{"name":"RECFM=","optional":true,"description":"Specifies that the file is to be written as a pure binary file without record-separator characters.","help":"RECFM=*N*","type":"value"}]},{"name":"FIND","description":"The inputs to the FIND statement are as follows: range specifies a range of observations. expression is an expression that is evaluated for being true or false. matrix-name names a matrix to contain the observation numbers. The FIND statement finds the observation numbers of records in range that satisfy the conditions of the WHERE clause. The FIND statement places these observation numbers in the numeric matrix whose name follows the INTO keyword.","help":"FIND &lt;ALL&gt; &lt;INTO&gt; &lt;WHERE(expression)&gt; ...","arguments":[{"name":"AFTER","optional":true,"description":"[range] Specifies all observations after the current one.","type":"standalone"},{"name":"ALL","optional":true,"description":"[range] Specifies all observations.","type":"standalone"},{"name":"CURRENT","optional":true,"description":"[range] Specifies the current observation.","type":"standalone"},{"name":"INTO","optional":true,"description":"The FIND statement finds the observation numbers of records in range that satisfy the conditions of the WHERE clause. The FIND statement places these observation numbers in the numeric matrix whose name follows the INTO keyword.","type":"standalone"},{"name":"NEXT","optional":true,"description":"Specifies the next observation or the next number of observations.","type":"standalone"},{"name":"POINT","optional":true,"description":"Specifies observations by number, where operand is one of the following:","type":"standalone"},{"name":"WHERE","optional":true,"description":"The WHERE clause conditionally selects observations that are contained within the range specification. The general form of the WHERE clause is WHERE(variable comparison-op operand) where:","type":"standalone"}]},{"name":"FINISH","description":"The FINISH statement signals the end of a module. Optionally, the FINISH statement can take the module name as its argument.","help":"START &lt;name&gt; &lt;(arguments)&gt; &lt;GLOBAL(arguments)&gt;"},{"name":"FREE","description":"where matrices are names of matrices. The FREE statement causes the specified matrices to lose their values; the memory is then freed for other uses. After execution of the FREE statement, the matrix does not have a value, and it returns 0 for the NROW and NCOL functions. Any printing attributes (assigned by the MATTRIB statement) are not released. The FREE statement is used mostly in large applications or under tight memory constraints to make room for more data (matrices) in the workspace.","help":"FREE matrices; | FREE / &lt;matrices&gt;"},{"name":"GO TO","aliases":["GOTO"],"description":"Jumps to a new statement.","help":"GO TO label | GOTO label"},{"name":"IF","description":"","help":"IF &lt;DO&gt; &lt;THEN&gt; &lt;WHEN&gt; ...","arguments":[{"name":"AND","optional":true,"description":"","type":"standalone"},{"name":"CALL","optional":true,"description":"Invokes a SAS CALL routine.","type":"standalone"},{"name":"DO","optional":true,"description":"Action statement in an IF-THEN construct.","type":"standalone"},{"name":"GO","optional":true,"aliases":["GOTO"],"description":"Jumps to a new statement.","help":"GO TO","type":"standalone"},{"name":"NOT","optional":true,"description":"","type":"standalone"},{"name":"OR","optional":true,"description":"","type":"standalone"},{"name":"OUTPUT","optional":true,"description":"Action statement in an IF-THEN construct.","type":"standalone"},{"name":"PUT","optional":true,"description":"Action statement in an IF-THEN construct.","type":"standalone"},{"name":"RETURN","optional":true,"description":"Action statement in an IF-THEN construct. Stops executing statements at the current point in the DATA step and returns to a predetermined point in the step.","type":"standalone"},{"name":"SET","optional":true,"description":"Reads an observation from one or more SAS data sets.","type":"standalone"},{"name":"STOP","optional":true,"description":"Action statement in an IF-THEN construct. Stops execution of the current DATA step.","type":"standalone"},{"name":"THEN","optional":true,"description":"If the conditions that are specified in the IF clause are met, the IF-THEN statement executes a SAS statement for observations that are read from a SAS data set, for records in an external file, or for computed values.","type":"standalone"},{"name":"WHEN","optional":true,"description":"WHEN statement in an IF-THEN-WHEN construct.","type":"standalone"}]},{"name":"INDEX","description":"where variables are the names of variables for which indexes are to be built. You can use the INDEX statement to create an index for the named variables in the current input SAS data set. An index is created for each variable listed if it does not already have an index. Current retrieval is set to the last variable indexed. Subsequent I/O operations such as LIST, READ, FIND, and DELETE can use this index to retrieve observations from the data set if IML determines that indexed retrieval will be faster. The indices are automatically updated when a data set is edited with the APPEND, DELETE, or REPLACE statements. Only one index is in effect at any given time. The SHOW contents command indicates which index is in use.","help":"INDEX &lt;NONE&gt; ","arguments":[{"name":"NONE","optional":true,"description":"An INDEX none statement can be used to set retrieval back to physical order.","type":"standalone"}]},{"name":"INFILE","description":"The inputs to the INFILE statement are as follows: operand is either a predefined filename or a quoted string containing the filename or character expression in parentheses referring to the pathname. options options available for the INFILE statement. You can use the INFILE statement to open an external file for input or, if the file is already open, to make it the current input file so that subsequent INPUT statements read from it.","help":"INFILE &lt;FLOWOVER&gt; &lt;LENGTH=variable&gt; &lt;RECFM=N&gt; ...","arguments":[{"name":"FLOWOVER","optional":true,"description":"Enables the INPUT statement to go to the next record to obtain values for the variables.","type":"standalone"},{"name":"LENGTH=","optional":true,"description":"Specifies a variable in which the length of a record is stored as IML reads it in.","help":"LENGTH=*variable*","type":"value"},{"name":"MISSOVER","optional":true,"description":"Tolerates attempted reading past the end of the record by assigning missing values to variables read past the end of the record.","type":"standalone"},{"name":"RECFM=","optional":true,"description":"Specifies that the file is to be read in as a pure binary file rather than as a file with record separator characters. To do this, you must use the byte operand (<) in the INPUT statement to get new records rather than use separate input statements or the new line (/) operator.","help":"RECFM=*N*","type":"value"},{"name":"STOPOVER","optional":true,"description":"Treats going past the end of a record as an error condition, which triggers an end-of-file condition.","type":"standalone"}]},{"name":"INPUT","description":"where the clauses and options are explained in the following list. You can use the INPUT statement to input records from the current input file, placing the values into IML variables. The INFILE statement sets up the current input file. The INPUT statement contains a sequence of arguments that include the following: variables specify the variable or variables you want to read from the current position in the record. Each variable can be followed immediately by an input format specification. informats specify an input format.","help":"INPUT &lt;variables&gt; &lt;informats&gt; &lt;record-directives&gt; &lt;positionals&gt;"},{"name":"LINK","description":"Directs program execution immediately to the statement label that is specified and, if followed by a RETURN statement, returns execution to the statement that follows the LINK statement.","help":"LINK label"},{"name":"LIST","description":"The inputs to the LIST statement are as follows: range specifies a range of observations operand specifies a set of variables expression is an expression evaluated to be true or false The LIST statement prints selected observations of a data set. If all data values for variables in the VAR clause fit on a single line, values are displayed in columns headed by the variable names. Each record occupies a separate line. If the data values do not fit on a single line, values from each record are grouped into paragraphs. Each element in the paragraph has the form name=value.","help":"LIST &lt;ALL&gt; &lt;VAR operand&gt; &lt;WHERE(expression)&gt; ...","arguments":[{"name":"AFTER","optional":true,"description":"[range] Specifies all observations after the current one.","type":"standalone"},{"name":"ALL","optional":true,"description":"[range] Specifies all observations.","type":"standalone"},{"name":"CURRENT","optional":true,"description":"[range] Specifies the current observation (this is the default for the LIST statement).","type":"standalone"},{"name":"NEXT","optional":true,"description":"Specifies the next observation or the next number of observations.","type":"standalone"},{"name":"POINT","optional":true,"description":"specifies observations by number, where operand is one of the following:","type":"standalone"},{"name":"VAR","optional":true,"description":"You can specify a set of variables to use with the VAR clause. The operand in the VAR clause can be one of the following: o a literal containing variable names o the name of a matrix containing variable names o an expression in parentheses yielding variable names o one of keywords described in the following list: _ALL_ for all variables _CHAR_ for all character variables","type":"standalone"},{"name":"WHERE","optional":true,"description":"The WHERE clause conditionally selects observations that are contained within the range specification. The general form of the WHERE clause is WHERE(variable comparison-op operand) where:","type":"standalone"},{"name":"_ALL_","optional":true,"description":"For all variables","type":"standalone"},{"name":"_CHAR_","optional":true,"description":"For all character variables","type":"standalone"},{"name":"_NUM_","optional":true,"description":"For all numeric variables","type":"standalone"}]},{"name":"LOAD","description":"The inputs to the LOAD statement are as follows: module-list is a list of modules. matrix-list is a list of matrices. The LOAD statement loads modules or matrix values from the current library storage into the current workspace.","help":"LOAD &lt;MODULE=(module-list)&gt; &lt;_ALL_&gt; ","arguments":[{"name":"MODULE=","optional":true,"description":"Loads modules.","type":"value"},{"name":"_ALL_","optional":true,"description":"Loads all matrices or all modules.","type":"standalone"}]},{"name":"MATTRIB","description":"The inputs to the MATTRIB subroutine are as follows: name is a character matrix or quoted literal giving the name of a matrix. row-name is a character matrix or quoted literal specifying row names. column-name is a character matrix or quoted literal specifying column names. label is a character matrix or quoted literal associating a label with the matrix. The label argument has a maximum length of 256 characters. format is a valid SAS format. The MATTRIB statement associates printing attributes with matrices. Each matrix can be associated with a ROWNAME= matrix and a COLNAME= matrix, which is used whenever the matrix is printed to label the rows and columns, respectively. The statement is written as the keyword MATTRIB followed by a list of one or more names and attribute associations. It is not necessary to specify all attributes. The attribute associations are applied to the previous name.","help":"MATTRIB &lt;COLNAME=column-name&gt; &lt;LABEL=label&gt; &lt;ROWNAME=row-name&gt; ...","arguments":[{"name":"COLNAME=","optional":true,"description":"Requires a character matrix or quoted literal specifying column names.","help":"COLNAME=*column-name*","type":"value"},{"name":"FORMAT=","optional":true,"description":"Specifies a valid SAS format.","help":"FORMAT=*format*","type":"value"},{"name":"LABEL=","optional":true,"description":"Requires a character matrix or quoted literal associating a label with the matrix. The label argument has a maximum length of 256 characters.","help":"LABEL=*label*","type":"value"},{"name":"ROWNAME=","optional":true,"description":"Requires a character matrix or quoted literal specifying row names.","help":"ROWNAME=*row-name*","type":"value"}]},{"name":"PACKAGE HELP","description":"The PACKAGE HELP statement is experimental in SAS/IML 14.1. If an installed package provides documentation, the PACKAGE HELP statement displays the documentation. The documentation often includes the syntax and purpose of the SAS/IML modules that the package defines. You must specify the following argument: packagename specifies the name of the package. You can also specify the following option in parentheses: collection requests that only the specified collection be searched. Valid values for collection are PRIVATE, PUBLIC, and SYSTEM.","help":"PACKAGE HELP packagename&lt;(collection )&gt;"},{"name":"PACKAGE INFO","description":"The PACKAGE INFO statement is experimental in SAS/IML 14.1. The PACKAGE INFO statement displays information about one or more installed packages. You must specify the following argument: packagename specifies the name of the package. You can specify multiple names in a single statement. You can also specify the following option in parentheses: collection requests that only the specified collection be searched. Valid values for collection are PRIVATE, PUBLIC, and SYSTEM.","help":"PACKAGE INFO packagename&lt;(collection )&gt; …"},{"name":"PACKAGE INSTALL","description":"PACKAGE INSTALL fileref<(collection <PARSETIME> )> …; The PACKAGE INSTALL statement is experimental in SAS/IML 14.1. Packages are distributed as ZIP files. The PACKAGE INSTALL statement unzips the ZIP file and installs the package in a predetermined location. You can specify the package to be installed in two ways: \"fullname\" specifies the ZIP file’s fully qualified name (which includes both the path and the filename) in quotation marks. You can specify multiple names in a single statement. fileref specifies a file reference that was previously created by the FILENAME statement. You can also specify the following options in parentheses: collection specifies the collection into which the package is to be installed. You can specify PUBLIC or PRIVATE; you cannot install a package in the SYSTEM collection. By default, the package is installed in the PRIVATE collection. At some sites, you might need administrative privileges in order to install a package in the PUBLIC collection. PARSETIME requests that the package be installed at parse time, rather than at run time. This option applies only to IMLPLUS programs in the SAS/IML Studio environment.","help":"PACKAGE INSTALL &lt;PARSETIME&gt; ","arguments":[{"name":"PARSETIME","description":"","type":"standalone"}]},{"name":"PACKAGE LIBNAME","description":"The PACKAGE LIBNAME statement is experimental in SAS/IML 14.1. The PACKAGE LIBNAME statement creates a SAS libref that points to the data directory for a package. You must load a package before you can use the PACKAGE LIBNAME statement. You must specify the following arguments: libref specifies the name of a SAS libref to be created. packagename specifies the name of the package.","help":"PACKAGE LIBNAME libref packagename"},{"name":"PACKAGE LIST","description":"The PACKAGE LIST statement is experimental in SAS/IML 14.1. The PACKAGE LIST statement lists the packages that are installed in the specified collection (or in all collections if a collection is not specified). You can specify the following option: collection requests that only packages in the specified collection be listed. Valid values for collection are PRIVATE, PUBLIC, and SYSTEM. By default, the PACKAGE LIST statement lists packages in all collections.","help":"PACKAGE LIST &lt;collection&gt; "},{"name":"PACKAGE LOAD","description":"The PACKAGE LOAD statement is experimental in SAS/IML 14.1. The PACKAGE LOAD statement executes the package source files. Usually the source files define SAS/IML modules. However, a package might also define SAS/IML matrices, create data sets, define macro variables, or carry out a computation. You must specify the following argument: packagename specifies the name of the package. You can specify multiple names in a single statement. You can also specify the following options in parentheses: collection requests that only the specified collection be searched for the file to be executed. Valid values for collection are PRIVATE, PUBLIC, and SYSTEM. For more information about collections, see the PACKAGE statement . VERSION=version specifies the minimum required version number for loading a package. A version number is a text string that contains up to four numbers that are separated by decimal points. For example, valid values are \"1.0\", \"2.7.1\", and \"3.1.4.1\". When the PACKAGE LOAD statement finds a specified package, it checks the package version. If the package version is greater than or equal to version, the package is loaded. Otherwise, the statement displays an error message.","help":"PACKAGE LOAD &lt;VERSION=&gt; ","arguments":[{"name":"VERSION=","description":"","type":"value"}]},{"name":"PACKAGE UNINSTALL","description":"The PACKAGE UNINSTALL statement is experimental in SAS/IML 14.1. The PACKAGE UNINSTALL statement uninstalls a package that is installed in the specified collection. You must specify the following argument: packagename specifies the name of the package. You can specify multiple names in a single statement. You can also specify the following options in parentheses: collection requests that only the specified collection be searched for the package to uninstall. Valid values for collection are PRIVATE and PUBLIC. By default, the PACKAGE UNINSTALL statement looks for the package in the PRIVATE collection. If you have administrative privileges to uninstall a package in the PUBLIC collection, you can specify the PUBLIC collection in parentheses after the package name. You cannot uninstall a package in the SYSTEM collection. NOWARN requests that no warning message be reported if the specified package is not installed. PARSETIME requests that the package be installed at parse time, rather than at run time. This option applies only to IMLPLUS programs in the SAS/IML Studio environment.","help":"PACKAGE UNINSTALL &lt;NOWARN&gt; &lt;PARSETIME&gt; ","arguments":[{"name":"NOWARN","description":"","type":"standalone"},{"name":"PARSETIME","description":"","type":"standalone"}]},{"name":"PAUSE","description":"The inputs to the PAUSE statement are as follows: expression is a character matrix or quoted literal giving a message to print. * suppresses any messages. The PAUSE statement stops execution of a module, saves the calling chain so that execution can resume later (by a RESUME statement), prints a pause message that you can specify, and puts you in immediate mode so you can enter more statements.","help":"PAUSE &lt;expression&gt; &lt;*&gt;"},{"name":"PRINT","description":"The inputs to the PRINT statement are as follows: matrices are the names of matrices. (expression) is an expression in parentheses that is evaluated. The result of the evaluation is printed. The evaluation of a subscripted matrix used as an expression results in printing the submatrix. \"message\" is a message in quotes. pointer-controls control the pointer for printing. For example, using a comma (,) skips a single line and using a slash (/) skips to a new page. [options] specified in brackets after the matrix name to which they apply. The PRINT statement prints the specified matrices or message.","help":"PRINT &lt;COLNAME=&gt; &lt;FORMAT=&gt; &lt;LABEL=&gt; ...","arguments":[{"name":"COLNAME=","optional":true,"description":"","type":"value"},{"name":"FORMAT=","optional":true,"description":"","type":"value"},{"name":"LABEL=","optional":true,"description":"","type":"value"}]},{"name":"PURGE","description":"The PURGE data processing statement is used to remove observations marked for deletion and to renumber the remaining observations. This closes the gaps created by deleted records. Execution of this statement can be time-consuming because it involves rewriting the entire data set. CAUTION: Any indexes associated with the data set are lost after a purge. IML does not do an automatic purge for you at quit time.","help":"PURGE"},{"name":"PUT","description":"The inputs to the PUT statement are as follows: operand specifies the value you want to output to the current position in the record. The operand can be either a variable name, a literal value, or an expression in parentheses. The operand can be followed immediately by an output format specification. record-directives start new records. There are three types: holding @ at the end of a PUT statement, instructs IML to put a hold on the current record so that IML can write more to the record with later PUT statements. Otherwise, IML automatically begins the next record for the next PUT statement. / -- writes out the current record and begins forming a new record. > operand -- specifies that the next record written will start at the indicated byte position in the file (for RECFM=N files only). The operand is a literal number, a variable name, or an expression in parentheses. positionals specify the column on the record to which the PUT statement should go. There are two types of positionals: @ operand specifies to go to the indicated column, where operand is a literal number, a variable name, or an expression in parentheses. For example, @30 means to go to column 30. + operand specifies that the indicated number of columns are to be skipped, where operand is a literal number, a variable name, or an expression in parentheses. format specifies a valid SAS or user-defined output format. These are of the form w.d or $w. for standard numeric and character formats, respectively, where w is the width of the field and d is the decimal parameter, if any. They can also be a named format of the form NAME, where NAME is the name of the format. If the width is unspecified, then a default width is used; this is 9 for numeric variables. The PUT statement writes to the file specified in the previously executed FILE statement, putting the values from IML variables.","help":"PUT &lt;operand&gt; &lt;record-directives&gt; &lt;positionals&gt; &lt;format&gt;"},{"name":"QUIT","description":"Use the QUIT statement to exit IML. If a DATA or PROC statement is encountered, QUIT is implied. The QUIT statement is executed immediately; therefore, you cannot use QUIT as an executable statement, that is, as part of a module or conditional clause. PROC IML closes all open data sets and files when a QUIT statement is encountered. Workspace and symbol spaces are freed up. If you need to use any matrix values or any module definitions in a later session, you must store them in a storage library before you quit.","help":"QUIT "},{"name":"READ","description":"The inputs to the READ function are as follows: range -- specifies a range of observations. operand -- selects a set of variables. expression -- is evaluated for being true or false. name -- is the name of the target matrix. row-name -- is a character matrix or quoted literal giving descriptive row labels. column-name is a character matrix or quoted literal giving descriptive column labels. The clauses and options are explained in the following lists. Use the READ statement to read variables or records from the current SAS data set into column matrices of the VAR clause or into the single matrix of the INTO clause. When the INTO clause is used, each variable in the VAR clause becomes a column of the target matrix, and all variables in the VAR clause must be of the same type. If you specify no VAR clause, the default variables for the INTO clause are all numeric variables. Read all character variables into a target matrix by using VAR _CHAR_.","help":"READ &lt;ALL&gt; &lt;VAR&gt; &lt;WHERE(variable comparison-op operand)&gt; ...","arguments":[{"name":"AFTER","optional":true,"description":"[range] Specifies all observations after the current one.","type":"standalone"},{"name":"ALL","optional":true,"description":"[range] Specifies all observations.","type":"standalone"},{"name":"CURRENT","optional":true,"description":"[range] Specifies the current observation (this is the default for the LIST statement).","type":"standalone"},{"name":"NEXT","optional":true,"description":"Specifies the next observation or the next number of observations.","type":"standalone"},{"name":"POINT","optional":true,"description":"specifies observations by number, where operand can one of the following:","type":"standalone"},{"name":"VAR","optional":true,"description":"Specifies a set of variables. You can specify a set of variables to use with the VAR clause. The operand in the VAR clause can be one of the following: o a literal containing variable names o the name of a matrix containing variable names o an expression in parentheses yielding variable names o one of keywords described in the following list: _ALL_ for all variables _CHAR_ for all character variables","type":"standalone"},{"name":"WHERE","optional":true,"description":"where: variable -- is a variable in the SAS data set. comparison-op -- is one of the several comparison operators (<, <=, =, >, >=, ^=, ?, etc.)","type":"standalone"},{"name":"_ALL_","optional":true,"description":"For all variables","type":"standalone"},{"name":"_CHAR_","optional":true,"description":"For all character variables","type":"standalone"},{"name":"_NUM_","optional":true,"description":"For all numeric variables","type":"standalone"}]},{"name":"REMOVE","description":"The inputs to the REMOVE statement are as follows: module-list specifies a module or modules to remove from storage. matrix-list specifies a matrix or matrices to remove from storage. The REMOVE statement removes matrices or modules or both from the current library storage.","help":"REMOVE &lt;MODULE=(module-list)&gt; &lt;_ALL_&gt; ","arguments":[{"name":"MODULE=","optional":true,"description":"Removes modules.","type":"value"},{"name":"_ALL_","optional":true,"description":"Removes all matrices or all modules.","type":"standalone"}]},{"name":"REPLACE","description":"The inputs to the REPLACE statement are as follows: range specifies a range of observations operand selects a set of variables expression is evaluated for being true or false The REPLACE statement replaces the values of observations in a SAS data set with current values of IML matrices with the same name. Use the range, VAR, and WHERE arguments to limit replacement to specific variables and observations. Replacement matrices should be the same type as the data set variables. The REPLACE statement uses matrix elements in row order replacing the value in the ith observation with the ith matrix element. If there are more observations in range than matrix elements, the REPLACE statement continues to use the last matrix element.","help":"REPLACE &lt;ALL&gt; &lt;VAR&gt; &lt;WHERE(expression)&gt; ...","arguments":[{"name":"AFTER","optional":true,"description":"[range] Specifies all observations after the current one.","type":"standalone"},{"name":"ALL","optional":true,"description":"[range] Specifies all observations.","type":"standalone"},{"name":"CURRENT","optional":true,"description":"[range] Specifies the current observation (this is the default for the LIST statement).","type":"standalone"},{"name":"NEXT","optional":true,"description":"Specifies the next observation or the next number of observations.","type":"standalone"},{"name":"POINT","optional":true,"description":"Specifies observations by number, where operand is one of the following:","type":"standalone"},{"name":"VAR","optional":true,"description":"Specifies a set of variables. You can specify a set of variables to use with the VAR clause. The operand in the VAR clause can be one of the following: o a literal containing variable names o the name of a matrix containing variable names o an expression in parentheses yielding variable names o one of keywords described in the following list: _ALL_ for all variables _CHAR_ for all character variables","type":"standalone"},{"name":"WHERE","optional":true,"description":"The WHERE clause conditionally selects observations that are contained within the range specification. The general form of the WHERE clause is WHERE(variable comparison-op operand) where:","type":"standalone"}]},{"name":"RESET","description":"The RESET statement sets processing options. Note that the prefix NO turns off the feature where indicated. For options that take operands, the operand should be a literal, a name of a matrix containing the value, or an expression in parentheses. The SHOW options statement displays the current settings of all of the options.","help":"RESET &lt;AUTONAME&gt; &lt;CENTER&gt; &lt;NOAUTONAME&gt; ...","arguments":[{"name":"AUTONAME","optional":true,"description":"Specifies that rows are automatically labeled ROW1, ROW2, and so on, and columns are labeled COL1, COL2, and so on, when a matrix is printed. Row-name and column-name attributes specified in the PRINT statement or associated via the MATTRIB statement override the default labels. The AUTONAME option causes the SPACES option to be reset to 4.","type":"standalone"},{"name":"CENTER","optional":true,"description":"Specifies that output from the PRINT statement is centered on the page. The default is CENTER. This resets the global CENTER/NOCENTER option for the SAS session.","type":"standalone"},{"name":"CLIP","optional":true,"description":"Specifies that SAS/IML graphs are automatically clipped outside the viewport; that is, any data falling outside the current viewport is not displayed. NOCLIP is the default.","type":"standalone"},{"name":"DEFLIB=","optional":true,"description":"Specifies the default libname for SAS data sets when no other libname is given. This defaults to USER if a USER libname is set up, or WORK if not. The libname operand can be specified with or without quotes.","help":"DEFLIB=*operand*","type":"value"},{"name":"DETAILS","optional":true,"description":"Specifies that additional information is printed from a variety of operations, such as when files are opened and closed.","type":"standalone"},{"name":"FLOW","optional":true,"description":"Specifies that operations are shown as executed. It is used for debugging only. The default is NOFLOW.","type":"standalone"},{"name":"FUZZ=","optional":true,"description":"Specifies that very small numbers are printed in scientific notation. If the absolute value of the number is less than the value specified in number, it will be printed as 0. The number argument is optional, and the default value varies across hosts but is typically around 1E-12. The default is NOFUZZ.","type":"value"},{"name":"FW=","optional":true,"description":"Sets the field width for printing numeric values. The default field width is 9.","help":"FW=*number*","type":"value"},{"name":"LINESIZE=","optional":true,"description":"Specifies the linesize for printing. The default value is usually 78. This resets the global LINESIZE option for the SAS session.","help":"LINESIZE=*n*","type":"value"},{"name":"LOG","optional":true,"description":"Specifies that output is routed to the log file rather than to the print file. On the log, the results are interleaved with the statements and messages.","type":"standalone"},{"name":"NOAUTONAME","optional":true,"description":"Specifies that rows are not automatically labeled ROW1, ROW2, and so on, and columns are labeled COL1, COL2, and so on, when a matrix is printed.","type":"standalone"},{"name":"NOCENTER","optional":true,"description":"Specifies that output from the PRINT statement is not centered on the page. The default is CENTER. This resets the global CENTER/NOCENTER option for the SAS session.","type":"standalone"},{"name":"NOCLIP","optional":true,"description":"Specifies that SAS/IML graphs are not automatically clipped outside the viewport; that is, any data falling outside the current viewport is not displayed. NOCLIP is the default.","type":"standalone"},{"name":"NODETAILS","optional":true,"description":"Specifies that no additional information is printed from a variety of operations, such as when files are opened and closed.","type":"standalone"},{"name":"NOFLOW","optional":true,"description":"Specifies that operations are not shown as executed. It is used for debugging only. The default is NOFLOW.","type":"standalone"},{"name":"NOFUZZ","optional":true,"description":"Specifies that very small numbers are printed as zero rather than in scientific notation.","type":"standalone"},{"name":"NOLOG","optional":true,"description":"Routes output to the OUTPUT window in the SAS windowing environment and to the listing file in batch mode. The default is NOLOG.","type":"standalone"},{"name":"NOPRINTALL","optional":true,"description":"Specifies that the intermediate and final results are not printed automatically. This is the default.","type":"standalone"},{"name":"PRINTADV=","optional":true,"description":"Inserts blank lines into the log before printing out the value of a matrix. The default, PRINTADV=2, causes two blank lines to be inserted.","type":"value"},{"name":"PRINTALL","optional":true,"description":"Specifies that the intermediate and final results are printed automatically. The default is NOPRINTALL.","type":"standalone"},{"name":"SPACES=","optional":true,"description":"Specifies the number of spaces between adjacent matrices printed across the page. The default value is 1, except when AUTONAME is on. Then, the default value is 4.","type":"value"},{"name":"STORAGE=","optional":true,"description":"Specifies the file to be the current library storage for STORE and LOAD statements. The default library storage is WORK.IMLSTOR. The libname argument is optional and defaults to SASUSER. It can be specified with or without quotes.","type":"value"}]},{"name":"RESUME","description":"The RESUME statement enables you to continue execution from the line in the module where the most recent PAUSE statement was executed. PROC IML issues an automatic pause when an error occurs inside a module. If a module was paused due to an error, the RESUME statement resumes execution immediately after the statement that caused the error. The SHOW pause statement displays the current state of all paused modules.","help":"RESUME"},{"name":"RETURN","description":"where operand is the value of the function returned. Use operand only in function modules. The RETURN statement causes IML to return to the calling point in a program. If a LINK statement has been issued, IML returns to the statement following the LINK. If no LINK statement was issued, the RETURN statement exits a module. If not in a module, execution is stopped (as with a STOP statement), and IML looks for more statements to parse. The RETURN statement with an operand is used in function modules that return a value. The operand can be a variable name or an expression. It is evaluated, and the value is returned.","help":"RETURN &lt;(operand)&gt;"},{"name":"RUN","description":"The inputs to the RUN statement are as follows: name is the name of a user-defined module or an IML built-in subroutine. arguments are arguments to the subroutine. Arguments can be both local and global. The RUN statement executes a user-defined module or invokes PROC IML's built-in subroutines.","help":"RUN &lt;name&gt; &lt;(arguments)&gt;"},{"name":"SAVE","aliases":["FORCE"],"description":"The SAVE statement forces out any data residing in output buffers for all active output data sets and files to ensure that the data are written to disk. This is equivalent to closing and then reopening the files.","help":"SAVE "},{"name":"SETIN","description":"The inputs to the SETIN statement are as follows: SAS-data-set can be specified with a one-level name (for example, A) or a two-level name (for example, SASUSER.A). name is the name of a variable to contain the number of observations in the data set. operand specifies the current observation. The SETIN statement chooses the specified data set from among the data sets already opened for input by the EDIT or USE statement. This data set becomes the current input data set for subsequent data management statements. The NOBS option is not required. If specified, the NOBS option returns the number of observations in the data set in the scalar variable name. The POINT option makes the specified observation the current one. It positions the data set to a particular observation. The SHOW datasets command lists data sets already opened for input.","help":"SETIN &lt;NOBS&gt; &lt;POINT&gt; ","arguments":[{"name":"NOBS","optional":true,"description":"Returns the number of observations in the data set in the scalar variable name.]","type":"standalone"},{"name":"POINT","optional":true,"description":"Makes the specified observation the current one. It positions the data set to a particular observation.","type":"standalone"}]},{"name":"SETOUT","description":"The inputs to the SETOUT statement are as follows: SAS-data-set can be specified with a one-level name (for example, A) or a two-level name (for example, SASUSER.A). name is the name of a variable to contain the number of observations in the data set operand specifies the observation to be made the current observation. The SETOUT statement chooses the specified data set from among those data sets already opened for output by the EDIT or CREATE statement. This data set becomes the current output data set for subsequent data management statements. If specified, the NOBS option returns the number of observations currently in the data set in the scalar variable name. The POINT option makes the specified observation the current one.","help":"SETOUT &lt;NOBS name&gt; &lt;POINT operand&gt; ","arguments":[{"name":"NOBS","optional":true,"description":"Returns the number of observations currently in the data set in the scalar variable name.]","type":"standalone"},{"name":"POINT","optional":true,"description":"Makes the specified observation the current one.","type":"standalone"}]},{"name":"SHOW","description":"The SHOW statement prints system information.","help":"SHOW &lt;ALL&gt; &lt;ALLNAMES&gt; &lt;CONTENTS&gt; ...","arguments":[{"name":"ALL","optional":true,"description":"Shows all the information included by OPTIONS, SPACE, DATASETS, FILES, and MODULES.","type":"standalone"},{"name":"ALLNAMES","optional":true,"description":"Behaves like NAMES, but also shows names without values.","type":"standalone"},{"name":"CONTENTS","optional":true,"description":"Shows the names and attributes of the variables in the current SAS data set.","type":"standalone"},{"name":"DATASETS","optional":true,"description":"shows all open SAS data sets.","type":"standalone"},{"name":"FILES","optional":true,"description":"Shows all open files.","type":"standalone"},{"name":"MEMORY","optional":true,"description":"Returns the size of the largest chunk of main memory available.","type":"standalone"},{"name":"MODULES","optional":true,"description":"Shows all modules that exist in the current IML environment. A module already referenced but not yet defined is listed as undefined.","type":"standalone"},{"name":"NAMES","optional":true,"description":"Shows attributes of all matrices having values. Attributes include number of rows, number of columns, data type, and size.","type":"standalone"},{"name":"OPTIONS","optional":true,"description":"shows current settings of all IML options.","type":"standalone"},{"name":"PAUSE","optional":true,"description":"Shows the status of all paused modules that are pending resume.","type":"standalone"},{"name":"SPACE","optional":true,"description":"Shows the workspace and symbolspace size and their current usage.","type":"standalone"},{"name":"STORAGE","optional":true,"description":"Shows the modules and matrices in the current IML library storage.","type":"standalone"},{"name":"WINDOWS","optional":true,"description":"Shows all active windows opened by WINDOW statements.","type":"standalone"}]},{"name":"SORT","description":"The SORT statement sorts the observations in a SAS data set by one or more variables, stores the resulting sorted observations in a new SAS data set, or replaces the original. As opposed to all other IML data processing statements, it is mandatory that the data set to be sorted be closed prior to the execution of the SORT statement.","help":"SORT &lt;BY variables&gt; &lt;DATA=SAS-data-set&gt; &lt;OUT=SAS-data-set&gt; ...","arguments":[{"name":"BY","optional":true,"description":"Specifies the variables to be sorted. A BY clause must be used with the SORT statement.","type":"standalone"},{"name":"DATA=","optional":true,"description":"Names the SAS data set to be sorted. It can be specified with a one-level name (for example, A) or a two-level name (for example, SASUSER.A).","help":"DATA=*SAS-data-set*","type":"dataSet"},{"name":"DESCENDING","optional":true,"description":"Specifies the variables are to be sorted in descending order.","type":"standalone"},{"name":"OUT=","optional":true,"description":"Specifies a name for the output data set. If this clause is omitted, the DATA= data set is sorted and the sorted version replaces the original data set.","help":"OUT=*SAS-data-set*","type":"dataSet"}]},{"name":"START","description":"The inputs to the START and FINISH statements are as follows: name is the name of a user-defined module. arguments are names of variable arguments to the module. Arguments can be either input variables or output (returned) variables. Arguments listed in the GLOBAL clause are treated as global variables. Otherwise, the arguments are local. module statements are statements making up the body of the module. The START statement instructs IML to enter a module-collect mode to collect the statements of a module rather than execute them immediately.","help":"START &lt;GLOBAL(arguments)&gt; ","arguments":[{"name":"GLOBAL","optional":true,"description":"Arguments listed in the GLOBAL clause are treated as global variables. Otherwise, the arguments are local.","type":"standalone"}]},{"name":"STOP","description":"The STOP statement stops the IML program, and no further matrix statements are executed. However, IML continues to execute if more statements are entered. See also the descriptions of the RETURN and ABORT statements. If IML execution was interrupted by a PAUSE statement or by a break, the STOP statement clears all the paused states and returns to immediate mode. IML supports STOP processing of both regular and function modules.","help":"STOP "},{"name":"STORE","description":"The inputs to the STORE statement are as follows. module-list is a list of module names. matrix-list is a list of matrix names. The STORE statement stores matrices or modules in the storage library.","help":"STORE &lt;MODULE=(module-list)&gt; &lt;_ALL_&gt; ","arguments":[{"name":"MODULE=","optional":true,"description":"Stores modules. module-list is a list of module names.","type":"value"},{"name":"_ALL_","optional":true,"description":"Stores all matrices or all modules.","type":"standalone"}]},{"name":"SUBMIT","description":"The SUBMIT statement enables you to submit SAS statements for processing from within a SAS/IML program. You can use the SUBMIT statement to call SAS procedures, DATA steps, and macros. All text between the SUBMIT statement and the ENDSUBMIT statement are referred to as a SUBMIT block. The SUBMIT block is processed by the SAS language processor.","help":"SUBMIT &lt;OK=ok-matrix&gt; &lt;R&gt; ","arguments":[{"name":"OK=","optional":true,"followsDelimiter":"/","description":"Specifies the name of a matrix. The matrix is set to 1 if the SUBMIT block executes without error, and to 0 otherwise.","help":"OK=*ok-matrix*","type":"value"},{"name":"R","optional":true,"followsDelimiter":"/","description":"specifies that statements in the SUBMIT block are processed by the R statistical software. You can use the R option to call functions in the R language, provided that the following statements are true: the R statistical software is installed on the SAS workspace server.","type":"standalone"}]},{"name":"SUMMARY","description":"where the operands used by most clauses take either a matrix name, a matrix literal, or an expression yielding a matrix name or value. The SUMMARY statement computes statistics for numeric variables for an entire data set or a subset of observations in the data set. The statistics can be stratified by the use of CLASS variables. The computed statistics are displayed in tabular form and optionally can be saved in matrices. Like most other IML data processing statements, the SUMMARY statement works on the current data set.","help":"SUMMARY &lt;CLASS operand&gt; &lt;VAR operand&gt; &lt;WEIGHT operand&gt; ...","arguments":[{"name":"CLASS","optional":true,"description":"Specifies the variables in the current input SAS data set to be used to group the summaries. The operand is a character matrix containing the names of the variables.","type":"standalone"},{"name":"OPT","optional":true,"description":"Sets the PRINT or NOPRINT and SAVE or NOSAVE options. The NOPRINT option suppresses the printing of the results from the SUMMARY statement. The SAVE option requests that the SUMMARY statement save the resultant statistics in matrices. The operand is a character matrix containing one or more of the options.","type":"standalone"},{"name":"STAT","optional":true,"description":"Computes the statistics specified. The operand is a character matrix containing the names of statistics.","type":"standalone"},{"name":"VAR","optional":true,"description":"Calculates statistics for a set of numeric variables from the current input data set. The operand is a character matrix containing the names of the variables. Also, the special keyword _NUM_ can be used as a VAR operand to specify all numeric variables. If the VAR clause is missing, the SUMMARY statement produces only the number of observations in each class group.","type":"standalone"},{"name":"WEIGHT","optional":true,"description":"Specifies a character value containing the name of a numeric variable in the current data set whose values are to be used to weight each observation. Only one variable can be specified.","type":"standalone"},{"name":"WHERE","optional":true,"description":"Conditionally selects observations, within the range specification, according to conditions given in expression.","type":"standalone"}]},{"name":"USE","description":"The inputs to the USE statement are as follows: SAS-data-set can be specified with a one-level name (for example, A) or a two-level name (for example, SASUSER.A). For more information about specifying SAS data sets, see the chapter on SAS data sets in SAS Language Reference: Concepts. operand selects a set of variables. expression is evaluated for being true or false. name is the name of a variable to contain the number of observations. If the data set has not already been opened, the USE statement opens the data set for read access. The USE statement also makes the data set the current input data set so that subsequent statements act on it. The USE statement optionally can define selection criteria that are used to control access.","help":"USE &lt;NOBS name&gt; &lt;VAR operand&gt; &lt;WHERE(expression)&gt; ...","arguments":[{"name":"NOBS","optional":true,"description":"Specifies the name of a variable to contain the number of observations.","type":"standalone"},{"name":"VAR=","optional":true,"description":"The VAR clause specifies a set of variables to use, where operand can be specified as one of the following:","help":"VAR=_ALL_ | _CHAR_ | _NUM_","type":"choice","arguments":[{"name":"_ALL_","type":"standalone"},{"name":"_CHAR_","type":"standalone"},{"name":"_NUM_","type":"standalone"}]},{"name":"WHERE","optional":true,"description":"The WHERE clause conditionally selects observations, within the range specification, according to conditions given in the clause. The general form of the WHERE clause is as follows: WHERE(variable comparison-op operand) where:","type":"standalone"},{"name":"_ALL_","optional":true,"description":"For all variables","type":"standalone"},{"name":"_CHAR_","optional":true,"description":"For all character variables","type":"standalone"},{"name":"_NUM_","optional":true,"description":"For all numeric variables","type":"standalone"}]},{"name":"WINDOW","description":"where window-name specifies a name 1 to 8 characters long for the window. This name is displayed in the upper-left border of the window. window-options control the size, position, and other attributes of the window. field-specs are a sequence of field specifications made up of positionals, field operands, formats, and options. These are described in the next section The WINDOW statement defines a window on the display and can include a number of fields. The DISPLAY statement actually writes values to the window.","help":"WINDOW &lt;CLOSE=window-name&gt; &lt;CMNDLINE=name&gt; &lt;GROUP=group-name&gt; ...","arguments":[{"name":"CLOSE=","optional":true,"description":"Closes the window.","help":"CLOSE=*window-name*","type":"value"},{"name":"CMNDLINE=","optional":true,"description":"Specifies the name of a variable in which the command line entered by the user will be stored.","help":"CMNDLINE=*name*","type":"value"},{"name":"COLOR=","optional":true,"description":"Syntax: COLOR=operand","help":"COLOR=WHITE | BLACK | GREEN | MAGENTA | RED | YELLOW | CYAN | GRAY | BLUE*operand*","type":"value","arguments":[{"name":"WHITE","description":"WHITE background color","type":"standalone"},{"name":"BLACK","description":"BLACK background color","type":"standalone"},{"name":"GREEN","description":"GREEN background color","type":"standalone"},{"name":"MAGENTA","description":"MAGENTA background color","type":"standalone"},{"name":"RED","description":"RED background color","type":"standalone"},{"name":"YELLOW","description":"YELLOW background color","type":"standalone"},{"name":"CYAN","description":"CYAN background color","type":"standalone"},{"name":"GRAY","description":"GRAY background color","type":"standalone"},{"name":"BLUE","description":"BLUE background color","type":"standalone"}]},{"name":"COLUMNS=","optional":true,"description":"Specifies the starting number of columns for the window. The operand is either a literal number, a variable name, or an expression in parentheses. The default value is 78 columns.","help":"COLUMNS=*operand*","type":"value"},{"name":"GROUP=","optional":true,"description":"Starts a repeating sequence of groups of fields defined for the window. The group-name specification is a name 1 to 8 characters long used to identify a group of fields in a later DISPLAY statement.","help":"GROUP=*group-name*","type":"value"},{"name":"ICOLUMN=","optional":true,"description":"Specifies the initial starting column position of the window on the display. The operand is either a literal number or a variable name. The default value is column 1.","help":"ICOLUMN=*operand*","type":"value"},{"name":"IROW=","optional":true,"description":"Specifies the initial starting row position of the window on the display. The operand is either a literal number or a variable name. The default value is row 1.","help":"IROW=*operand*","type":"value"},{"name":"MSGLINE=","optional":true,"description":"Specifies the message to be displayed on the standard message line when the window is made active. The operand is almost always the name of a variable, but a character literal can be used.","help":"MSGLINE=*operand*","type":"value"},{"name":"PROTECT=","optional":true,"aliases":["P="],"description":"","type":"value"},{"name":"ROWS=","optional":true,"description":"Determines the starting number of rows of the window. The operand is either a literal number, the name of a variable containing the number, or an expression in parentheses yielding the number. The default value is 23 rows.","help":"ROWS=*operand*","type":"value"}]}],"interactive":true,"supportSiteInformation":{"docsetId":"casimllang","docsetVersion":"v_032","docsetTargetFile":"casimllang_common_toc.htm"}}