{"name":"NETWORK","statements":[{"name":"PROC NETWORK","description":"The NETWORK procedure includes a number of graph theory and network analysis algorithms that can augment data mining and machine learning approaches. In many practical applications of data mining and machine learning models, pairwise interaction between the entities of interest in the model often plays an important role.","help":"PROC NETWORK <options>;\n\tBICONNECTEDCOMPONENTS <options>;    \n\tBY variables;    \n\tCENTRALITY <options>;    \n\tCLIQUE <options>;    \n\tCOMMUNITY <options>;    \n\tCONNECTEDCOMPONENTS <options>;    \n\tCORE <option>;    \n\tCYCLE <options>;    \n\tDISPLAY <table-list></ options>;    \n\tDISPLAYOUT table-spec-list</ options>;    \n\tLINKSQUERYVAR <options>;    \n\tLINKSVAR <options>;    \n\tLOADGRAPH ;    \n\tNODESIMILARITY <options>;    \n\tNODESQUERYVAR <options>;    \n\tNODESSUBSETVAR <options>;    \n\tNODESVAR <options>;    \n\tPATH <options>;    \n\tPATTERNMATCH <options>;    \n\tPROJECTION <options>;    \n\tREACH <options>;    \n\tSHORTESTPATH <options>;    \n\tSUMMARY <options>;    \n\tTOPOLOGICALSORT ;    \n\tTRANSITIVECLOSURE <option>;    \n\tUNLOADGRAPH ;    ","arguments":[{"name":"DETERMINISTIC=","optional":true,"description":"specifies whether to enforce determinism. By default, DETERMINISTIC=TRUE, which ensures that each invocation (with the same machine configuration and parameter settings) produces the same final result.","help":"DETERMINISTIC=TRUE |  FALSE","type":"choice","arguments":[{"name":"TRUE","type":"standalone"},{"name":"FALSE","type":"standalone"}]},{"name":"DIRECTION=","optional":true,"description":"specifies whether the input graph should be considered directed or undirected. By default, DIRECTION=UNDIRECTED.","help":"DIRECTION=DIRECTED | UNDIRECTED","type":"choice","arguments":[{"name":"DIRECTED","description":"considers the input graph to be directed.","type":"standalone"},{"name":"UNDIRECTED","description":"considers the input graph to be undirected.","type":"standalone"}]},{"name":"DISTRIBUTED=","optional":true,"description":"specifies whether to use a distributed graph. By default, DISTRIBUTED=FALSE, which means that a distributed graph is not used.","help":"DISTRIBUTED=TRUE |  FALSE","type":"choice","arguments":[{"name":"TRUE","type":"standalone"},{"name":"FALSE","type":"standalone"}]},{"name":"GRAPH=","optional":true,"description":"specifies the in-memory graph to use. This option can be used with any algorithm that supports in-memory execution.","help":"GRAPH=*number*","type":"value"},{"name":"INDEXOFFSET=","optional":true,"description":"specifies the index offset for identifiers in the log and results output data tables.","help":"INDEXOFFSET=*number*","type":"value"},{"name":"LINKS=","optional":true,"description":"specifies the input data table that contains the graph link information.","help":"LINKS=*libref.data-table*","type":"dataSet"},{"name":"LINKSQUERY=","optional":true,"description":"specifies the input data table that contains the graph link information for the query graph.","help":"LINKSQUERY=*libref.data-table*","type":"dataSet"},{"name":"LOGFREQUENCYTIME=","optional":true,"aliases":["LOGFREQTIME="],"description":"controls the frequency (in number of seconds) for displaying iteration logs for some algorithms, where number can be any integer greater than or equal to 1. By default, LOGFREQTIME=5.","help":"LOGFREQUENCYTIME=*number*","type":"value"},{"name":"LOGLEVEL=","optional":true,"description":"controls the amount of information that is displayed in the SAS log. By default, LOGLEVEL=BASIC.","help":"LOGLEVEL=NONE | BASIC | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"NONE","description":"turns off all procedure-related messages in the SAS log.","type":"standalone"},{"name":"BASIC","description":"displays a brief summary of the algorithmic processing.","type":"standalone"},{"name":"MODERATE","description":"displays a moderately detailed summary of the input, output, and algorithmic processing.","type":"standalone"},{"name":"AGGRESSIVE","description":"displays a more detailed summary of the input, output, and algorithmic processing.","type":"standalone"}]},{"name":"MULTILINKS=","optional":true,"description":"specifies whether to include or aggregate multilinks when an input graph (specified by the LINKS= or LINKSQUERY= option) is read. By default, MULTILINKS=TRUE for algorithms that support multilinks.","help":"MULTILINKS=TRUE |  FALSE","type":"choice","arguments":[{"name":"TRUE","description":"includes multilinks.","type":"standalone"},{"name":"FALSE","description":"aggregates multilinks.","type":"standalone"}]},{"name":"NODES=","optional":true,"description":"specifies the input data table that contains the graph node information.","help":"NODES=*libref.data-table*","type":"dataSet"},{"name":"NODESQUERY=","optional":true,"description":"specifies the input data table that contains the graph node information for the query graph.","help":"NODESQUERY=*libref.data-table*","type":"dataSet"},{"name":"NODESSUBSET=","optional":true,"description":"specifies the input data table that contains the graph node subset information.","help":"NODESSUBSET=*libref.data-table*","type":"dataSet"},{"name":"NTHREADS=","optional":true,"description":"specifies the maximum number of threads to use for multithreaded processing. Some of the algorithms can take advantage of multicore machines and can run faster when number is greater than 1.","help":"NTHREADS=*number*","type":"value"},{"name":"OUTGRAPHLIST=","optional":true,"description":"specifies the output data table to contain summary information about in-memory graphs.","help":"OUTGRAPHLIST=*libref.data-table*","type":"dataSet"},{"name":"OUTLINKS=","optional":true,"description":"specifies the output data table to contain the graph link information along with any results from the algorithms that calculate metrics on links.","help":"OUTLINKS=*libref.data-table*","type":"dataSet"},{"name":"OUTNODES=","optional":true,"description":"specifies the output data table to contain the graph node information along with any results from the algorithms that calculate metrics on nodes.","help":"OUTNODES=*libref.data-table*","type":"dataSet"},{"name":"SELFLINKS=","optional":true,"description":"specifies whether to include or remove self-links when an input graph (specified by the LINKS= or LINKSQUERY= option) is read. By default, SELFLINKS=TRUE for algorithms that support self-links.","help":"SELFLINKS=TRUE |  FALSE","type":"choice","arguments":[{"name":"TRUE","description":"includes self-links.","type":"standalone"},{"name":"FALSE","description":"removes self-links.","type":"standalone"}]},{"name":"STANDARDIZEDLABELS","optional":true,"description":"specifies that the input graph data are in a standardized format.","type":"standalone"},{"name":"STANDARDIZEDLABELSOUT","optional":true,"description":"specifies that the output graph data include standardized format.","type":"standalone"},{"name":"TIMETYPE=","optional":true,"description":"specifies whether CPU time or real time is used for each algorithm’s MAXTIME= option (where applicable). By default, TIMETYPE=REAL.","help":"TIMETYPE=CPU | REAL","type":"choice","arguments":[{"name":"CPU","description":"specifies units of CPU time. The time restriction is applied per processing machine (not across all machines).","type":"standalone"},{"name":"REAL","description":"specifies units of real time.","type":"standalone"}]}]},{"name":"BICONNECTEDCOMPONENTS","description":"The BICONNECTEDCOMPONENTS statement requests that PROC NETWORK find biconnected components and articulation points of an undirected input graph.","help":"BICONNECTEDCOMPONENTS &lt;*options*&gt;;    ","arguments":[{"name":"OUT=","optional":true,"description":"specifies the output data table to contain the biconnected components summary results.","help":"OUT=*libref.data-table*","type":"dataSet"},{"name":"OUTBCTREELINKS=","optional":true,"description":"specifies the output data table to contain the links of the block-cut tree.","help":"OUTBCTREELINKS=*libref.data-table*","type":"dataSet"},{"name":"OUTBCTREENODES=","optional":true,"description":"specifies the output data table to contain the nodes of the block-cut tree.","help":"OUTBCTREENODES=*libref.data-table*","type":"dataSet"}]},{"name":"BY","description":"You can specify a BY statement in PROC NETWORK to obtain separate analyses of observations in groups that are defined by the values of the BY variables.","help":"BY *variables*;    "},{"name":"CENTRALITY","description":"The CENTRALITY statement enables you to select which centrality metrics to calculate for the specified input graph.","help":"CENTRALITY &lt;*options*&gt;;    ","arguments":[{"name":"AUTH=","optional":true,"description":"specifies how to calculate authority centrality.","help":"AUTH=WEIGHT | UNWEIGHT | BOTH","type":"choice","arguments":[{"name":"WEIGHT","description":"calculates authority centrality based on the weighted graph.","type":"standalone"},{"name":"UNWEIGHT","description":"calculates authority centrality based on the unweighted graph.","type":"standalone"},{"name":"BOTH","description":"calculates authority centrality based on both weighted and unweighted graphs.","type":"standalone"}]},{"name":"BETWEEN=","optional":true,"description":"specifies how to calculate betweenness centrality for node betweenness or link betweenness.","help":"BETWEEN=WEIGHT | UNWEIGHT | BOTH","type":"choice","arguments":[{"name":"WEIGHT","description":"calculates betweenness centrality based on the weighted graph.","type":"standalone"},{"name":"UNWEIGHT","description":"calculates betweenness centrality based on the unweighted graph.","type":"standalone"},{"name":"BOTH","description":"calculates betweenness centrality based on both weighted and unweighted graphs.","type":"standalone"}]},{"name":"BETWEENNORM=","optional":true,"description":"specifies whether to normalize the betweenness centrality metrics. By default, BETWEENNORM=TRUE.","help":"BETWEENNORM=TRUE | FALSE","type":"choice","arguments":[{"name":"TRUE","description":"normalizes the betweenness metrics. This is the default.","type":"standalone"},{"name":"FALSE","description":"does not normalize the betweenness metrics.","type":"standalone"}]},{"name":"CLOSE=","optional":true,"description":"specifies how to calculate closeness centrality.","help":"CLOSE=WEIGHT | UNWEIGHT | BOTH","type":"choice","arguments":[{"name":"WEIGHT","description":"calculates closeness centrality based on the weighted graph.","type":"standalone"},{"name":"UNWEIGHT","description":"calculates closeness centrality based on the unweighted graph.","type":"standalone"},{"name":"BOTH","description":"calculates closeness centrality based on both weighted and unweighted graphs.","type":"standalone"}]},{"name":"CLOSENOPATH=","optional":true,"description":"specifies a method for accounting for the shortest path distance between two nodes when a path does not exist (disconnected nodes). By default, CLOSENOPATH=DIAMETER.","help":"CLOSENOPATH=DIAMETER | HARMONIC | NNODES | ZERO","type":"choice","arguments":[{"name":"DIAMETER","description":"uses the graph diameter as a shortest path between disconnected nodes.","type":"standalone"},{"name":"HARMONIC","description":"uses the harmonic formula for calculating closeness centrality.","type":"standalone"},{"name":"NNODES","description":"uses the number of nodes as a shortest path between disconnected nodes.","type":"standalone"},{"name":"ZERO","description":"uses zero as a shortest path between disconnected nodes.","type":"standalone"}]},{"name":"CLUSTERINGCOEFFICIENT","optional":true,"aliases":["CLUSTERINGCOEF"],"description":"calculates the node clustering coefficient.","type":"standalone"},{"name":"DEGREE=","optional":true,"description":"specifies how to calculate degree centrality.","help":"DEGREE=WEIGHT | UNWEIGHT | BOTH","type":"choice","arguments":[{"name":"WEIGHT","description":"calculates degree centrality by using the weighted graph..","type":"standalone"},{"name":"UNWEIGHT","description":"calculates degree centrality by using the unweighted graph.","type":"standalone"},{"name":"BOTH","description":"calculates degree centrality by using both the weighted and unweighted graph graphs.","type":"standalone"}]},{"name":"EIGEN=","optional":true,"description":"specifies how to calculate eigenvector centrality.","help":"EIGEN=WEIGHT | UNWEIGHT | BOTH","type":"choice","arguments":[{"name":"WEIGHT","description":"calculates eigenvector centrality based on the weighted graph.","type":"standalone"},{"name":"UNWEIGHT","description":"calculates eigenvector centrality based on the unweighted graph.","type":"standalone"},{"name":"BOTH","description":"calculates eigenvector centrality based on both weighted and unweighted graphs.","type":"standalone"}]},{"name":"EIGENALGORITHM=","optional":true,"description":"specifies the algorithm to use in calculating centrality metrics that require solving eigensystems—that is, when the EIGEN, PAGERANK, HUB, or AUTH option (or some combination) is specified. By default, EIGENALGORITHM=AUTOMATIC.","help":"EIGENALGORITHM=AUTOMATIC | JACOBIDAVIDSON | POWER","type":"choice","arguments":[{"name":"AUTOMATIC","description":"automatically determines the eigensolver to use.","type":"standalone"},{"name":"JACOBIDAVIDSON","description":"uses a variant of the Jacobi-Davidson algorithm for solving eigensystems.","type":"standalone"},{"name":"POWER","description":"uses the power method to calculate eigenvectors.","type":"standalone"}]},{"name":"EIGENMAXITER=","optional":true,"description":"specifies the maximum number of iterations to use for eigenvector calculations in order to limit the amount of computation time spent when convergence is slow. By default, EIGENMAXITERS=10,000.","help":"EIGENMAXITER=*number*","type":"value"},{"name":"HUB=","optional":true,"description":"specifies how to calculate hub centrality.","help":"HUB=WEIGHT | UNWEIGHT | BOTH","type":"choice","arguments":[{"name":"WEIGHT","description":"calculates hub centrality by using the weighted graph.","type":"standalone"},{"name":"UNWEIGHT","description":"calculates hub centrality by using the unweighted graph.","type":"standalone"},{"name":"BOTH","description":"calculates hub centrality by using both the weighted and unweighted graphs.","type":"standalone"}]},{"name":"INFLUENCE=","optional":true,"description":"specifies how to calculate influence centrality.","help":"INFLUENCE=WEIGHT | UNWEIGHT | BOTH","type":"choice","arguments":[{"name":"WEIGHT","description":"calculates influence centrality by using the weighted graph.","type":"standalone"},{"name":"UNWEIGHT","description":"calculates influence centrality by using the unweighted graph.","type":"standalone"},{"name":"BOTH","description":"calculates influence centrality by using both the weighted and unweighted graphs.","type":"standalone"}]},{"name":"PAGERANK=","optional":true,"description":"specifies how to calculate PageRank centrality.","help":"PAGERANK=WEIGHT | UNWEIGHT | BOTH","type":"choice","arguments":[{"name":"WEIGHT","description":"calculates PageRank centrality by using the weighted graph.","type":"standalone"},{"name":"UNWEIGHT","description":"calculates PageRank centrality by using the unweighted graph.","type":"standalone"},{"name":"BOTH","description":"calculates PageRank centrality by using both the weighted and unweighted graphs.","type":"standalone"}]},{"name":"PAGERANKALPHA=","optional":true,"description":"specifies the damping factor to use in the PageRank algorithm.","help":"PAGERANKALPHA=*number*","type":"value"},{"name":"PAGERANKTOLERANCE=","optional":true,"description":"specifies the convergence tolerance value for the PageRank algorithm.","help":"PAGERANKTOLERANCE=*number*","type":"value"},{"name":"SAMPLEPERCENT=","optional":true,"description":"specifies the percentage of source nodes to sample for the approximate betweenness calculation. The default is 100.","help":"SAMPLEPERCENT=*number*","type":"value"}]},{"name":"CLIQUE","description":"The CLIQUE statement invokes an algorithm that finds maximal cliques in the input graph.","help":"CLIQUE &lt;*options*&gt;;    ","arguments":[{"name":"CLIQUENUMBER=","optional":true,"description":"specifies whether to calculate the clique number of the graph. By default, CLIQUENUMBER=FALSE.","help":"CLIQUENUMBER=TRUE | FALSE","type":"choice","arguments":[{"name":"TRUE","type":"standalone"},{"name":"FALSE","type":"standalone"}]},{"name":"MAXCLIQUES=","optional":true,"description":"specifies the maximum number of cliques for clique enumeration to return. By default, MAXCLIQUES=1 when CLIQUENUMBER=FALSE; otherwise, MAXCLIQUES=ALL.","help":"MAXCLIQUES=*number* | ALL","type":"choice","arguments":[{"name":"number","placeholder":true,"type":"value"},{"name":"ALL","type":"standalone"}]},{"name":"MAXLINKWEIGHT=","optional":true,"description":"specifies the maximum sum of link weights in a clique. The default is the largest number that can be represented by a double. When the default is used, no cliques are removed from the results.","help":"MAXLINKWEIGHT=*number*","type":"value"},{"name":"MAXNODEWEIGHT=","optional":true,"description":"specifies the maximum sum of node weights in a clique. The default is the largest number that can be represented by a double. When the default is used, no cliques are removed from the results.","help":"MAXNODEWEIGHT=*number*","type":"value"},{"name":"MAXSIZE=","optional":true,"description":"specifies the maximum number of nodes in a clique. The default is the largest number that can be represented by a 32-bit integer. When the default is used, no cliques are removed from the results.","help":"MAXSIZE=*number*","type":"value"},{"name":"MAXTIME=","optional":true,"description":"specifies the maximum amount of time to spend finding cliques. The default is the largest number that can be represented by a double.","help":"MAXTIME=*number*","type":"value"},{"name":"MINLINKWEIGHT=","optional":true,"description":"specifies the minimum sum of link weights in a clique. The default is the largest (in magnitude) negative number that can be represented by a double. When the default is used, no cliques are removed from the results.","help":"MINLINKWEIGHT=*number*","type":"value"},{"name":"MINNODEWEIGHT=","optional":true,"description":"specifies the minimum sum of node weights in a clique. The default is the largest (in magnitude) negative number that can be represented by a double, which causes no cliques to be removed from the results.","help":"MINNODEWEIGHT=*number*","type":"value"},{"name":"MINSIZE=","optional":true,"description":"specifies the minimum number of nodes in a clique. By default, MINSIZE=1 and no cliques are removed from the results.","help":"MINSIZE=*number*","type":"value"},{"name":"OUT=","optional":true,"description":"specifies the output data table to contain the maximal cliques.","help":"OUT=*libref.data-table*","type":"dataSet"}]},{"name":"COMMUNITY","description":"The COMMUNITY statement invokes an algorithm that detects communities of the input graph.","help":"COMMUNITY &lt;*options*&gt;;    ","arguments":[{"name":"ALGORITHM=","optional":true,"description":"specifies the algorithm to use for community detection. By default, ALGORITHM=LOUVAIN.","help":"ALGORITHM=LOUVAIN | LABELPROP","type":"choice","arguments":[{"name":"LABELPROPAGATION","description":"uses the label propagation algorithm proposed by Raghavan, Albert, and Kumara (2007)","type":"standalone"},{"name":"LOUVAIN","description":"uses the Louvain algorithm proposed in Blondel et al. (2008).","type":"standalone"}]},{"name":"FIX=","optional":true,"description":"specifies which data variable defines groups of nodes to fix together in a community.","help":"FIX=*column*","type":"value"},{"name":"LABELUPDATEMODE=","optional":true,"description":"specifies whether nodes update their labels according to the labels of their neighbors at the current iteration (asynchronous) or the previous iteration (synchronous). This option is ignored unless you specify ALGORITHM=LABELPROPAGATION. By default, LABELUPDATEMODE=SYNCHRONOUS..","help":"LABELUPDATEMODE=ASYNCHRONOUS | SYNCHRONOUS","type":"choice","arguments":[{"name":"ASYNCHRONOUS","type":"standalone"},{"name":"SYNCHRONOUS","type":"standalone"}]},{"name":"LINKREMOVALRATIO=","optional":true,"description":"specifies the percentage of small-weight links to be removed around each node neighborhood. A link is usually removed if its weight is relatively smaller than the weights of the neighboring links.","help":"LINKREMOVALRATIO=*number*","type":"value"},{"name":"MAXITERS=","optional":true,"description":"specifies the maximum number of iterations allowed in the algorithm. The default is 20 when ALGORITHM=LOUVAIN and 100 when ALGORITHM=LABEL_PROP or ALGORITHM=PARALLEL_LABEL_PROP.","help":"MAXITERS=*number*","type":"value"},{"name":"OUTCOMMLINKS=","optional":true,"description":"specifies the output data table to describe the links between communities.","help":"OUTCOMMLINKS=*libref.data-table*","type":"dataSet"},{"name":"OUTCOMMUNITY=","optional":true,"description":"specifies the output data table to contain properties about each community.","help":"OUTCOMMUNITY=*libref.data-table*","type":"dataSet"},{"name":"OUTLEVEL=","optional":true,"description":"specifies the output data table to contain community information at different resolution levels.","help":"OUTLEVEL=*libref.data-table*","type":"dataSet"},{"name":"OUTOVERLAP=","optional":true,"description":"specifies the output data table to describe the intensity of each node.","help":"OUTOVERLAP=*libref.data-table*","type":"dataSet"},{"name":"RANDOMFACTOR=","optional":true,"description":"specifies the random factor for the synchronous label propagation algorithm. The default is 0.15.","help":"RANDOMFACTOR=*number*","type":"value"},{"name":"RANDOMSEED=","optional":true,"description":"specifies the random seed for the synchronous label propagation algorithm. By default, RANDOMSEED=1234.","help":"RANDOMSEED=*number*","type":"value"},{"name":"RECURSIVE","optional":true,"description":"breaks down large communities into smaller ones until the specified conditions are satisfied.","help":"RECURSIVE(*options*)","type":"value","arguments":[{"name":"MAXCOMMSIZE=","description":"specifies the maximum number of nodes to be contained in any community. The default is the largest number that can be represented by a 32-bit integer.","type":"value"},{"name":"MAXDIAMETER=","description":"specifies the maximum number of links on the shortest paths between any pair of nodes in any community. The default is the largest number that can be represented by a 32-bit integer.","type":"value"},{"name":"RELATION=","description":"the relationship between the values of MAXCOMMSIZE= and MAXDIAMETER= options.","type":"value"}]},{"name":"RESOLUTIONLIST=","optional":true,"description":"specifies a list of resolution values (nonnegative numbers) that are separated by spaces (for example, 4.3 2.1 1.0 0.6 0.2).","help":"RESOLUTIONLIST=*num-list*","type":"value"},{"name":"TOLERANCE=","optional":true,"aliases":["MODULARITY="],"description":"specifies the tolerance value for when to stop iterations. By default, TOLERANCE=0.05 if ALGORITHM=LABELPROPAGATION and LABELUPDATEMODE=SYNCHRONOUS; otherwise TOLERANCE=0.001.","help":"TOLERANCE=*number*","type":"value"},{"name":"WARMSTART=","optional":true,"description":"specifies which data variable defines the initial node partition for warm starting community detection.","help":"WARMSTART=*column*","type":"value"}]},{"name":"CONNECTEDCOMPONENTS","description":"The CONNECTEDCOMPONENTS statement invokes an algorithm that finds the connected components of the input graph.","help":"CONNECTEDCOMPONENTS &lt;*options*&gt;;    ","arguments":[{"name":"ALGORITHM=","optional":true,"description":"specifies the algorithm to use for calculating connected components. By default, ALGORITHM=AUTOMATIC.","help":"ALGORITHM=AUTOMATIC | AFFOREST | DFS | UNIONFIND","type":"choice","arguments":[{"name":"AUTOMATIC","description":"uses the union-find or afforest algorithm for undirected graphs and the depth-first search algorithm for directed graphs.","type":"standalone"},{"name":"AFFOREST","description":"uses the afforest algorithm for connected components. You can use this algorithm only with undirected graphs.","type":"standalone"},{"name":"DFS","description":"uses the depth-first search algorithm for connected components.","type":"standalone"},{"name":"UNIONFIND","description":"uses the union-find algorithm for connected components. You can use this algorithm only with undirected graphs.","type":"standalone"}]},{"name":"OUT=","optional":true,"description":"specifies the output data table to contain the connected components summary results.","help":"OUT=*libref.data-table*","type":"dataSet"}]},{"name":"CORE","description":"The CORE statement invokes an algorithm that finds the core decomposition of the input graph.","help":"CORE &lt;*option*&gt;;    ","arguments":[{"name":"MAXTIME=","optional":true,"description":"specifies the maximum amount of time to spend calculating the core decomposition. The default is the largest number that can be represented by a double.","help":"MAXTIME=*number*","type":"value"}]},{"name":"CYCLE","description":"The CYCLE statement invokes an algorithm that finds the cycles (or the existence of a cycle) in the input graph.","help":"CYCLE &lt;*options*&gt;;    ","arguments":[{"name":"ALGORITHM=","optional":true,"description":"specifies which algorithm to use in enumerating cycles. By default, ALGORITHM=BACKTRACK for MAXLENGTH greater than 20; otherwise, ALGORITHM=BUILD.","help":"ALGORITHM=BACKTRACK | BUILD","type":"choice","arguments":[{"name":"BACKTRACK","description":"uses a backtracking algorithm based on Johnson (1975).","type":"standalone"},{"name":"BUILD","description":"uses a building algorithm based on Liu and Wang (2006).","type":"standalone"}]},{"name":"MAXCYCLES=","optional":true,"description":"specifies the maximum number of cycles for cycle enumeration to return. By default, MAXCYCLES=1.","help":"MAXCYCLES=*number* | ALL","type":"choice","arguments":[{"name":"number","placeholder":true,"type":"value"},{"name":"ALL","type":"standalone"}]},{"name":"MAXLENGTH=","optional":true,"description":"specifies the maximum number of links in a cycle. The default is the largest number that can be represented by a 32-bit integer, which causes no cycles to be removed from the results.","help":"MAXLENGTH=*number*","type":"value"},{"name":"MAXLINKWEIGHT=","optional":true,"description":"specifies the maximum sum of link weights in a cycle. The default is the largest number that can be represented by a double. When the default is used, no cycles are removed from the results.","help":"MAXLINKWEIGHT=*number*","type":"value"},{"name":"MAXNODEWEIGHT=","optional":true,"description":"specifies the maximum sum of node weights in a cycle. The default is the largest number that can be represented by a double. When the default is used, no cycles are removed from the results.","help":"MAXNODEWEIGHT=*number*","type":"value"},{"name":"MAXTIME","optional":true,"description":"specifies the maximum amount of time to spend finding cycles. The default is the largest number that can be represented by a double.","type":"standalone"},{"name":"MINLENGTH=","optional":true,"description":"specifies the minimum number of links in a cycle. By default, MINLENGTH=1 and no cycles are removed from the results.","help":"MINLENGTH=*number*","type":"value"},{"name":"MINLINKWEIGHT=","optional":true,"description":"specifies the minimum sum of link weights in a cycle. The default is the largest (in magnitude) negative number that can be represented by a double. When the default is used, no cycles are removed from the results.","help":"MINLINKWEIGHT=*number*","type":"value"},{"name":"MINNODEWEIGHT=","optional":true,"description":"specifies the minimum sum of node weights in a cycle. The default is the largest (in magnitude) negative number that can be represented by a double, which causes no cycles to be removed from the results.","help":"MINNODEWEIGHT=*number*","type":"value"},{"name":"OUTCYCLESLINKS=","optional":true,"description":"specifies the output data table to contain the links of the cycles found.","help":"OUTCYCLESLINKS=*libref.data-table*","type":"dataSet"},{"name":"OUT=","optional":true,"aliases":["OUTCYCLESNODES="],"description":"specifies the output data table to contain the nodes of the cycles found.","help":"OUT=*libref.data-table*","type":"dataSet"}]},{"name":"DISPLAY","description":"The DISPLAY statement enables you to specify a list of display tables to display or exclude.","help":"DISPLAY &lt;*table-list*&gt;&lt;*/ options*&gt;;    ","arguments":[{"name":"CASESENSITIVE","optional":true,"followsDelimiter":"/","description":"performs a case-sensitive comparison of table names in the table-list to display table names when tables are subsetted for display. To preserve case, you must enclose table names in the table-list in quotation marks.","type":"standalone"},{"name":"EXCLUDE","optional":true,"followsDelimiter":"/","description":"displays all display tables except those that you specify in the table-list.","type":"standalone"},{"name":"EXCLUDEALL","optional":true,"followsDelimiter":"/","description":"suppresses display of all tables. This option takes precedence over the other options.","type":"standalone"},{"name":"TRACE","optional":true,"followsDelimiter":"/","description":"displays the display table names, labels, and paths.","type":"standalone"}]},{"name":"DISPLAYOUT","description":"The DISPLAYOUT statement enables you to create output tables from your displayed output.","help":"DISPLAYOUT *table-spec-list*&lt;*/ options*&gt;;    ","arguments":[{"name":"INCLUDEALL","optional":true,"followsDelimiter":"/","description":"creates output tables for all display tables.","type":"standalone"},{"name":"NOREPLACE","optional":true,"followsDelimiter":"/","description":"does not replace any existing output table of the same name.","type":"standalone"},{"name":"REPEATED","optional":true,"followsDelimiter":"/","description":"replicates all output tables on all nodes.","type":"standalone"}]},{"name":"LINKSQUERYVAR","description":"The LINKSQUERYVAR statement enables you to explicitly specify the data variable names for PROC NETWORK to use when it reads the data table that you specify in the LINKSQUERY= option in the PROC NETWORK statement.","help":"LINKSQUERYVAR &lt;*options*&gt;;    ","arguments":[{"name":"EXPANDLOWER=","optional":true,"description":"specifies the name of the data variable for the query path expansion lower bounds.","help":"EXPANDLOWER=*column*","type":"value"},{"name":"EXPANDUPPER=","optional":true,"description":"specifies the name of the data variable for the query path expansion upper bounds.","help":"EXPANDUPPER=*column*","type":"value"},{"name":"FROM=","optional":true,"aliases":["FROMVAR="],"description":"specifies the name of the data variable for the from nodes. The default name is from.","help":"FROM=*column*","type":"value"},{"name":"TO=","optional":true,"aliases":["TOVAR="],"description":"specifies the name of the data variable for the to nodes. The default name is to.","help":"TO=*column*","type":"value"},{"name":"VARS=","optional":true,"description":"specifies the names of the data variables to read.","help":"VARS=(*columns*)","type":"value"},{"name":"VARSMATCH=","optional":true,"description":"specifies the names of the data variables to match in the query graph. The value of the variables can be numeric or character.","help":"VARSMATCH=(*columns*)","type":"value"}]},{"name":"LINKSVAR","description":"The LINKSVAR statement enables you to explicitly specify the data variable names for PROC NETWORK to use when it reads the data table that you specify in the LINKS= option in the PROC NETWORK statement.","help":"LINKSVAR &lt;*options*&gt;;    ","arguments":[{"name":"AUXWEIGHT=","optional":true,"description":"specifies the name of the data variable for the auxiliary link weights. The value of the column variable must be numeric.","help":"AUXWEIGHT=*column*","type":"value"},{"name":"FROM=","optional":true,"aliases":["FROMVAR="],"description":"specifies the name of the data variable for the from nodes. The default name is from.","help":"FROM=*column*","type":"value"},{"name":"TO=","optional":true,"aliases":["TOVAR="],"description":"specifies the name of the data variable for the to nodes. The default name is to.","help":"TO=*column*","type":"value"},{"name":"VARS=","optional":true,"description":"specifies the names of the additional data variables to read.","help":"VARS=(*columns*)","type":"value"},{"name":"VARSOUT=","optional":true,"description":"specifies the names of the additional data variables to write to the output results. By default, the variables to write are the same as the variables read (as specified in the VARS= option).","help":"VARSOUT=(*columns*)","type":"value"},{"name":"WEIGHT=","optional":true,"description":"specifies the name of the data variable for the link weights. The default name is weight.","help":"WEIGHT=*column*","type":"value"}]},{"name":"LOADGRAPH","description":"The LOADGRAPH statement reads the input graph from tables that are specified by the LINKS= option or the NODES= option (or both) in the PROC NETWORK statement, and it retains the graph in memory.","help":"LOADGRAPH ;    "},{"name":"NODESIMILARITY","description":"The NODESIMILARITY statement invokes an algorithm that calculates how similar the neighborhoods of pairs of nodes are in an input graph.","help":"NODESIMILARITY &lt;*options*&gt;;    ","arguments":[{"name":"ADAMICADAR=","optional":true,"description":"specifies whether to calculate Adamic-Adar node similarity. By default, ADAMICADAR=FALSE.","help":"ADAMICADAR=TRUE |  FALSE","type":"choice","arguments":[{"name":"TRUE","description":"calculates Adamic-Adar node similarity and saves the results in the output table that is specified in the OUTSIMILARITY= option.","type":"standalone"},{"name":"FALSE","description":"does not calculate Adamic-Adar node similarity.","type":"standalone"}]},{"name":"BOTTOMK=","optional":true,"description":"specifies the maximum number of lowest-ranked similarity pairs to output in the OUTSIMILARITY= table, where number can be any integer greater than or equal to 0.","help":"BOTTOMK=*number*","type":"value"},{"name":"COMMONNEIGHBORS=","optional":true,"description":"specifies whether to calculate common neighbors node similarity. By default, COMMONNEIGHBORS=FALSE.","help":"COMMONNEIGHBORS=TRUE |  FALSE","type":"choice","arguments":[{"name":"TRUE","description":"calculates common neighbors node similarity and saves the results in the output table that is specified in the OUTSIMILARITY= option.","type":"standalone"},{"name":"FALSE","description":"does not calculate common neighbors node similarity.","type":"standalone"}]},{"name":"CONVERGENCETHRESHOLD=","optional":true,"description":"specifies the convergence threshold for vector similarity. By default, CONVERGENCETHRESHOLD=0.01.","help":"CONVERGENCETHRESHOLD=*number*","type":"value"},{"name":"COSINE=","optional":true,"description":"specifies whether to calculate cosine node similarity. By default, COSINE=FALSE.","help":"COSINE=TRUE | FALSE","type":"choice","arguments":[{"name":"TRUE","description":"calculates cosine node similarity and saves the results in the output table that is specified in the OUTSIMILARITY= option.","type":"standalone"},{"name":"FALSE","description":"does not calculate cosine node similarity.","type":"standalone"}]},{"name":"DICE=","optional":true,"description":"specifies whether to calculate Dice node similarity. By default, DICE=FALSE.","help":"DICE=TRUE | FALSE","type":"choice","arguments":[{"name":"TRUE","description":"calculates Dice node similarity and saves the results in the output table that is specified in the OUTSIMILARITY= option.","type":"standalone"},{"name":"FALSE","description":"does not calculate Dice node similarity.","type":"standalone"}]},{"name":"EMBED=","optional":true,"description":"specifies whether to calculate vector embeddings. By default, EMBED=FALSE when VECTOR=FALSE, and EMBED=TRUE when VECTOR=TRUE.","help":"EMBED=TRUE | FALSE","type":"choice","arguments":[{"name":"TRUE","description":"calculates vector embeddings and saves the results in the output table that is specified in the OUTNODES= option.","type":"standalone"},{"name":"FALSE","description":"does not calculate vector embeddings.","type":"standalone"}]},{"name":"EMBEDDINGS=","optional":true,"description":"specifies the names of one or more data variables to be used as precalculated vector embeddings.","help":"EMBEDDINGS=(*columns*)","type":"value"},{"name":"JACCARD=","optional":true,"description":"specifies whether to calculate Jaccard node similarity.","help":"JACCARD=TRUE | FALSE","type":"choice","arguments":[{"name":"TRUE","description":"calculates Jaccard node similarity and saves the results in the output table that is specified in the OUTSIMILARITY= option.","type":"standalone"},{"name":"FALSE","description":"does not calculate Jaccard node similarity.","type":"standalone"}]},{"name":"MAXSCORE=","optional":true,"description":"specifies the maximum similarity score to output in the OUTSIMILARITY= table, where number must be in the range [0, 1]. By default, MAXSCORE=1.","help":"MAXSCORE=*number*","type":"value"},{"name":"MINSCORE=","optional":true,"description":"specifies the minimum similarity score to output in the OUTSIMILARITY= table, where number must be in the range [0, 1]. By default, MINSCORE=0.","help":"MINSCORE=*number*","type":"value"},{"name":"NDIMENSIONS=","optional":true,"description":"specifies the number of dimensions for node-embedding vectors. By default, NDIMENSIONS=100.","help":"NDIMENSIONS=*number*","type":"value"},{"name":"NEGATIVESAMPLEFACTOR=","optional":true,"description":"specifies a multiplier for the number of negative training samples per positive training sample for the vector algorithm. By default, NEGATIVESAMPLEFACTOR=5.","help":"NEGATIVESAMPLEFACTOR=*number*","type":"value"},{"name":"NSAMPLES=","optional":true,"description":"specifies the number of training samples for the vector algorithm. NSAMPLES=1000 times the number of links in the input graph.","help":"NSAMPLES=*number*","type":"value"},{"name":"ORDERBY=","optional":true,"description":"specifies the similarity measure to use for ranking the similarity pairs to output in the OUTSIMILARITY= table.","help":"ORDERBY=JACCARD | COMMONNEIGHBORS | ADAMICADAR | VECTOR | COSINE","type":"choice","arguments":[{"name":"JACCARD","type":"standalone"},{"name":"COMMONNEIGHBORS","type":"standalone"},{"name":"ADAMICADAR","type":"standalone"},{"name":"VECTOR","type":"standalone"},{"name":"COSINE","type":"standalone"}]},{"name":"OUTCONVERGENCE=","optional":true,"description":"specifies the output data table to contain the convergence curves for vector similarity.","help":"OUTCONVERGENCE=*libref.data-table*","type":"dataSet"},{"name":"OUTSIMILARITY=","optional":true,"description":"specifies the output data table to contain the similarity scores between pairs of nodes.","help":"OUTSIMILARITY=*libref.data-table*","type":"dataSet"},{"name":"PROXIMITYORDER=","optional":true,"description":"specifies the type of proximity to use in the vector algorithm.","help":"PROXIMITYORDER=FIRST | SECOND","type":"choice","arguments":[{"name":"FIRST","description":"uses first-order proximity in the vector algorithm.","type":"standalone"},{"name":"SECOND","description":"uses second-order proximity in the vector algorithm.","type":"standalone"}]},{"name":"SINK=","optional":true,"description":"specifies the sink node for node similarity calculations.","help":"SINK=*sink-node*","type":"value"},{"name":"SOURCE=","optional":true,"description":"specifies the source node for node similarity calculations.","help":"SOURCE=*source-node*","type":"value"},{"name":"SPARSE=","optional":true,"description":"specifies whether to output sparse similarity data.","help":"SPARSE=TRUE | FALSE","type":"choice","arguments":[{"name":"TRUE","description":"outputs a sparse set of node pairs in the OUTSIMILARITY= table.","type":"standalone"},{"name":"FALSE","description":"outputs a dense set of node pairs in the OUTSIMILARITY= table.","type":"standalone"}]},{"name":"TOPK=","optional":true,"description":"specifies the maximum number of highest-ranked similarity pairs to output in the OUTSIMILARITY= table, where number can be any integer greater than or equal to 0.","help":"TOPK=*number*","type":"value"},{"name":"VECTOR=","optional":true,"description":"specifies whether to calculate vector node similarity. By default, VECTOR=FALSE.","help":"VECTOR=TRUE | FALSE","type":"choice","arguments":[{"name":"TRUE","description":"calculates vector node similarity and saves the results in the output table that is specified in the OUTSIMILARITY= option.","type":"standalone"},{"name":"FALSE","description":"does not calculate vector node similarity.","type":"standalone"}]}]},{"name":"NODESQUERYVAR","description":"The NODESQUERYVAR statement enables you to explicitly specify the data variable names for PROC NETWORK to use when it reads the data table that you specify in the NODESQUERY= option in the PROC NETWORK statement.","help":"NODESQUERYVAR &lt;*options*&gt;;    ","arguments":[{"name":"NODE=","optional":true,"description":"specifies the name of the data variable for the nodes. The value of the variable can be numeric or character.","help":"NODE=*column*","type":"value"},{"name":"VARS=","optional":true,"description":"specifies the names of the data variables to read. The value of the variables can be numeric or character.","help":"VARS=(*columns*)","type":"value"},{"name":"VARSMATCH=","optional":true,"description":"specifies the names of the data variables to match in the query graph. The value of the variables can be numeric or character.","help":"VARSMATCH=(*columns*)","type":"value"}]},{"name":"NODESSUBSETVAR","description":"The NODESSUBSETVAR statement enables you to explicitly specify the data variable names for PROC NETWORK to use when it reads the data table that you specify in the NODESSUBSET= option in the PROC NETWORK statement.","help":"NODESSUBSETVAR &lt;*options*&gt;;    ","arguments":[{"name":"NODE=","optional":true,"description":"specifies the name of the data variable for the nodes. The value of the column variable can be numeric or character.","help":"NODE=*column*","type":"value"},{"name":"REACH=","optional":true,"description":"specifies the name of the data variable for the reach identifier. The value of the column variable must be numeric.","help":"REACH=*column*","type":"value"},{"name":"SINK=","optional":true,"description":"specifies the name of the data variable for the sink indicator. The value of the column variable must be numeric.","help":"SINK=*column*","type":"value"},{"name":"SOURCE=","optional":true,"description":"specifies the name of the data variable for the source indicator. The value of the column variable must be numeric.","help":"SOURCE=*column*","type":"value"}]},{"name":"NODESVAR","description":"The NODESVAR statement enables you to explicitly specify the data variable names for PROC NETWORK to use when it reads the data table that you specify in the NODES= option in the PROC NETWORK statement.","help":"NODESVAR &lt;*options*&gt;;    ","arguments":[{"name":"NODE=","optional":true,"description":"specifies the name of the data variable for the nodes. The value of the column variable can be numeric or character. The default name is node.","help":"NODE=*column*","type":"value"},{"name":"VARS=","optional":true,"description":"specifies the names of the additional data variables to read. The value of the variables can be numeric or character.","help":"VARS=(*column(s)*)","type":"value"},{"name":"VARSOUT=","optional":true,"description":"specifies the names of the additional data variables to write to the output results. The value of the variables can be numeric or character. By default, the variables to write are the same as the variables read (as specified in the VARS= option).","help":"VARSOUT=(*column(s)*)","type":"value"},{"name":"WEIGHT=","optional":true,"description":"specifies the name of the data variable for the node weights. The value of the column variable must be numeric. The default name is weight.","help":"WEIGHT=*column*","type":"value"}]},{"name":"PATH","description":"The PATH statement invokes an algorithm that finds the paths in the input graph.","help":"PATH &lt;*options*&gt;;    ","arguments":[{"name":"MAXLENGTH=","optional":true,"description":"specifies the maximum number of links in a path. The default is the largest number that can be represented by a 32-bit integer. When the default is used, no paths are removed from the results.","help":"MAXLENGTH=*number*","type":"value"},{"name":"MAXLINKWEIGHT=","optional":true,"description":"specifies the maximum sum of link weights in a path. The default is the largest number that can be represented by a double. When the default is used, no paths are removed from the results.","help":"MAXLINKWEIGHT=*number*","type":"value"},{"name":"MAXNODEWEIGHT=","optional":true,"description":"specifies the maximum sum of node weights in a path. The default is the largest number that can be represented by a double. When the default is used, no paths are removed from the results.","help":"MAXNODEWEIGHT=*number*","type":"value"},{"name":"MAXTIME=","optional":true,"description":"specifies the maximum amount of time to spend finding paths. The default is the largest number that can be represented by a double.","help":"MAXTIME=*number*","type":"value"},{"name":"MINLENGTH=","optional":true,"description":"specifies the minimum number of links in a path. By default, MINLENGTH=1 and no paths are removed from the results.","help":"MINLENGTH=*number*","type":"value"},{"name":"MINLINKWEIGHT=","optional":true,"description":"specifies the minimum sum of link weights in a path. The default is the largest (in magnitude) negative number that can be represented by a double. When the default is used, no paths are removed from the results.","help":"MINLINKWEIGHT=*number*","type":"value"},{"name":"MINNODEWEIGHT=","optional":true,"description":"specifies the minimum sum of node weights in a path. The default is the largest (in magnitude) negative number that can be represented by a double, which causes no paths to be removed from the results.","help":"MINNODEWEIGHT=number","type":"value"},{"name":"OUTPATHSLINKS=","optional":true,"aliases":["OUTPATHS="],"description":"specifies the output data table to contain the path links.","help":"OUTPATHSLINKS=*libref.data-table*","type":"dataSet"},{"name":"OUTPATHSNODES=","optional":true,"description":"specifies the output data table to contain the path nodes.","help":"OUTPATHSNODES=*libref.data-table*","type":"dataSet"},{"name":"SINK=","optional":true,"description":"specifies the sink node for path calculations.","help":"SINK=*sink-node*","type":"value"},{"name":"SOURCE=","optional":true,"description":"specifies the source node for path calculations.","help":"SOURCE=*source-node*","type":"value"}]},{"name":"PATTERNMATCH","description":"The PATTERNMATCH statement invokes an algorithm that searches for subgraph patterns in an input graph.","help":"PATTERNMATCH &lt;*options*&gt;;    ","arguments":[{"name":"CODE=","optional":true,"description":"specifies the code that defines FCMP functions.","help":"CODE=*string*","type":"value"},{"name":"INDUCED=","optional":true,"description":"specifies whether to filter matches by using the induced subgraph of the match. By default, INDUCED=FALSE.","help":"INDUCED=TRUE | FALSE","type":"choice","arguments":[{"name":"TRUE","description":"keeps only matches whose induced subgraph is topologically equivalent to the query graph.","type":"standalone"},{"name":"FALSE","description":"does not filter by using the induced subgraph of the match.","type":"standalone"}]},{"name":"LINKFILTER=","optional":true,"description":"specifies the FCMP function for link filters.","help":"LINKFILTER=*function-name*","type":"value"},{"name":"LINKPAIRFILTER=","optional":true,"description":"specifies the FCMP function for link-pair filters.","help":"LINKPAIRFILTER=*function-name*","type":"value"},{"name":"MATCHFILTER=","optional":true,"description":"specifies the FCMP function for a filter that is based on a potential match (that is, any subset of nodes or links or both).","help":"MATCHFILTER=*function-name*","type":"value"},{"name":"MAXMATCHES=","optional":true,"aliases":["MAXMATCHESPERQUERY"],"description":"specifies the maximum number of matches to return for each pattern-matching query. By default, MAXMATCHESPERQUERY=ALL.","help":"MAXMATCHES=*number* | ALL","type":"value"},{"name":"MAXTIME=","optional":true,"description":"specifies the maximum amount of time to spend in the pattern matching algorithm. The default is the largest number that can be represented by a double.","help":"MAXTIME=*number*","type":"value"},{"name":"NODEFILTER=","optional":true,"description":"specifies the FCMP function for node filters.","help":"NODEFILTER=*function-name*","type":"value"},{"name":"NODEPAIRFILTER=","optional":true,"description":"specifies the FCMP function for node-pair filters.","help":"NODEPAIRFILTER=*function-name*","type":"value"},{"name":"OUTMATCHGRAPHLINKS=","optional":true,"description":"specifies the links output data table for the induced subgraph of matches.","help":"OUTMATCHGRAPHLINKS=*libref.data-table*","type":"dataSet"},{"name":"OUTMATCHGRAPHNODES=","optional":true,"description":"specifies the nodes output data table for the induced subgraph of matches.","help":"OUTMATCHGRAPHNODES=*libref.data-table*","type":"dataSet"},{"name":"OUTMATCHLINKS=","optional":true,"description":"specifies the links output data table for matching subgraphs.","help":"OUTMATCHLINKS=*libref.data-table*","type":"dataSet"},{"name":"OUTMATCHNODES=","optional":true,"description":"specifies the nodes output data table for matching subgraph mappings.","help":"OUTMATCHNODES=*libref.data-table*","type":"dataSet"},{"name":"OUTQUERYLINKS=","optional":true,"description":"specifies the links query output data table to contain the generated queries.","help":"OUTQUERYLINKS=*libref.data-table*","type":"dataSet"},{"name":"OUTQUERYNODES=","optional":true,"description":"specifies the nodes query output data table to contain the generated queries.","help":"OUTQUERYNODES=*libref.data-table*","type":"dataSet"},{"name":"OUTSUMMARY=","optional":true,"description":"specifies the summary output data table for pattern match queries.","help":"OUTSUMMARY=*libref.data-table*","type":"dataSet"},{"name":"QUERYKEY=","optional":true,"description":"specifies the name of the data variable for the query key. The value of the variable can be numeric or character.","help":"QUERYKEY=*column*","type":"value"},{"name":"QUERYKEYAGGREGATE=","optional":true,"description":"specifies whether to aggregate nodes across query keys for creating the induced subgraph(s). By default, QUERYKEYAGGREGATE=TRUE.","help":"QUERYKEYAGGREGATE=TRUE | FALSE","type":"choice","arguments":[{"name":"TRUE","description":"aggregates nodes across query keys for creating the induced subgraph(s).","type":"standalone"},{"name":"FALSE","description":"does not aggregate nodes across query keys for creating the induced subgraphs(s).","type":"standalone"}]}]},{"name":"PROJECTION","description":"The PROJECTION statement invokes an algorithm that calculates the network projection of the multiple-partition input graph and produces a single-partition output graph.","help":"PROJECTION &lt;*options*&gt;;    ","arguments":[{"name":"ADAMICADAR=","optional":true,"description":"specifies whether to calculate Adamic-Adar node similarity. By default, ADAMICADAR=FALSE.","help":"ADAMICADAR=TRUE | FALSE","type":"choice","arguments":[{"name":"TRUE","description":"calculates Adamic-Adar node similarity and saves the results in the output table that is specified in the OUTPROJECTIONLINKS= option.","type":"standalone"},{"name":"FALSE","description":"does not calculate Adamic-Adar node similarity.","type":"standalone"}]},{"name":"COMMONNEIGHBORS=","optional":true,"description":"specifies whether to calculate common neighbors node similarity. By default, COMMONNEIGHBORS=FALSE.","help":"COMMONNEIGHBORS=TRUE | FALSE","type":"choice","arguments":[{"name":"TRUE","description":"calculates common neighbors node similarity and saves the results in the output table that is specified in the OUTPROJECTIONLINKS= option.","type":"standalone"},{"name":"FALSE","description":"does not calculate common neighbors node similarity.","type":"standalone"}]},{"name":"COSINE=","optional":true,"description":"specifies whether to calculate cosine node similarity. By default, COSINE=FALSE.","help":"COSINE=TRUE | FALSE","type":"choice","arguments":[{"name":"TRUE","description":"calculates cosine node similarity and saves the results in the output table that is specified in the OUTPROJECTIONLINKS= option.","type":"standalone"},{"name":"FALSE","description":"does not calculate cosine node similarity.","type":"standalone"}]},{"name":"DICE=","optional":true,"description":"specifies whether to calculate Dice node similarity. By default, DICE=FALSE.","help":"DICE=TRUE | FALSE","type":"choice","arguments":[{"name":"TRUE","description":"calculates Dice node similarity and saves the results in the output table that is specified in the OUTPROJECTIONLINKS= option.","type":"standalone"},{"name":"FALSE","description":"does not calculate Dice node similarity.","type":"standalone"}]},{"name":"DIRECTEDMETHOD=","optional":true,"description":"specifies the method to use for projection of directed graphs. This option can be used only for directed graphs. By default, DIRECTEDMETHOD=CONVERGING.","help":"DIRECTEDMETHOD=CONVERGING | DIVERGING | TRANSITIVE","type":"choice","arguments":[{"name":"CONVERGING","description":"uses shared out-neighbors to define projected links.","type":"standalone"},{"name":"DIVERGING","description":"uses shared in-neighbors to define projected links.","type":"standalone"},{"name":"TRANSITIVEs","description":"uses directed paths of length two to define projected links.","type":"standalone"}]},{"name":"JACCARD=","optional":true,"description":"specifies whether to calculate Jaccard node similarity. By default, JACCARD=FALSE.","help":"JACCARD=TRUE | FALSE","type":"choice","arguments":[{"name":"TRUE","description":"calculates Jaccard node similarity and saves the results in the output table that is specified in the OUTPROJECTIONLINKS= option.","type":"standalone"},{"name":"FALSE","description":"does not calculate Jaccard node similarity.","type":"standalone"}]},{"name":"OUTNEIGHBORSLIST=","optional":true,"description":"specifies the output data table to contain the lists of common neighbors between pairs of nodes.","help":"OUTNEIGHBORSLIST=*libref.data-table*","type":"dataSet"},{"name":"OUTPROJECTIONLINKS=","optional":true,"description":"specifies the output data table to contain the links of the projected graph.","help":"OUTPROJECTIONLINKS=*libref.data-table*","type":"dataSet"},{"name":"OUTPROJECTIONNODES=","optional":true,"description":"specifies the output data table to contain the nodes of the projected graph.","help":"OUTPROJECTIONNODES=*libref.data-table*","type":"dataSet"},{"name":"PARTITION=","optional":true,"description":"specifies the name of the data variable for the partition flag. The value of the variable must be 0, 1, or missing.","help":"PARTITION=*column*","type":"value"}]},{"name":"REACH","description":"The REACH statement invokes an algorithm that calculates the reach (ego) network in an input graph.","help":"REACH &lt;*options*&gt;;    ","arguments":[{"name":"DIGRAPH","optional":true,"description":"calculates the directed reach counts when computing the reach networks and includes the directed counts in the resulting output data table, which is specified in the OUTCOUNTS= option. This option requires MAXREACH=1.","type":"standalone"},{"name":"EACHSOURCE","optional":true,"description":"treats each node as a source and calculates a reach network from each one.","type":"standalone"},{"name":"MAXREACH=","optional":true,"description":"specifies the maximum number of hops from each source node in a reach network. By default, MAXREACH=1.","help":"MAXREACH=*number*","type":"value"},{"name":"OUTCOUNTS=","optional":true,"description":"specifies the output data table to contain the node counts in each reach network.","help":"OUTCOUNTS=*libref.data-table*","type":"dataSet"},{"name":"OUTREACHLINKS=","optional":true,"description":"specifies the output data table to contain the links in each reach network.","help":"OUTREACHLINKS=*libref.data-table*","type":"dataSet"},{"name":"OUTREACHNODES=","optional":true,"description":"specifies the output data table to contain the nodes in each reach network.","help":"OUTREACHNODES=*libref.data-table*","type":"dataSet"}]},{"name":"SHORTESTPATH","description":"The SHORTESTPATH statement invokes an algorithm that calculates shortest paths between pairs of nodes in the input graph. By default, PROC NETWORK finds a shortest path for each possible combination of source and sink nodes.","help":"SHORTESTPATH &lt;*options*&gt;;    ","arguments":[{"name":"MAXABSOLUTEOBJECTIVEGAP=","optional":true,"aliases":["MAXABSOBJGAP="],"description":"specifies an acceptance criterion for the sum of link weights (CandidatePath) in paths relative to the sum of link weights in the shortest path (ShortestPath). The default is the largest number that can be represented by a double. When the default is used, no paths are removed from the results.","help":"MAXABSOLUTEOBJECTIVEGAP=*number*","type":"value"},{"name":"MAXPATHWEIGHT=","optional":true,"aliases":["MAXLINKWEIGHT="],"description":"specifies the maximum path weight. The default is the largest number that can be represented by a double, which causes no paths to be removed from the results.","help":"MAXPATHWEIGHT=*number*","type":"value"},{"name":"MAXPATHSPERPAIR=","optional":true,"description":"specifies the maximum number of ranked paths to find for each source-sink pair. By default, MAXPATHSPERPAIR=1 and the algorithm finds one shortest path between each source-sink pair.","help":"MAXPATHSPERPAIR=*number*","type":"value"},{"name":"MAXRELATIVEOBJECTIVEGAP=","optional":true,"aliases":["MAXRELOBJGAP="],"description":"specifies an acceptance criterion for the sum of link weights (CandidatePath) in paths relative to the sum of link weights in the shortest path (ShortestPath). The default is the largest number that can be represented by a double. When the default is used, no paths are removed from the results.","help":"MAXRELATIVEOBJECTIVEGAP=*number*","type":"value"},{"name":"MINPATHWEIGHT=","optional":true,"aliases":["MINLINKWEIGHT="],"description":"specifies the minimum sum of link weights in a path. The default is the largest (in magnitude) negative number that can be represented by a double. When the default is used, no paths are removed from the results.","help":"MINPATHWEIGHT=*number*","type":"value"},{"name":"OUTPATHS=","optional":true,"aliases":["OUT=","OUTPATHSLINKS="],"description":"specifies the output data table to contain the shortest path links.","help":"OUTPATHS=*libref.data-table*","type":"dataSet"},{"name":"OUTPATHSNODES=","optional":true,"description":"specifies the output data table to contain the shortest path nodes.","help":"OUTPATHSNODES=*libref.data-table*","type":"dataSet"},{"name":"OUTSUMMARY=","optional":true,"description":"specifies the output data table to contain descriptive statistics of the finite shortest paths for each source.","help":"OUTSUMMARY=*libref.data-table*","type":"dataSet"},{"name":"OUTWEIGHTS=","optional":true,"description":"specifies the output data table to contain the total weight of the shortest path for each source-sink pair.","help":"OUTWEIGHTS=*libref.data-table*","type":"dataSet"},{"name":"SEQUENCE=","optional":true,"description":"specifies which data variable in the nodes subset table defines the sequence of nodes to visit.","help":"SEQUENCE=*column*","type":"value"},{"name":"SINK=","optional":true,"description":"specifies the sink node for shortest path calculations.","help":"SINK=*sink-node*","type":"value"},{"name":"SOURCE=","optional":true,"description":"specifies the source node for shortest path calculations.","help":"SOURCE=*source-node*","type":"value"}]},{"name":"SUMMARY","description":"The SUMMARY statement invokes an algorithm that calculates various summary metrics for an input graph.","help":"SUMMARY &lt;*options*&gt;;    ","arguments":[{"name":"ASSORTATIVITYDEGREE=","optional":true,"description":"calculates degree assortativity and specifies which type of calculation to perform.","help":"ASSORTATIVITYDEGREE=WEIGHT | UNWEIGHT | BOTH","type":"choice","arguments":[{"name":"WEIGHT","description":"calculates degree assortativity by using the weighted graph.","type":"standalone"},{"name":"UNWEIGHT","description":"calculates degree assortativity by using the unweighted graph.","type":"standalone"},{"name":"BOTH","description":"calculates degree assortativity by using both the weighted and unweighted graphs.","type":"standalone"}]},{"name":"ASSORTATIVITYNOMINAL=","optional":true,"description":"specifies the name of the data variable for computing the nominal assortativity.","help":"ASSORTATIVITYNOMINAL=*column*","type":"value"},{"name":"ASSORTATIVITYNUMERIC=","optional":true,"description":"specifies the name of the data variable for computing the numeric assortativity.","help":"ASSORTATIVITYNUMERIC=*column*","type":"value"},{"name":"BICONNECTEDCOMPONENTS","optional":true,"description":"calculates information about biconnected components. You can use this option only for an undirected graph.","type":"standalone"},{"name":"CLUSTERINGCOEFFICIENT","optional":true,"aliases":["CLUSTERINGCOEF"],"description":"calculates information about clustering coefficients. You can use this option only for an undirected graph.","type":"standalone"},{"name":"CONNECTEDCOMPONENTS","optional":true,"description":"calculates information about connected components.","type":"standalone"},{"name":"DIAMETERAPPROX=","optional":true,"description":"calculates information about the approximate diameter and specifies which type of calculation to perform.","help":"DIAMETERAPPROX=WEIGHT | UNWEIGHT | BOTH","type":"choice","arguments":[{"name":"WEIGHT","description":"calculates the approximate diameter by using the weighted graph.","type":"standalone"},{"name":"UNWEIGHT","description":"calculates the approximate diameter by using the unweighted graph.","type":"standalone"},{"name":"BOTH","description":"calculates the approximate diameter by using both the weighted and unweighted graphs.","type":"standalone"}]},{"name":"FINITEPATH","optional":true,"description":"includes only finite values when calculating descriptive statistics that are related to shortest paths (eccentricity, diameter, and so on).","type":"standalone"},{"name":"OUT=","optional":true,"description":"specifies the output data table to contain the summary results.","help":"OUT=*libref.data-table*","type":"dataSet"},{"name":"SHORTESTPATH=","optional":true,"description":"calculates information about shortest paths and specifies which type of calculation to perform.","help":"SHORTESTPATH=WEIGHT | UNWEIGHT | BOTH","type":"choice","arguments":[{"name":"WEIGHT","description":"calculates shortest paths by using the weighted graph.","type":"standalone"},{"name":"UNWEIGHT","description":"calculates shortest paths by using the unweighted graph.","type":"standalone"},{"name":"BOTH","description":"calculates shortest paths by using both the weighted and unweighted graphs.","type":"standalone"}]}]},{"name":"TOPOLOGICALSORT","description":"The TOPOLOGICALSORT statement calculates a topological ordering of the nodes of a directed acyclic input graph.","help":"TOPOLOGICALSORT ;    "},{"name":"TRANSITIVECLOSURE","description":"The TRANSITIVECLOSURE statement invokes an algorithm that calculates the transitive closure of an input graph.","help":"TRANSITIVECLOSURE &lt;*option*&gt;;    ","arguments":[{"name":"OUT=","optional":true,"description":"specifies the output data table to contain the transitive closure results.","help":"OUT=*libref.data-table*","type":"dataSet"}]},{"name":"UNLOADGRAPH","description":"The UNLOADGRAPH statement deletes the in-memory graph that is specified in the GRAPH= option in the PROC NETWORK statement.","help":"UNLOADGRAPH ;    "}],"supportSiteInformation":{"docsetId":"casmlnetwork","docsetVersion":"v_018","docsetTargetFile":"casmlnetwork_network_toc.htm"}}