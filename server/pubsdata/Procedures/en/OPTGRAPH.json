{"name":"OPTGRAPH","statements":[{"name":"PROC OPTGRAPH","description":"The OPTGRAPH procedure can be used to analyze relationships between entities. These relationships are typically defined by using a graph. A graph, G = (N,A), is defined over a set N of nodes and a set A of arcs. A node is an abstract representation of some entity (or object), and an arc defines some relationship (or connection) between two nodes. The terms node and vertex are often interchanged when describing an entity. The term arc is often interchanged with the term edge or link when describing a connection. † The OPTGRAPH procedure in SAS High-Performance Network Algorithms enables you to perform community detection and centrality computations on large graphs in a high-performance environment. It uses an appliance that houses a massively parallel database management system (Teradata or EMC Greenplum) to manage data in distributed form and to perform computations in parallel on an x64 Linux platform. A computing appliance is a dedicated hardware and software environment that acts as a server to provide computing resources in a client/server model. You connect indirectly to the appliance through the network connection between the client machine and the appliance. Software instructions on the client machine are translated into commands that are run on the appliance.","help":"PROC OPTGRAPH <DATA_ADJ_MATRIX=SAS-data-set | ADJ_MATRIX=SAS-data-set><DATA_LINKS=SAS-data-set | LINKS=SAS-data-set><DATA_MATRIX=SAS-data-set | MATRIX=SAS-data-set><DATA_NODES=SAS-data-set | NODES=SAS-data-set><DATA_NODES_SUB=SAS-data-set | NODES_SUB=SAS-data-set><FILTER_SUBGRAPH=num><GRAPH_DIRECTION=DIRECTED | UNDIRECTED><GRAPH_INTERNAL_FORMAT=THIN | FULL><INCLUDE_SELFLINK><LOGLEVEL=NONE|0 | BASIC|1 | MODERATE|2... ><OUT_LINKS=SAS-data-set><OUT_NODES=SAS-data-set><TIMETYPE=CPU | REAL>;     \n\tBICONCOMP <LOGLEVEL=<NONE|0 | BASIC|1 | MODERATE|2>... ><NODE=column><WEIGHT=column> ...;\n\tCENTRALITY <AUTH=<WEIGHT | UNWEIGHT | BOTH>><BETWEEN=<WEIGHT | UNWEIGHT | BOTH>><BETWEEN_NORM=<YES | NO>> ...;\n\tCLIQUE <LOGLEVEL=<NONE|0 | BASIC|1 | MODERATE|2>... ><MAXCLIQUES=num><MAXTIME=num> ...;\n\tCOMMUNITY <ALGORITHM=<PARALLEL_LABEL_PROP>><LOGLEVEL=<NONE|0 | BASIC|1 | MODERATE|2>... ><MAXITER=num> ...;\n\tCONCOMP <ALGORITHM=<DFS | UNION_FIND>><LOGLEVEL=<NONE|0 | BASIC|1 | MODERATE|2>... > ;\n\tCORE <LINKS=<IN | OUT | BOTH>><LOGLEVEL=<NONE|0 | BASIC|1 | MODERATE|2>... > ;\n\tCYCLE <LOGLEVEL=<NONE|0 | BASIC|1 | MODERATE|2>... ><MAXCYCLES=num><MAXLENGTH=num> ...;\n\tDATA_ADJ_MATRIX_VAR column1 <,column2,...> ;\n\tDATA_LINKS_VAR <FROM=column><LOWER=column><TO=column> ...;\n\tDATA_MATRIX_VAR column1 <,column2,...> ;\n\tDATA_NODES_VAR <CLUSTER=column><NODE=column><WEIGHT=column> ...;\n\tEIGENVECTOR <ALGORITHM=<ARPACK | POWER>><LOGLEVEL=<NONE|0 | BASIC|1 | MODERATE|2>... ><MAXITER=num> ...;\n\tLINEAR_ASSIGNMENT <ID=(column1 <,column2,...>)><LOGLEVEL=<NONE|0 | BASIC|1 | MODERATE|2>... ><MAXTIME=num> ...;\n\tMINCUT <LOGLEVEL=<NONE|0 | BASIC|1 | MODERATE|2>... ><MAXNUMCUTS=num><MAXWEIGHT=num> ...;\n\tMINSPANTREE <LOGLEVEL=<NONE|0 | BASIC|1 | MODERATE|2>... ><OUT=SAS-data-set> ;\n\tNETFLOW_MINCOST <LOGFREQ=num><LOGLEVEL=<NONE|0 | BASIC|1 | MODERATE|2>... ><MAXTIME=option> ...;\n\tPERFORMANCE <COMMIT=n><CPUCOUNT=<ACTUAL | <num>>><DATASERVER=“name”> ...;\n\tREACH <BY_CLUSTER><DIGRAPH><EACH_SOURCE> ...;\n\tSHORTPATH <LOGFREQNODE=num><LOGLEVEL=<NONE|0 | BASIC|1 | MODERATE|2>... ><OUT_PATHS | OUT==SAS-data-set> ...;\n\tSUMMARY <BICONCOMP><BY_CLUSTER><CONCOMP> ...;\n\tTRANSITIVE_CLOSURE <LOGLEVEL=<NONE|0 | BASIC|1 | MODERATE|2>... ><OUT=SAS-data-set> ;\n\tTSP <ABSOBJGAP=num><CUTOFF=num><CUTSTRATEGY=<AUTOMATIC|-1 | NONE|0 | MODERATE|1>... > ...;","arguments":[{"name":"DATA_ADJ_MATRIX=","optional":true,"aliases":["ADJ_MATRIX="],"description":"Specifies the input data set that contains the graph link information, where the links are defined as an adjacency matrix.","type":"value"},{"name":"DATA_LINKS=","optional":true,"aliases":["LINKS="],"description":"Specifies the input data set that contains the graph link information, where the links are defined as a list.","type":"value"},{"name":"DATA_MATRIX=","optional":true,"aliases":["MATRIX="],"description":"Specifies the input data set that contains the matrix to be processed. This is a generic matrix (as opposed to an adjacency matrix which defines an underlying graph).","type":"value"},{"name":"DATA_NODES=","optional":true,"aliases":["NODES="],"description":"Specifies the input data set that contains the graph node information.","type":"value"},{"name":"DATA_NODES_SUB=","optional":true,"aliases":["NODES_SUB="],"description":"Specifies the input data set that contains the graph node subset information.","type":"value"},{"name":"FILTER_SUBGRAPH=","optional":true,"description":"Specifies the minimum number of nodes allowed in a subgraph when processing is decomposed by cluster. When the BY_CLUSTER option is also specified in another statement, any subgraph whose number of nodes is less than or equal to num is skipped. The default setting is 0, so nothing is filtered by default.","help":"FILTER_SUBGRAPH=*num*","type":"value"},{"name":"GRAPH_DIRECTION=","optional":true,"aliases":["DIRECTION="],"description":"Syntax: GRAPH_DIRECTION=DIRECTED | UNDIRECTED DIRECTION=DIRECTED | UNDIRECTED","help":"GRAPH_DIRECTION=DIRECTED | UNDIRECTED","type":"choice","arguments":[{"name":"DIRECTED","description":"Specifies the graph as directed.","type":"standalone"},{"name":"UNDIRECTED","description":"Specifies the graph as undirected.","type":"standalone"}]},{"name":"GRAPH_INTERNAL_FORMAT=","optional":true,"aliases":["INTERNAL_FORMAT="],"description":"Syntax: GRAPH_INTERNAL_FORMAT=THIN | FULL INTERNAL_FORMAT=THIN | FULL","help":"GRAPH_INTERNAL_FORMAT=THIN | FULL","type":"choice","arguments":[{"name":"THIN","description":"Stores the graph in thin format. This option can improve performance in some cases both by reducing memory and by simplifying the construction of the internal data structures. The thin format causes PROC OPTGRAPH to skip the removal of duplicate links when it reads in the graph. So this option should be used with caution. For some algorithms, the thin format is not allowed and this option is ignored. The THIN option can often be helpful when you do calculations that are decomposed by subgraph.","type":"standalone"},{"name":"FULL","description":"Stores the graph in standard (full) format. This is the default.","type":"standalone"}]},{"name":"INCLUDE_SELFLINK","optional":true,"description":"Includes self links—for example, —when an input graph is read. By default, when PROC OPTGRAPH reads the DATA_LINKS= data set, it removes all self links.","type":"standalone"},{"name":"LOGLEVEL=","optional":true,"description":"Controls the amount of information that is displayed in the SAS log. Each algorithm has its own specific log level. This setting sets the log level for all algorithms except those for which you specify the LOGLEVEL= option in the algorithm statement.","help":"LOGLEVEL=NONE | BASIC | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"NONE","aliases":["0"],"description":"Turns off all procedure-related messages in the SAS log","type":"standalone"},{"name":"BASIC","aliases":["1"],"description":"Displays a basic summary of the input, output, and algorithmic processing","type":"standalone"},{"name":"MODERATE","aliases":["2"],"description":"Displays a summary of the input, output, and algorithmic processing","type":"standalone"},{"name":"AGGRESSIVE","aliases":["3"],"description":"Displays a detailed summary of the input, output, and algorithmic processing","type":"standalone"}]},{"name":"OUT_LINKS=","optional":true,"description":"Specifies the output data set to contain the graph link information along with any results from the various algorithms that calculate metrics on links.","help":"OUT_LINKS=*SAS-data-set*","type":"dataSet"},{"name":"OUT_NODES=","optional":true,"description":"Specifies the output data set to contain the graph node information along with any results from the various algorithms that calculate metrics on nodes.","help":"OUT_NODES=*SAS-data-set*","type":"dataSet"},{"name":"TIMETYPE=","optional":true,"description":"Specifies whether CPU time or real time is used for the MAXTIME= option for each applicable algorithm.","help":"TIMETYPE=CPU | REAL","type":"choice","arguments":[{"name":"CPU","description":"Specifies units of CPU time","type":"standalone"},{"name":"REAL","description":"Specifies units of real time","type":"standalone"}]}]},{"name":"BICONCOMP","description":"The BICONCOMP statement requests that PROC OPTGRAPH find biconnected components and articulation points of an undirected input graph.","help":"BICONCOMP &lt;LOGLEVEL=&lt;NONE|0 | BASIC|1 | MODERATE|2&gt;... &gt;&lt;NODE=column&gt;&lt;WEIGHT=column&gt; ...","arguments":[{"name":"LOGLEVEL=","optional":true,"description":"Controls the amount of information that is displayed in the SAS log.","help":"LOGLEVEL=NONE | BASIC | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"NONE","aliases":["0"],"description":"Turns off all algorithm-related messages in the SAS log","type":"standalone"},{"name":"BASIC","aliases":["1"],"description":"Displays a basic summary of the algorithmic processing","type":"standalone"},{"name":"MODERATE","aliases":["2"],"description":"Displays a summary of the algorithmic processing","type":"standalone"},{"name":"AGGRESSIVE","aliases":["3"],"description":"Displays a detailed summary of the algorithmic processing","type":"standalone"}]},{"name":"NODE=","optional":true,"description":"Specifies the data set variable name for the nodes. The value of column can be numeric or character.","help":"NODE=*column*","type":"value"},{"name":"WEIGHT2=","optional":true,"description":"Specifies the data set variable name for auxiliary node weights. The value of column must be numeric.","help":"WEIGHT2=*column*","type":"value"},{"name":"WEIGHT=","optional":true,"description":"Specifies the data set variable name for node weights. The value of column must be numeric.","help":"WEIGHT=*column*","type":"value"}]},{"name":"CENTRALITY","description":"The CENTRALITY statement enables you to select which centrality metrics to calculate for the given input graph. It also enables you to specify options for particular metrics. The resulting metrics are included in the node output data set (specified by the OUT_NODES= option) or the link output data set (specified by the OUT_LINKS= option).","help":"CENTRALITY &lt;AUTH=&lt;WEIGHT | UNWEIGHT | BOTH&gt;&gt;&lt;BETWEEN=&lt;WEIGHT | UNWEIGHT | BOTH&gt;&gt;&lt;BETWEEN_NORM=&lt;YES | NO&gt;&gt; ...","arguments":[{"name":"AUTH=","optional":true,"description":"Specifies which type of authority centrality to calculate.","help":"AUTH=WEIGHT | UNWEIGHT | BOTH","type":"choice","arguments":[{"name":"WEIGHT","description":"Calculates authority centrality based on the weighted graph.","type":"standalone"},{"name":"UNWEIGHT","description":"Calculates authority centrality based on the unweighted graph.","type":"standalone"},{"name":"BOTH","description":"Calculates authority centrality based on both weighted and unweighted graphs.","type":"standalone"}]},{"name":"BETWEEN=","optional":true,"description":"Specifies which type of betweenness centrality to calculate.","help":"BETWEEN=WEIGHT | UNWEIGHT | BOTH","type":"choice","arguments":[{"name":"WEIGHT","description":"Calculates betweenness centrality based on the weighted graph.","type":"standalone"},{"name":"UNWEIGHT","description":"Calculates betweenness centrality based on the unweighted graph.","type":"standalone"},{"name":"BOTH","description":"Calculates betweenness centrality based on both weighted and unweighted graphs.","type":"standalone"}]},{"name":"BETWEEN_NORM=","optional":true,"description":"Specifies whether to normalize the betweenness centrality metrics.","help":"BETWEEN_NORM=YES | NO","type":"choice","arguments":[{"name":"YES","description":"Normalizes the betweenness metrics. This is the default.","type":"standalone"},{"name":"NO","description":"Does not normalize the betweenness metrics.","type":"standalone"}]},{"name":"BY_CLUSTER","optional":true,"description":"Decomposes the calculations by cluster (or subgraph). If this option is specified, PROC OPTGRAPH looks for a definition of the clusters in the input data set specified by the DATA_NODES= option in the PROC OPTGRAPH statement. The use of the BY_CLUSTER option is described in the section Processing by Cluster.","type":"standalone"},{"name":"CLOSE=","optional":true,"description":"Specifies which type of closeness centrality to calculate.","help":"CLOSE=WEIGHT | UNWEIGHT | BOTH","type":"choice","arguments":[{"name":"WEIGHT","description":"Calculates closeness centrality based on the weighted graph.","type":"standalone"},{"name":"UNWEIGHT","description":"Calculates closeness centrality based on the unweighted graph.","type":"standalone"},{"name":"BOTH","description":"Calculates closeness centrality based on both weighted and unweighted graphs.","type":"standalone"}]},{"name":"CLOSE_NOPATH=","optional":true,"description":"Specifies a method for accounting for a shortest path between two nodes when a path does not exist (disconnected nodes).","help":"CLOSE_NOPATH=NNODES | DIAMETER | ZERO","type":"choice","arguments":[{"name":"NNODES","description":"Uses the number of nodes as a shortest path between disconnected nodes. This is the default.","type":"standalone"},{"name":"DIAMETER","description":"Uses the graph diameter as a shortest path between disconnected nodes.","type":"standalone"},{"name":"ZERO","description":"Uses zero as a shortest path between disconnected nodes.","type":"standalone"}]},{"name":"CLUSTERING_COEF","optional":true,"description":"Calculates the node clustering coefficient.","type":"standalone"},{"name":"DEGREE=","optional":true,"description":"Specifies which type of degree centrality to calculate for the input graph.","help":"DEGREE=IN | OUT | BOTH","type":"choice","arguments":[{"name":"IN","description":"Calculates degree based on in-links.","type":"standalone"},{"name":"OUT","description":"Calculates degree based on out-links.","type":"standalone"},{"name":"BOTH","description":"Calculates degree based on in-links and out-links.","type":"standalone"}]},{"name":"EIGEN=","optional":true,"description":"Specifies which type of eigenvector centrality to calculate.","help":"EIGEN=WEIGHT | UNWEIGHT | BOTH","type":"choice","arguments":[{"name":"WEIGHT","description":"Calculates eigenvector centrality based on the weighted graph.","type":"standalone"},{"name":"UNWEIGHT","description":"Calculates centrality based on the unweighted graph.","type":"standalone"},{"name":"BOTH","description":"Calculates centrality based on both weighted and unweighted graphs.","type":"standalone"}]},{"name":"EIGEN_ALGORITHM=","optional":true,"description":"Specifies the algorithm to use in calculating the eigenvector centrality.","help":"EIGEN_ALGORITHM=ARPACK | POWER","type":"choice","arguments":[{"name":"ARPACK","description":"Uses ARPACK to calculate eigenvector centrality. This is the default.","type":"standalone"},{"name":"POWER","description":"Uses the power method to calculate eigenvector centrality.","type":"standalone"}]},{"name":"EIGEN_MAXITER=","optional":true,"description":"Specifies the maximum number of iterations to use for eigenvector calculations to limit the amount of computation time spent when convergence is slow. The default is 5,000.","help":"EIGEN_MAXITER=*num*","type":"value"},{"name":"HUB=","optional":true,"description":"Specifies which type of hub centrality to calculate.","help":"HUB=WEIGHT | UNWEIGHT | BOTH","type":"choice","arguments":[{"name":"WEIGHT","description":"Calculates hub centrality based on the weighted graph.","type":"standalone"},{"name":"UNWEIGHT","description":"Calculates hub centrality based on the unweighted graph.","type":"standalone"},{"name":"BOTH","description":"Calculates hub centrality based on both weighted and unweighted graphs.","type":"standalone"}]},{"name":"INFLUENCE=","optional":true,"description":"Specifies which type of influence centrality to calculate.","help":"INFLUENCE=WEIGHT | UNWEIGHT | BOTH","type":"choice","arguments":[{"name":"WEIGHT","description":"Calculates influence centrality based on the weighted graph.","type":"standalone"},{"name":"UNWEIGHT","description":"Calculates influence centrality based on the unweighted graph.","type":"standalone"},{"name":"BOTH","description":"Calculates influence centrality based on both weighted and unweighted graphs.","type":"standalone"}]},{"name":"LOGFREQNODE=","optional":true,"description":"Controls the frequency for displaying iteration logs for some of the centrality metrics. For computationally intensive algorithms such as betweenness and closeness centrality, this option displays progress every num nodes. If you also specify the BY_CLUSTER option in this statement or a value greater than 1 for the NTHREADS= option in the PERFORMANCE statement, this option is ignored and the display frequency is determined by using the LOGFREQTIME= option instead. The value of num can be any integer greater than or equal to 1; the default is determined automatically based on the size of the graph. Setting this value too low can hurt performance on large-scale graphs.","help":"LOGFREQNODE=*num*","type":"value"},{"name":"LOGFREQTIME=","optional":true,"description":"Controls the frequency for displaying iteration logs for some of the centrality metrics. For computationally intensive algorithms such as betweenness and closeness centrality, this option displays progress every num seconds. If you specify a value greater than 1 for the NTHREADS= option in the PERFORMANCE statement, PROC OPTGRAPH displays the number of nodes that have completed. If you specify the BY_CLUSTER option, PROC OPTGRAPH displays the number of subgraphs that have completed. The value of num can be any integer greater than or equal to 1; the default is 5. Setting this value too low can hurt performance on large-scale graphs.","help":"LOGFREQTIME=*num*","type":"value"},{"name":"LOGLEVEL=","optional":true,"description":"Controls the amount of information that is displayed in the SAS log.","help":"LOGLEVEL=NONE | BASIC | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"NONE","aliases":["0"],"description":"Turns off all algorithm-related messages in the SAS log.","type":"standalone"},{"name":"BASIC","aliases":["1"],"description":"Displays a basic summary of the algorithmic processing.","type":"standalone"},{"name":"MODERATE","aliases":["2"],"description":"Displays a summary of the algorithmic processing including a progress log using the interval dictated by the LOGFREQNODE= or LOGFREQTIME= option.","type":"standalone"},{"name":"AGGRESSIVE","aliases":["3"],"description":"Displays a detailed summary of the algorithmic processing including a progress log using the interval dictated by the LOGFREQNODE= or LOGFREQTIME= option","type":"standalone"}]},{"name":"PAGERANK=","optional":true,"description":"Specifies which type of graph to base PageRank calculation on.","help":"PAGERANK=WEIGHT | UNWEIGHT | BOTH","type":"choice","arguments":[{"name":"WEIGHT","description":"Calculates PageRank based on the weighted graph.","type":"standalone"},{"name":"UNWEIGHT","description":"Calculates PageRank based on the unweighted graph.","type":"standalone"},{"name":"BOTH","description":"Calculates PageRank based on both weighted and unweighted graphs.","type":"standalone"}]},{"name":"PAGERANK_ALPHA=","optional":true,"description":"Specifies the damping factor to be used in the PageRank algorithm. The value must be between 0 and 1 (inclusive). The default is 0.85, which means a random Web surfer has a 15% chance of jumping to any other node in the network at any time. The algorithm usually takes more iterations to converge (or does not converge at all) as the damping factor is set closer to 1.","help":"PAGERANK_ALPHA=*num*","type":"value"},{"name":"PAGERANK_TOL=","optional":true,"description":"Specifies the convergence tolerance value for the PageRank algorithm. The value must be a positive number; the default value is 1E–9. The algorithm stops power iterations when the gap between the PageRank scores of the current iteration and the previous iteration is less than or equal to num.","help":"PAGERANK_TOL=*num*","type":"value"},{"name":"SUBSIZESWITCH=","optional":true,"description":"Specifies how many subgraph nodes to run separately when you also specify the BY_CLUSTER option in this statement and a value greater than 1 for the NTHREADS= option in the PERFORMANCE statement. When PROC OPTGRAPH processes centrality by subgraphs, it uses thread logic to simultaneously process a number of subgraphs, with that number as specified in the NTHREADS= option in the PERFORMANCE statement. For a larger graph with a number of nodes greater than num, each subgraph is processed sequentially, allowing the threading to be done at the centrality metric level. The default value is 10,000.","help":"SUBSIZESWITCH=*num*","type":"value"},{"name":"WEIGHT2=","optional":true,"description":"Specifies the data set variable name for a second link weight. The value of column must be numeric.","help":"WEIGHT2=*column*","type":"value"}]},{"name":"CLIQUE","description":"The CLIQUE statement invokes an algorithm that finds maximal cliques on the input graph.","help":"CLIQUE &lt;LOGLEVEL=&lt;NONE|0 | BASIC|1 | MODERATE|2&gt;... &gt;&lt;MAXCLIQUES=num&gt;&lt;MAXTIME=num&gt; ...","arguments":[{"name":"LOGLEVEL=","optional":true,"description":"Controls the amount of information that is displayed in the SAS log.","help":"LOGLEVEL=NONE | BASIC | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"NONE","aliases":["0"],"description":"Turns off all algorithm-related messages in the SAS log","type":"standalone"},{"name":"BASIC","aliases":["1"],"description":"Displays a basic summary of the algorithmic processing","type":"standalone"},{"name":"MODERATE","aliases":["2"],"description":"Displays a summary of the algorithmic processing","type":"standalone"},{"name":"AGGRESSIVE","aliases":["3"],"description":"Displays a detailed summary of the algorithmic processing","type":"standalone"}]},{"name":"MAXCLIQUES=","optional":true,"description":"Specifies the maximum number of cliques to return during clique calculations. The default is the positive number that has the largest absolute value that can be represented in your operating environment.","help":"MAXCLIQUES=*num*","type":"value"},{"name":"MAXTIME=","optional":true,"description":"Specifies the maximum amount of time to spend calculating cliques. The type of time (either CPU time or real time) is determined by the value of the TIMETYPE= option. The value of num can be any positive number; the default value is the positive number that has the largest absolute value that can be represented in your operating environment.","help":"MAXTIME=*num*","type":"value"},{"name":"OUT=","optional":true,"description":"Specifies the output data set to contain the maximal cliques.","help":"OUT=*SAS-data-set*","type":"dataSet"}]},{"name":"COMMUNITY","description":"The COMMUNITY statement invokes an algorithm that detects communities of the input graph.","help":"COMMUNITY &lt;ALGORITHM=&lt;PARALLEL_LABEL_PROP&gt;&gt;&lt;LOGLEVEL=&lt;NONE|0 | BASIC|1 | MODERATE|2&gt;... &gt;&lt;MAXITER=num&gt; ...","arguments":[{"name":"ALGORITHM=","optional":true,"description":"Specifies which algorithm to use. Currently, only the parallel label propagation algorithm (PARALLEL_ LABEL_PROP) is supported in MPP mode..","help":"ALGORITHM=PARALLEL_LABEL_PROP*PARALLEL_LABEL_PROP*","type":"value","arguments":[{"name":"PARALLEL_LABEL_PROP","description":"Specifies to use the parallel label propagation algorithm.","type":"standalone"}]},{"name":"LOGLEVEL=","optional":true,"description":"Controls the amount of information that is displayed in the SAS log.","help":"LOGLEVEL=NONE | BASIC | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"NONE","aliases":["0"],"description":"Turns off all algorithm-related messages in the SAS log","type":"standalone"},{"name":"BASIC","aliases":["1"],"description":"Displays a basic summary of the algorithmic processing","type":"standalone"},{"name":"MODERATE","aliases":["2"],"description":"Displays a summary of the algorithmic processing","type":"standalone"},{"name":"AGGRESSIVE","aliases":["3"],"description":"Displays a detailed summary of the algorithmic processing","type":"standalone"}]},{"name":"MAXITER=","optional":true,"description":"Specifies the maximum number of iterations allowed in the algorithm. The default is 20 when ALGORITHM=LOUVAIN and 100 when ALGORITHM=LABEL_PROP or ALGORITHM=PARALLEL_LABEL_PROP.","help":"MAXITER=*num*","type":"value"},{"name":"OUT_COMMUNITY=","optional":true,"description":"Specifies the output data set to contain the number of nodes in each community.","help":"OUT_COMMUNITY=*SAS-data-set*","type":"dataSet"},{"name":"OUT_COMM_LINKS=","optional":true,"description":"Specifies the output data set that describes the links between communities. This data set is not created when you specify ALGORITHM=PARALLEL_LABEL_PROP and you are running PROC OPTGRAPH in a distributed computing environment.","help":"OUT_COMM_LINKS=*SAS-data-set*","type":"dataSet"},{"name":"OUT_INTRA_COMM_LINKS=","optional":true,"description":"Specifies the output data set that describes the links within each community.","help":"OUT_INTRA_COMM_LINKS=*SAS-data-set*","type":"dataSet"},{"name":"OUT_LEVEL=","optional":true,"description":"Specifies the output data set to contain community information at different resolution levels.","help":"OUT_LEVEL=*SAS-data-set*","type":"dataSet"},{"name":"OUT_OVERLAP=","optional":true,"description":"Specifies the output data set that describes the intensity of each node that belongs to multiple communities. This data set is not created when you specify ALGORITHM=PARALLEL_LABEL_PROP and you are running PROC OPTGRAPH in a distributed computing environment.","help":"OUT_OVERLAP=*SAS-data-set*","type":"dataSet"},{"name":"RANDOM_FACTOR=","optional":true,"description":"Specifies the random factor for the parallel label propagation algorithm. At each iteration, some nodes are randomly selected to skip the label propagation step based on the specified RANDOM_FACTOR value. The default is 0.15, meaning 15% of nodes will skip the label propagation step at each iteration.","help":"RANDOM_FACTOR=*num*","type":"value"},{"name":"RANDOM_SEED=","optional":true,"description":"Specifies the initial seed for random number generation used in the parallel label propagation algorithm. At each iteration, some nodes are randomly selected to skip the label propagation step based on the value that you specify in the RANDOM_FACTOR= option. To change the sequence of random numbers generated by changing the initial seed, specify a number in the RANDOM_SEED= option. The default is 1234.","help":"RANDOM_SEED=*number*","type":"value"},{"name":"RECURSIVE=","optional":true,"description":"Requests that the algorithm recursively break down large communities into smaller ones until all communities have a size that is less than or equal to number. This option starts with the keyword RECURSIVE, followed by the MAX_COMM_SIZE= suboption enclosed in parentheses—for example, RECURSIVE (MAX_COMM_SIZE=200). MAX_COMM_SIZE= specifies the maximum number of nodes to be contained in any community.","help":"RECURSIVE=MAX_COMM_SIZE=","type":"choice","arguments":[{"name":"MAX_COMM_SIZE=","type":"value"}]},{"name":"RESOLUTION_LIST","optional":true,"description":"Specifies a list of resolution parameters that are separated by spaces (for example, 4.3 2.1 1.0 0.6 0.2). The OPTGRAPH procedure interprets the RESOLUTION_LIST= option differently depending on the value of the ALGORITHM= option.","type":"standalone"},{"name":"TOLERANCE=","optional":true,"description":"Stops iterations when the percentage of label changes for all nodes in the graph falls within the tolerance specified by number. The valid range is between 0 and 1. The default is 0.01.","help":"TOLERANCE=*num*","type":"value"}]},{"name":"CONCOMP","description":"The CONCOMP statement invokes an algorithm that finds the connected components of the input graph.","help":"CONCOMP &lt;ALGORITHM=&lt;DFS | UNION_FIND&gt;&gt;&lt;LOGLEVEL=&lt;NONE|0 | BASIC|1 | MODERATE|2&gt;... &gt;","arguments":[{"name":"ALGORITHM=","optional":true,"description":"Specifies the algorithm to use for calculating connected components.","help":"ALGORITHM=DFS | UNION_FIND","type":"choice","arguments":[{"name":"DFS","description":"Uses the depth-first search algorithm for connected components. This value cannot be used when you specify GRAPH_INTERNAL_FORMAT=THIN in the PROC OPTGRAPH statement.","type":"standalone"},{"name":"UNION_FIND","description":"Uses the union-find algorithm for connected components. You can specify this value with either the THIN or FULL value for the GRAPH_INTERNAL_FORMAT option in the PROC OPTGRAPH statement. This value can be faster than DFS when used with GRAPH_INTERNAL_FORMAT=THIN; however, you can use it only with undirected graphs.","type":"standalone"}]},{"name":"LOGLEVEL=","optional":true,"description":"Controls the amount of information that is displayed in the SAS log.","help":"LOGLEVEL=NONE | BASIC | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"NONE","aliases":["0"],"description":"Turns off all algorithm-related messages in the SAS log","type":"standalone"},{"name":"BASIC","aliases":["1"],"description":"Displays a basic summary of the algorithmic processing","type":"standalone"},{"name":"MODERATE","aliases":["2"],"description":"Displays a summary of the algorithmic processing","type":"standalone"},{"name":"AGGRESSIVE","aliases":["3"],"description":"Displays a detailed summary of the algorithmic processing","type":"standalone"}]}]},{"name":"CORE","description":"The CORE statement invokes an algorithm that finds the core decomposition of the input graph.","help":"CORE &lt;LINKS=&lt;IN | OUT | BOTH&gt;&gt;&lt;LOGLEVEL=&lt;NONE|0 | BASIC|1 | MODERATE|2&gt;... &gt;","arguments":[{"name":"LINKS=","optional":true,"description":"Specifies which type of cores to calculate for a directed graph. You can choose to calculate the cores based on in-links (IN), out-links (OUT), or both (BOTH). For an undirected graph, core applies only to out-links.","help":"LINKS=IN | OUT | BOTH","type":"choice","arguments":[{"name":"IN","description":"Specifies to calculate the cores based on in-links.","type":"standalone"},{"name":"OUT","description":"Specifies to calculate the cores based on out-links.","type":"standalone"},{"name":"BOTH","description":"Specifies to calculate the cores based on both in-links and out-links.","type":"standalone"}]},{"name":"LOGLEVEL=","optional":true,"description":"Controls the amount of information that is displayed in the SAS log.","help":"LOGLEVEL=NONE | BASIC | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"NONE","aliases":["0"],"description":"Turns off all algorithm-related messages in the SAS log","type":"standalone"},{"name":"BASIC","aliases":["1"],"description":"Displays a basic summary of the algorithmic processing","type":"standalone"},{"name":"MODERATE","aliases":["2"],"description":"Displays a summary of the algorithmic processing","type":"standalone"},{"name":"AGGRESSIVE","aliases":["3"],"description":"Displays a detailed summary of the algorithmic processing","type":"standalone"}]}]},{"name":"CYCLE","description":"The CYCLE statement invokes an algorithm that finds the cycles (or the existence of a cycle) in the input graph.","help":"CYCLE &lt;LOGLEVEL=&lt;NONE|0 | BASIC|1 | MODERATE|2&gt;... &gt;&lt;MAXCYCLES=num&gt;&lt;MAXLENGTH=num&gt; ...","arguments":[{"name":"LOGLEVEL=","optional":true,"description":"Controls the amount of information that is displayed in the SAS log.","help":"LOGLEVEL=NONE | BASIC | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"NONE","aliases":["0"],"description":"Turns off all algorithm-related messages in the SAS log","type":"standalone"},{"name":"BASIC","aliases":["1"],"description":"Displays a basic summary of the algorithmic processing","type":"standalone"},{"name":"MODERATE","aliases":["2"],"description":"Displays a summary of the algorithmic processing","type":"standalone"},{"name":"AGGRESSIVE","aliases":["3"],"description":"Displays a detailed summary of the algorithmic processing","type":"standalone"}]},{"name":"MAXCYCLES=","optional":true,"description":"Specifies the maximum number of cycles to return. The default is the positive number that has the largest absolute value representable in your operating environment. This option works only when you also specify MODE=ALL_CYCLES.","help":"MAXCYCLES=*num*","type":"value"},{"name":"MAXLENGTH=","optional":true,"description":"Specifies the maximum number of links to allow in a cycle. If a cycle is found whose length is greater than num, that cycle is removed from the results. The default is the positive number that has the largest absolute value representable in your operating environment. By default, nothing is filtered. This option works only when you also specify MODE=ALL_CYCLES.","help":"MAXLENGTH=*num*","type":"value"},{"name":"MAXLINKWEIGHT=","optional":true,"description":"Specifies the maximum sum of link weights to allow in a cycle. If a cycle is found whose sum of link weights is greater than num, that cycle is removed from the results. The default is the positive number that has the largest absolute value representable in your operating environment. By default, nothing is filtered. This option works only when you also specify MODE=ALL_CYCLES.","help":"MAXLINKWEIGHT=*num*","type":"value"},{"name":"MAXNODEWEIGHT=","optional":true,"description":"Specifies the maximum sum of node weights to allow in a cycle. If a cycle is found whose sum of node weights is greater than num, that cycle is removed from the results. The default is the positive number that has the largest absolute value representable in your operating environment. By default, nothing is filtered. This option works only when you also specify MODE=ALL_CYCLES.","help":"MAXNODEWEIGHT=*num*","type":"value"},{"name":"MAXTIME","optional":true,"description":"Specifies the maximum amount of time to spend finding cycles. The type of time (either CPU time or real time) is determined by the value of the TIMETYPE= option. The value of num can be any positive number; the default value is the positive number that has the largest absolute value that can be represented in your operating environment. This option works only when you also specify MODE=ALL_CYCLES.","type":"standalone"},{"name":"MINLENGTH=","optional":true,"description":"Specifies the minimum number of links to allow in a cycle. If a cycle is found that has fewer links than num, that cycle is removed from the results. The default is 1. By default, nothing is filtered. This option works only when you also specify MODE=ALL_CYCLES.","help":"MINLENGTH=*num*","type":"value"},{"name":"MINLINKWEIGHT=","optional":true,"description":"Specifies the minimum sum of link weights to allow in a cycle. If a cycle is found whose sum of link weights is less than num, that cycle is removed from the results. The default is the negative number that has the largest absolute value representable in your operating environment. By default, nothing is filtered. This option works only when you also specify MODE=ALL_CYCLES.","help":"MINLINKWEIGHT=*num*","type":"value"},{"name":"MINNODEWEIGHT=","optional":true,"description":"Specifies the minimum sum of node weights to allow in a cycle. If a cycle is found whose sum of node weights is less than num, that cycle is removed from the results. The default is the negative number that has the largest absolute value representable in your operating environment. By default, nothing is filtered. This option works only when you also specify MODE=ALL_CYCLES.","help":"MINNODEWEIGHT=*num*","type":"value"},{"name":"MODE=","optional":true,"description":"Specifies the mode for processing cycles.","help":"MODE=ALL_CYCLES | FIRST_CYCLE*option*","type":"value","arguments":[{"name":"ALL_CYCLES","description":"Returns all (unique, elementary) cycles found.","type":"standalone"},{"name":"FIRST_CYCLE","description":"Returns the first cycle found.","type":"standalone"}]},{"name":"OUT=","optional":true,"description":"Specifies the output data set to contain the cycles found.","help":"OUT=*SAS-data-set*","type":"dataSet"}]},{"name":"DATA_ADJ_MATRIX_VAR","aliases":["ADJ_MATRIX_VAR"],"description":"ADJ_MATRIX_VAR column1 <,column2,...> ; The DATA_ADJ_MATRIX_VAR statement enables you to explicitly define the data set variable names for PROC OPTGRAPH to use when it reads the data set that is specified in the DATA_ADJ_MATRIX= option in the PROC OPTGRAPH statement. The format of the adjacency matrix input data set is defined in the section Adjacency Matrix Input Data. The value of each column variable must be numeric.","help":"DATA_ADJ_MATRIX_VAR column1 &lt;,column2,...&gt; "},{"name":"DATA_LINKS_VAR","aliases":["LINKS_VAR"],"description":"LINKS_VAR < options > ; The DATA_LINKS_VAR statement enables you to explicitly define the data set variable names for PROC OPTGRAPH to use when it reads the data set that is specified in the DATA_LINKS= option in the PROC OPTGRAPH statement.","help":"DATA_LINKS_VAR &lt;FROM=column&gt;&lt;LOWER=column&gt;&lt;TO=column&gt; ...","arguments":[{"name":"FROM=","optional":true,"description":"Specifies the data set variable name for from nodes. The value of column can be numeric or character.","help":"FROM=*column*","type":"value"},{"name":"LOWER=","optional":true,"description":"Specifies the data set variable name for link flow lower bounds. The value of column must be numeric.","help":"LOWER=*column*","type":"value"},{"name":"TO=","optional":true,"description":"Specifies the data set variable name for to node. The value of column can be numeric or character.","help":"TO=*column*","type":"value"},{"name":"UPPER=","optional":true,"description":"Specifies the data set variable name for link flow upper bounds. The value of column must be numeric.","help":"UPPER=*column*","type":"value"},{"name":"WEIGHT=","optional":true,"description":"Specifies the data set variable name for link weights. The value of column must be numeric.","help":"WEIGHT=*column*","type":"value"}]},{"name":"DATA_MATRIX_VAR","aliases":["MATRIX_VAR"],"description":"MATRIX_VAR column1 <,column2,...> ; The DATA_MATRIX_VAR statement enables you to explicitly define the data set variable names for PROC OPTGRAPH to use when it reads the data set that is specified in the DATA_MATRIX= option in the PROC OPTGRAPH statement. The format of the matrix input data set is defined in the section Matrix Input Data. The value of each column variable must be numeric.","help":"DATA_MATRIX_VAR column1 &lt;,column2,...&gt; "},{"name":"DATA_NODES_VAR","aliases":["NODES_VAR"],"description":"NODES_VAR < options > ; The DATA_NODES_VAR statement enables you to explicitly define the data set variable names for PROC OPTGRAPH to use when it reads the data set that is specified in the DATA_NODES= option in the PROC OPTGRAPH statement.","help":"DATA_NODES_VAR &lt;CLUSTER=column&gt;&lt;NODE=column&gt;&lt;WEIGHT=column&gt; ...","arguments":[{"name":"CLUSTER=","optional":true,"description":"Specifies the data set variable name for clusters identifiers. The value of column must be numeric.","help":"CLUSTER=*column*","type":"value"},{"name":"NODE=","optional":true,"description":"Specifies the data set variable name for the nodes. The value of column can be numeric or character.","help":"NODE=*column*","type":"value"},{"name":"WEIGHT2=","optional":true,"description":"Specifies the data set variable name for auxiliary node weights. The value of column must be numeric.","help":"WEIGHT2=*column*","type":"value"},{"name":"WEIGHT=","optional":true,"description":"Specifies the data set variable name for node weights. The value of column must be numeric.","help":"WEIGHT=*column*","type":"value"}]},{"name":"EIGENVECTOR","description":"The EIGENVECTOR statement invokes an algorithm that finds eigenvectors (and eigenvalues) for symmetric matrices. The matrix is typically defined in the input data set that is specified by the DATA_MATRIX= option in the PROC OPTGRAPH statement. The matrix can also be input as a graph by using the DATA_LINKS= option in the PROC OPTGRAPH statement. Internally, the graph is converted into a (sparse) adjacency matrix.","help":"EIGENVECTOR &lt;ALGORITHM=&lt;ARPACK | POWER&gt;&gt;&lt;LOGLEVEL=&lt;NONE|0 | BASIC|1 | MODERATE|2&gt;... &gt;&lt;MAXITER=num&gt; ...","arguments":[{"name":"ALGORITHM=","optional":true,"description":"Specifies the algorithm to use when calculating eigenvectors.","help":"ALGORITHM=ARPACK | POWER","type":"choice","arguments":[{"name":"ARPACK","description":"Uses ARPACK to calculate eigenvectors. This is the default.","type":"standalone"},{"name":"POWER","description":"Uses the power method to calculate eigenvectors. This option can be used only when EIGENVALUES=LM and NEIGEN=1.","type":"standalone"}]},{"name":"EIGENVALUES=","optional":true,"description":"Specifies the type of eigenvector to calculate.","help":"EIGENVALUES=LA | SA | LM | SM | BE","type":"choice","arguments":[{"name":"LA","description":"Computes NEIGEN largest (algebraic) eigenvalues.","type":"standalone"},{"name":"SA","description":"Computes NEIGEN smallest (algebraic) eigenvalues.","type":"standalone"},{"name":"LM","description":"Computes NEIGEN largest (in magnitude) eigenvalues. This is the default","type":"standalone"},{"name":"SM","description":"Computes NEIGEN smallest (in magnitude) eigenvalues.","type":"standalone"},{"name":"BE","description":"Computes NEIGEN eigenvalues, half from each end of the spectrum. When NEIGEN is odd, compute one more from the high end than from the low end.","type":"standalone"}]},{"name":"LOGLEVEL=","optional":true,"description":"Controls the amount of information that is displayed in the SAS log.","help":"LOGLEVEL=NONE | BASIC | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"NONE","aliases":["0"],"description":"Turns off all algorithm-related messages in the SAS log","type":"standalone"},{"name":"BASIC","aliases":["1"],"description":"Displays a basic summary of the algorithmic processing","type":"standalone"},{"name":"MODERATE","aliases":["2"],"description":"Displays a summary of the algorithmic processing","type":"standalone"},{"name":"AGGRESSIVE","aliases":["3"],"description":"Displays a detailed summary of the algorithmic processing","type":"standalone"}]},{"name":"MAXITER=","optional":true,"description":"Specifies the maximum number of iterations used in the algorithm to calculate eigenvectors. When ALGORITHM=ARPACK is also specified, the resulting solution is invalid when the number of iterations reaches num. When ALGORITHM=POWER is also specified, the resulting solution might be valid but is not guaranteed. The default is 5,000.","help":"MAXITER=*num*","type":"value"},{"name":"NEIGEN=","optional":true,"description":"Specifies the number of eigenvectors to generate. When ALGORITHM=ARPACK is specified, this value must be less than the dimension of the matrix. The default is 1.","help":"NEIGEN=*num*","type":"value"},{"name":"OUT=","optional":true,"description":"Specifies the output data set to contain the eigenvectors (and eigenvalues) found.","help":"OUT=*SAS-data-set*","type":"dataSet"}]},{"name":"LINEAR_ASSIGNMENT","aliases":["LAP"],"description":"The LINEAR_ASSIGNMENT statement invokes an algorithm that solves the minimal-cost linear assignment problem. In graph terms, this problem is also known as the minimum link-weighted matching problem on a bipartite graph. The input data (the cost matrix) is typically defined in the input data set that is specified in the DATA_MATRIX= option in the PROC OPTGRAPH statement. The data can also be defined as a directed graph by specifying the DATA_LINKS= option in the PROC OPTGRAPH statement, where the costs are defined as link weights. Internally, the graph is treated as a bipartite graph in which the from nodes define one part and the to nodes define the other part.","help":"LINEAR_ASSIGNMENT &lt;ID=(column1 &lt;,column2,...&gt;)&gt;&lt;LOGLEVEL=&lt;NONE|0 | BASIC|1 | MODERATE|2&gt;... &gt;&lt;MAXTIME=num&gt; ...","arguments":[{"name":"ID=","optional":true,"description":"Specifies the data set variable names that identify the matrix rows (from nodes). The information in these columns is carried to the output data set that is specified in the OUT= option. The value of each column variable can be numeric or character.","type":"value"},{"name":"LOGLEVEL=","optional":true,"description":"Controls the amount of information that is displayed in the SAS log.","help":"LOGLEVEL=NONE | BASIC | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"NONE","aliases":["0"],"description":"Turns off all algorithm-related messages in the SAS log","type":"standalone"},{"name":"BASIC","aliases":["1"],"description":"Displays a basic summary of the algorithmic processing","type":"standalone"},{"name":"MODERATE","aliases":["2"],"description":"Displays a summary of the algorithmic processing","type":"standalone"},{"name":"AGGRESSIVE","aliases":["3"],"description":"Displays a detailed summary of the algorithmic processing","type":"standalone"}]},{"name":"MAXTIME=","optional":true,"description":"Specifies the maximum amount of time to spend calculating cliques. The type of time (either CPU time or real time) is determined by the value of the TIMETYPE= option. The value of num can be any positive number; the default value is the positive number that has the largest absolute value that can be represented in your operating environment.","help":"MAXTIME=*num*","type":"value"},{"name":"OUT=","optional":true,"description":"Specifies the output data set to contain the solution to the linear assignment problem.","help":"OUT=*SAS-data-set*","type":"dataSet"},{"name":"WEIGHT=","optional":true,"description":"Specifies the data set variable names for the cost matrix. The value of each column variable must be numeric. If this option is not specified, the matrix is assumed to be defined by all of the numeric variables in the data set (excluding those specified in the ID= option).","type":"value"}]},{"name":"MINCUT","description":"The MINCUT statement invokes an algorithm that finds the minimum link-weighted cut of an input graph.","help":"MINCUT &lt;LOGLEVEL=&lt;NONE|0 | BASIC|1 | MODERATE|2&gt;... &gt;&lt;MAXNUMCUTS=num&gt;&lt;MAXWEIGHT=num&gt; ...","arguments":[{"name":"LOGLEVEL=","optional":true,"description":"Controls the amount of information that is displayed in the SAS log.","help":"LOGLEVEL=NONE | BASIC | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"NONE","aliases":["0"],"description":"Turns off all algorithm-related messages in the SAS log","type":"standalone"},{"name":"BASIC","aliases":["1"],"description":"Displays a basic summary of the algorithmic processing","type":"standalone"},{"name":"MODERATE","aliases":["2"],"description":"Displays a summary of the algorithmic processing","type":"standalone"},{"name":"AGGRESSIVE","aliases":["3"],"description":"Displays a detailed summary of the algorithmic processing","type":"standalone"}]},{"name":"MAXNUMCUTS=","optional":true,"description":"Specifies the maximum number of cuts to return from the algorithm. The minimal cut and any others found during the search, up to num, are returned. The default is 1.","help":"MAXNUMCUTS=*num*","type":"value"},{"name":"MAXWEIGHT=","optional":true,"description":"Specifies the maximum weight of the cuts to return from the algorithm. Only cuts that have weight less than or equal to num are returned. The default is the positive number that has the largest absolute value representable in your operating environment.","help":"MAXWEIGHT=*num*","type":"value"},{"name":"OUT=","optional":true,"description":"Specifies the output data set to contain the solution to the minimum cut problem.","help":"OUT=*SAS-data-set*","type":"dataSet"}]},{"name":"MINSPANTREE","description":"The MINSPANTREE statement invokes an algorithm that solves the minimum link-weighted spanning tree problem on an input graph.","help":"MINSPANTREE &lt;LOGLEVEL=&lt;NONE|0 | BASIC|1 | MODERATE|2&gt;... &gt;&lt;OUT=SAS-data-set&gt;","arguments":[{"name":"LOGLEVEL=","optional":true,"description":"Controls the amount of information that is displayed in the SAS log.","help":"LOGLEVEL=NONE | BASIC | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"NONE","aliases":["0"],"description":"Turns off all algorithm-related messages in the SAS log","type":"standalone"},{"name":"BASIC","aliases":["1"],"description":"Displays a basic summary of the algorithmic processing","type":"standalone"},{"name":"MODERATE","aliases":["2"],"description":"Displays a summary of the algorithmic processing","type":"standalone"},{"name":"AGGRESSIVE","aliases":["3"],"description":"Displays a detailed summary of the algorithmic processing","type":"standalone"}]},{"name":"OUT=","optional":true,"description":"Specifies the output data set to contain the solution to the minimum link-weighted spanning tree problem.","help":"OUT=*SAS-data-set*","type":"dataSet"}]},{"name":"NETFLOW_MINCOST","aliases":["MCF"],"description":"The NETFLOW_MINCOST statement invokes an algorithm that solves the minimum-cost network flow problem on an input graph.","help":"NETFLOW_MINCOST &lt;LOGFREQ=num&gt;&lt;LOGLEVEL=&lt;NONE|0 | BASIC|1 | MODERATE|2&gt;... &gt;&lt;MAXTIME=option&gt; ...","arguments":[{"name":"LOGFREQ=","optional":true,"description":"Controls the frequency for displaying iteration logs for minimum-cost network flow calculations that use the network simplex algorithm. For graphs that contain one component, this option displays progress every num simplex iterations, and the default is 10,000. For graphs that contain multiple components, when you also specify LOGLEVEL=MODERATE, this option displays progress after processing every num components, and the default is based on the number of components. When you also specify LOGLEVEL=AGGRESSIVE, the simplex iteration log for each component is displayed with frequency num.","help":"LOGFREQ=*num*","type":"value"},{"name":"LOGLEVEL=","optional":true,"description":"Controls the amount of information that is displayed in the SAS log.","help":"LOGLEVEL=NONE | BASIC | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"NONE","aliases":["0"],"description":"Turns off all algorithm-related messages in the SAS log","type":"standalone"},{"name":"BASIC","aliases":["1"],"description":"Displays a basic summary of the algorithmic processing","type":"standalone"},{"name":"MODERATE","aliases":["2"],"description":"Displays a summary of the algorithmic processing including a progress log using the interval dictated by the LOGFREQ option","type":"standalone"},{"name":"AGGRESSIVE","aliases":["3"],"description":"Displays a detailed summary of the algorithmic processing including a progress log using the interval dictated by the LOGFREQ option","type":"standalone"}]},{"name":"MAXTIME=","optional":true,"description":"Specifies the maximum amount of time to spend calculating minimum-cost network flows. The type of time (either CPU time or real time) is determined by the value of the TIMETYPE= option. The value of num can be any positive number; the default value is the positive number that has the largest absolute value that can be represented in your operating environment.","help":"MAXTIME=*option*","type":"value"}]},{"name":"PERFORMANCE","description":"The PERFORMANCE statement specifies performance options for multithreaded and distributed computing, passes variables about the distributed computing environment, and requests detailed results about the performance characteristics of the OPTGRAPH procedure. With the PERFORMANCE statement, you can also control whether the OPTGRAPH procedure executes in symmetric multiprocessing (SMP) or massively parallel processing (MPP) mode. The OPTGRAPH procedure supports the deterministic mode of the PARALLELMODE= option in the PERFORMANCE statement. Note:MPP mode requires SAS®High-Performance Analytics software.","help":"PERFORMANCE &lt;COMMIT=n&gt;&lt;CPUCOUNT=&lt;ACTUAL | &lt;num&gt;&gt;&gt;&lt;DATASERVER=“name”&gt; ...","arguments":[{"name":"COMMIT=","optional":true,"description":"This option specifies the minimum number of observations transferred from the client to the appliance necessary to update the SAS Log. For instance, if you specify COMMIT=5000, then every time the number of observations sent exceeds an integer multiple of 5000 a log message is produced. This message indicates the actual number of observations distributed, not the COMMIT= value that triggered the message.","help":"COMMIT=*n*","type":"value"},{"name":"CPUCOUNT=","optional":true,"description":"This argument specifies how many processors PROC OPTGRAPH assumes are available on each host in the computing environment. Valid values for number are integers between 1 and 256, inclusive. Setting CPUCOUNT= to a value greater than the actual number of available CPUs might results in reduced performance. Specify CPUCOUNT=ACTUAL to set CPUCOUNT= to the number of processors physically available. This number can be less than the physical number of CPUs if the SAS process has been restricted by system administration tools. This option overrides the CPUCOUNT= SAS system option. If PROC OPTGRAPH executes in SMP mode, then this option referes to the client machine of the SAS session. If PROC OPTGRAPH executes in MPP mode, then this option applies the nodes on the appliance.","help":"CPUCOUNT=ACTUAL | &lt;*num*&gt;","type":"choice","arguments":[{"name":"ACTUAL","description":"Sets CPUCOUNT to the number of processors physically available. This number can be less than the physical number of CPUs if the SAS process has been restricted by system administration tools.","type":"standalone"},{"name":"num","placeholder":true,"description":"Replace <num> with an actual number. Setting CPUCOUNT= to a number greater than the actual number of available CPUs might result in reduced performance. This option overrides the CPUCOUNT= SAS system option.","type":"value"}]},{"name":"DATASERVER=","optional":true,"description":"Specifies the name of the server on Teradata systems as defined through the hosts file and as used in the LIBNAME statement for Teradata. For example, if the hosts file defines myservercop1 33.44.55.66 as the server for Teradata, then a LIBNAME specification would be as follows: libname TDLib teradata server=myserver user= password= database= ; A PERFORMANCE statement to induce running alongside the Teradata server would specify the following:","type":"value"},{"name":"DETAILS","optional":true,"description":"Specify this option to request a table that shows a timing breakdown of the procedure steps.","type":"standalone"},{"name":"HOST=","optional":true,"aliases":["GRIDHOST="],"description":"This option specifies the name of the appliance host. The HOST= option overrides the value of the GRIDHOST environment variable.","type":"value"},{"name":"INSTALL=","optional":true,"aliases":["INSTALLLOC="],"description":"This option specifies the directory where the High-Performance Analytics shared libraries are installed on the appliance. Specifying the INSTALL= option overrides the GRIDINSTALLLOC environment variable.","type":"value"},{"name":"NTHREADS=","optional":true,"description":"This option specifies the number of threads used for analytic computations and overrides the SAS system option THREADS | NOTHREADS. If you do not specify the NTHREADS= option, then the number of threads is determined based on the number of CPUs on the host machine where the analytic computations execute. By default, High-Performance Analytics procedures execute in multiple concurrent threads, unless you disable this behavior with the NOTHREADS system option or you specify NTHREADS=1 to force single-threaded execution. The value specified here must not exceed 256.","help":"NTHREADS=*n*","type":"value"},{"name":"TIMEOUT=","optional":true,"description":"Specifies the time-out in seconds for the procedure to wait for a connection to the appliance and establish a connection back to the client. The default is 120 seconds. If jobs are submitted to the appliance through workload management tools that might suspend access to the appliance for a longer period, you might want to increase the time-out value.","help":"TIMEOUT=*s*","type":"value"}]},{"name":"REACH","description":"The REACH statement invokes an algorithm that calculates the reach (ego) network on an input graph.","help":"REACH &lt;BY_CLUSTER&gt;&lt;DIGRAPH&gt;&lt;EACH_SOURCE&gt; ...","arguments":[{"name":"BY_CLUSTER","optional":true,"description":"Decomposes the calculations by cluster (subgraph). If this option is specified, PROC OPTGRAPH looks for a definition of the clusters in the input data set specified by the DATA_NODES= option in the PROC OPTGRAPH statement. If BY_CLUSTER is specified, the reach network links output (specified by the OUT_LINKS= option) cannot be generated.","type":"standalone"},{"name":"DIGRAPH","optional":true,"description":"Calculates the directed reach counts when computing the reach networks and includes the directed counts in the resulting output data set that is specified in the OUT_COUNTS= option. This option is ignored unless you specify MAXREACH=1 in the REACH statement.","type":"standalone"},{"name":"EACH_SOURCE","optional":true,"description":"Treats each node as a source and calculates a reach network from each one.","type":"standalone"},{"name":"IGNORE_SELF","optional":true,"description":"Ignores the source nodes in the reach network node counts.","type":"standalone"},{"name":"LOGFREQTIME=","optional":true,"description":"Displays iteration logs for the reach algorithm every num seconds. When PROC OPTGRAPH runs the reach algorithm, it displays the number of source networks that have completed. When you also specify the BY_CLUSTER option in the REACH statement, PROC OPTGRAPH displays the number of subgraphs that have completed. The value of num can be any integer greater than or equal to 1; the default is 5. Setting this value too low can hurt performance on large-scale graphs.","help":"LOGFREQTIME=*num*","type":"value"},{"name":"LOGLEVEL=","optional":true,"description":"Controls the amount of information that is displayed in the SAS log.","help":"LOGLEVEL=NONE | BASIC | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"NONE","aliases":["0"],"description":"Turns off all algorithm-related messages in the SAS log","type":"standalone"},{"name":"BASIC","aliases":["1"],"description":"Displays a basic summary of the algorithmic processing","type":"standalone"},{"name":"MODERATE","aliases":["2"],"description":"Displays a summary of the algorithmic processing","type":"standalone"},{"name":"AGGRESSIVE","aliases":["3"],"description":"Displays a detailed summary of the algorithmic processing","type":"standalone"}]},{"name":"MAXREACH=","optional":true,"description":"Specifies the maximum number of links to allow from each source node in a reach network.","help":"MAXREACH=*num*","type":"value"},{"name":"OUT_COUNTS1=","optional":true,"description":"Specifies the output data set to contain the node counts in each reach network for the special case of calculating only counts that have limit 1 and 2. This data set holds the counts with MAXREACH=1. This option works only when the EACH_SOURCE and BY_CLUSTER options are specified.","help":"OUT_COUNTS1=*SAS-data-set*","type":"dataSet"},{"name":"OUT_COUNTS2=","optional":true,"description":"Specifies the output data set to contain the node counts in each reach network for the special case of calculating only counts that have limit 1 and 2. This data set holds the counts with MAXREACH=2. This option works only when the EACH_SOURCE and BY_CLUSTER options are specified.","help":"OUT_COUNTS2=*SAS-data-set*","type":"dataSet"},{"name":"OUT_COUNTS=","optional":true,"description":"Specifies the output data set to contain the node counts in each reach network.","help":"OUT_COUNTS=*SAS-data-set*","type":"dataSet"},{"name":"OUT_LINKS=","optional":true,"description":"Specifies the output data set to contain the links in each reach network.","help":"OUT_LINKS=*SAS-data-set*","type":"dataSet"},{"name":"OUT_NODES=","optional":true,"description":"Specifies the output data set to contain the nodes in each reach network.","help":"OUT_NODES=*SAS-data-set*","type":"dataSet"}]},{"name":"SHORTPATH","description":"The SHORTPATH statement invokes an algorithm that calculates shortest paths between sets of nodes on the input graph.","help":"SHORTPATH &lt;LOGFREQNODE=num&gt;&lt;LOGLEVEL=&lt;NONE|0 | BASIC|1 | MODERATE|2&gt;... &gt;&lt;OUT_PATHS | OUT==SAS-data-set&gt; ...","arguments":[{"name":"LOGFREQNODE=","optional":true,"description":"Displays iteration logs for shortest path calculations every num nodes. The value of num can be any integer greater than or equal to 1. The default is determined automatically based on the size of the graph. Setting this value too low can hurt performance on large-scale graphs.","help":"LOGFREQNODE=*num*","type":"value"},{"name":"LOGLEVEL=","optional":true,"description":"Controls the amount of information that is displayed in the SAS log.","help":"LOGLEVEL=NONE | BASIC | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"NONE","aliases":["0"],"description":"Turns off all algorithm-related messages in the SAS log","type":"standalone"},{"name":"BASIC","aliases":["1"],"description":"Displays a basic summary of the algorithmic processing","type":"standalone"},{"name":"MODERATE","aliases":["2"],"description":"Displays a summary of the algorithmic processing including a progress log using the interval dictated by the LOGFREQ option","type":"standalone"},{"name":"AGGRESSIVE","aliases":["3"],"description":"Displays a detailed summary of the algorithmic processing including a progress log using the interval dictated by the LOGFREQ option","type":"standalone"}]},{"name":"OUT_PATHS=","optional":true,"aliases":["OUT="],"description":"Specifies the output data set to contain the shortest paths.","type":"value"},{"name":"OUT_WEIGHTS=","optional":true,"description":"Specifies the output data set to contain the shortest path summaries.","help":"OUT_WEIGHTS=*SAS-data-set*","type":"dataSet"},{"name":"PATHS=","optional":true,"description":"Specifies the type of output to produce in the output data set that is specified in the OUT_PATHS= option.","help":"PATHS=ALL | SHORTEST | LONGEST","type":"choice","arguments":[{"name":"ALL","description":"Outputs shortest paths for all pairs of source-sinks. This is the default.","type":"standalone"},{"name":"SHORTEST","description":"Outputs shortest paths for the source-sink pair with the longest (finite) length. If other source-sink pairs (up to 100) have equally long length, they are also output.","type":"standalone"},{"name":"LONGEST","description":"Outputs shortest paths for the source-sink pair with the shortest length. If other source-sink pairs (up to 100) have equally short length, they are also output.","type":"standalone"}]},{"name":"SINK=","optional":true,"description":"Specifies the sink node for shortest paths calculations. This setting overrides the use of the variable sink in the data set that is specified by the DATA_NODES_SUB= option in the PROC OPTGRAPH statement.","help":"SINK=*sink-node*","type":"value"},{"name":"SOURCE=","optional":true,"description":"Specifies the source node for shortest paths calculations. This setting overrides the use of the variable source in the data set that is specified by the DATA_NODES_SUB= option in the PROC OPTGRAPH statement.","help":"SOURCE=*source-node*","type":"value"},{"name":"USEWEIGHT=","optional":true,"description":"Specifies whether to use link weights (if they exist) in calculating shortest paths.","help":"USEWEIGHT=YES | NO","type":"choice","arguments":[{"name":"YES","description":"Uses weights (if they exist) in shortest path calculations. This is the default.","type":"standalone"},{"name":"NO","description":"Does not use weights in shortest path calculations.","type":"standalone"}]},{"name":"WEIGHT2=","optional":true,"description":"Specifies the data set variable name for the auxiliary link weights. The value of column must be numeric.","help":"WEIGHT2=*column*","type":"value"}]},{"name":"SUMMARY","description":"The SUMMARY statement invokes an algorithm that calculates various summary metrics on an input graph.","help":"SUMMARY &lt;BICONCOMP&gt;&lt;BY_CLUSTER&gt;&lt;CONCOMP&gt; ...","arguments":[{"name":"BICONCOMP","optional":true,"description":"Specifies whether to calculate information about biconnected components. The graph must be undirected.","type":"standalone"},{"name":"BY_CLUSTER","optional":true,"description":"Specifies whether to decompose the calculations by cluster (or subgraph). If this option is specified, PROC OPTGRAPH looks for a definition of the clusters in the input data set specified by the DATA_NODES= option.","type":"standalone"},{"name":"CONCOMP","optional":true,"description":"Specifies whether to calculate information about connected components.","type":"standalone"},{"name":"DIAMETER_APPROX=","optional":true,"description":"Specifies whether to calculate information about the approximate diameter and what type of calculations to perform. Use this option when calculating the exact diameter (by calculating all shortest paths) is too expensive.","help":"DIAMETER_APPROX=WEIGHT | UNWEIGHT | BOTH","type":"choice","arguments":[{"name":"WEIGHT","description":"Calculates approximate diameter based on the weighted graph.","type":"standalone"},{"name":"UNWEIGHT","description":"Calculates approximate diameter based on the unweighted graph.","type":"standalone"},{"name":"BOTH","description":"Calculates approximate diameter based on both weighted and unweighted graphs.","type":"standalone"}]},{"name":"LOGFREQNODE=","optional":true,"description":"Controls the frequency for displaying iteration logs for some of the summary metrics. For computationally intensive summary metrics such as shortest path, this option displays progress every num nodes. If you also specify the BY_CLUSTER option in this statement or a value greater than 1 for the NTHREADS= option in the PERFORMANCE statement, this option is ignored and the display frequency is determined by using the LOGFREQTIME= option instead. The value of num can be any integer greater than or equal to 1. The default is determined automatically based on the size of the graph. Setting this value too low can hurt performance on large-scale graphs.","help":"LOGFREQNODE=*num*","type":"value"},{"name":"LOGFREQTIME=","optional":true,"description":"Controls the frequency for displaying iteration logs for some of the summary metrics. For computationally intensive summary metrics such as shortest path, this option displays progress every num seconds. When you specify a value greater than 1 for the NTHREADS= option in the PERFORMANCE statement, PROC OPTGRAPH displays the number of nodes that have completed. When you specify the BY_CLUSTER option, PROC OPTGRAPH displays the number of subgraphs that have completed. The value of num can be any integer greater than or equal to 1; the default is 5. Setting this value too low can hurt performance on large-scale graphs.","help":"LOGFREQTIME=*num*","type":"value"},{"name":"LOGLEVEL=","optional":true,"description":"Controls the amount of information that is displayed in the SAS log.","help":"LOGLEVEL=NONE | BASIC | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"NONE","aliases":["0"],"description":"Turns off all algorithm-related messages in the SAS log","type":"standalone"},{"name":"BASIC","aliases":["1"],"description":"Displays a basic summary of the algorithmic processing","type":"standalone"},{"name":"MODERATE","aliases":["2"],"description":"Displays a summary of the algorithmic processing","type":"standalone"},{"name":"AGGRESSIVE","aliases":["3"],"description":"Displays a detailed summary of the algorithmic processing","type":"standalone"}]},{"name":"OUT=","optional":true,"description":"Specifies the output data set to contain the summary results.","help":"OUT=*SAS-data-set*","type":"dataSet"},{"name":"SHORTPATH=","optional":true,"description":"Specifies whether to calculate information about shortest paths and what type of calculations to perform.","help":"SHORTPATH=WEIGHT | UNWEIGHT | BOTH","type":"choice","arguments":[{"name":"WEIGHT","description":"Calculates shortest paths based on the weighted graph.","type":"standalone"},{"name":"UNWEIGHT","description":"Calculates shortest paths based on the unweighted graph.","type":"standalone"},{"name":"BOTH","description":"Calculates shortest paths based on both weighted and unweighted graphs.","type":"standalone"}]},{"name":"SUBSIZESWITCH=","optional":true,"description":"Specifies how many subgraph nodes to run separately when you also specify the BY_CLUSTER option in this statement and a value greater than 1 for the NTHREADS= option in the PERFORMANCE statement. When PROC OPTGRAPH processes summary by subgraphs, it uses thread logic to simultaneously process a number of subgraphs, with that number as specified in the NTHREADS= option in the PERFORMANCE statement. For a larger graph with a number of nodes greater than num, each subgraph is processed sequentially, allowing the threading to be done at the summary metric level.","help":"SUBSIZESWITCH=*num*","type":"value"}]},{"name":"TRANSITIVE_CLOSURE","aliases":["TRANSC"],"description":"The TRANSITIVE_CLOSURE statement invokes an algorithm that calculates the transitive closure of an input graph.","help":"TRANSITIVE_CLOSURE &lt;LOGLEVEL=&lt;NONE|0 | BASIC|1 | MODERATE|2&gt;... &gt;&lt;OUT=SAS-data-set&gt;","arguments":[{"name":"LOGLEVEL=","optional":true,"description":"Controls the amount of information that is displayed in the SAS log.","help":"LOGLEVEL=NONE | BASIC | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"NONE","aliases":["0"],"description":"Turns off all algorithm-related messages in the SAS log","type":"standalone"},{"name":"BASIC","aliases":["1"],"description":"Displays a basic summary of the algorithmic processing","type":"standalone"},{"name":"MODERATE","aliases":["2"],"description":"Displays a summary of the algorithmic processing","type":"standalone"},{"name":"AGGRESSIVE","aliases":["3"],"description":"Displays a detailed summary of the algorithmic processing","type":"standalone"}]},{"name":"OUT=","optional":true,"description":"Specifies the output data set to contain the transitive closure results.","help":"OUT=*SAS-data-set*","type":"dataSet"}]},{"name":"TSP","description":"The TSP statement invokes an algorithm that solves the traveling salesman problem. The traveling salesman problem is described in the section Traveling Salesman Problem. The algorithm that is used to solve this problem is built around the same method as is used in PROC OPTMILP: a branch-and-cut algorithm.","help":"TSP &lt;ABSOBJGAP=num&gt;&lt;CUTOFF=num&gt;&lt;CUTSTRATEGY=&lt;AUTOMATIC|-1 | NONE|0 | MODERATE|1&gt;... &gt; ...","arguments":[{"name":"ABSOBJGAP=","optional":true,"description":"Specifies a stopping criterion. When the absolute difference between the best integer objective and the objective of the best remaining branch-and-bound node becomes less than the value of num, the procedure stops. The value of num can be any nonnegative number; the default value is 1E–6.","help":"ABSOBJGAP=*num*","type":"value"},{"name":"CUTOFF=","optional":true,"description":"Cuts off any branch-and-bound nodes in a minimization problem with an objective value that is greater than num. The value of num can be any number; the default value is the positive number that has the largest absolute value that can be represented in your operating environment.","help":"CUTOFF=*num*","type":"value"},{"name":"CUTSTRATEGY=","optional":true,"description":"Specifies the level of cuts to be generated by PROC OPTGRAPH.","help":"CUTSTRATEGY=AUTOMATIC | NONE | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"AUTOMATIC","aliases":["-1"],"description":"Disables most of the generic mixed-integer programming cuts and focuses on the generation of TSP-specific cuts","type":"standalone"},{"name":"NONE","aliases":["0"],"description":"Disables generation of cutting planes","type":"standalone"},{"name":"MODERATE","aliases":["1"],"description":"Uses a moderate cut strategy","type":"standalone"},{"name":"AGGRESSIVE","aliases":["2"],"description":"Uses an aggressive cut strategy","type":"standalone"}]},{"name":"EMPHASIS=","optional":true,"description":"Specifies a search emphasis option or its corresponding value num.","help":"EMPHASIS=BALANCE | OPTIMAL | FEASIBLE","type":"choice","arguments":[{"name":"BALANCE","aliases":["0"],"description":"Performs a balanced search","type":"standalone"},{"name":"OPTIMAL","aliases":["1"],"description":"Emphasizes optimality over feasibility","type":"standalone"},{"name":"FEASIBLE","aliases":["2"],"description":"Emphasizes feasibility over optimality","type":"standalone"}]},{"name":"HEURISTICS=","optional":true,"description":"Controls the level of initial and primal heuristics that are applied by PROC OPTGRAPH. This level determines how frequently primal heuristics are applied during the branch-and-bound tree search. It also affects the maximum number of iterations that are allowed in iterative heuristics. Some computationally expensive heuristics might be disabled by the solver at less aggressive levels.","help":"HEURISTICS=AUTOMATIC | NONE | BASIC | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"AUTOMATIC","aliases":["-1"],"description":"Applies the default level of heuristics","type":"standalone"},{"name":"NONE","aliases":["0"],"description":"Disables all initial and primal heuristics","type":"standalone"},{"name":"BASIC","aliases":["1"],"description":"Applies basic intial and primal heuristics at low frequency","type":"standalone"},{"name":"MODERATE","aliases":["2"],"description":"Applies most intial and primal heuristics at moderate frequency","type":"standalone"},{"name":"AGGRESSIVE","aliases":["3"],"description":"Applies all intitial primal heuristics at high frequency","type":"standalone"}]},{"name":"INTTOL=","optional":true,"description":"Specifies the amount by which an integer variable value can differ from an integer and still be considered integer feasible. The value of num can be any number between 0.0 and 1.0; the default value is 1E–5. PROC OPTGRAPH attempts to find an optimal solution with integer infeasibility less than num. If you assign a value that is less than 1E–10 to num and the best solution found by PROC OPTGRAPH has integer infeasibility between num and 1E–10, then PROC OPTGRAPH ends with a solution status of OPTIMAL_COND.","help":"INTTOL=*num*","type":"value"},{"name":"LOGFREQ=","optional":true,"description":"Specifies how often to print information in the branch-and-bound node log. The value of num can be any nonnegative integer up to the largest four-byte signed integer, which is 2³¹ - 1. The default value is 100. If num is set to 0, then the node log is disabled. If num is positive, then an entry is made in the node log at the first node, at the last node, and at intervals that are dictated by the value of num. An entry is also made each time a better integer solution is found.","help":"LOGFREQ=*num*","type":"value"},{"name":"LOGLEVEL=","optional":true,"description":"Controls the amount of information displayed in the SAS log by the solver, from a short description of presolve information and summary to details at each branch-and-bound node.","help":"LOGLEVEL=NONE | BASIC | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"NONE","aliases":["0"],"description":"Turns off all solver-related messages in the SAS log","type":"standalone"},{"name":"BASIC","aliases":["1"],"description":"Displays a solver summary after stopping","type":"standalone"},{"name":"MODERATE","aliases":["2"],"description":"Prints a solver summary and a node log by using the interval dictated by the LOGFREQ= option","type":"standalone"},{"name":"AGGRESSIVE","aliases":["3"],"description":"Prints a detailed solver summary and a node log by using the interval dictated by the LOGFREQ= option","type":"standalone"}]},{"name":"MAXNODES=","optional":true,"description":"Specifies the maximum number of branch-and-bound nodes to be processed. The value of num can be any nonnegative integer up to the largest four-byte signed integer, which is 2³¹ - 1.","help":"MAXNODES=*num*","type":"value"},{"name":"MAXSOLS=","optional":true,"description":"Specifies a stopping criterion. If num solutions have been found, then the procedure stops. The value of num can be any positive integer up to the largest four-byte signed integer, which is 2³¹ - 1. The default value is 2³¹ - 1.","help":"MAXSOLS=*num*","type":"value"},{"name":"MAXTIME","optional":true,"description":"Specifies the maximum amount of time to spend solving the traveling salesman problem. The type of time (either CPU time or real time) is determined by the value of the TIMETYPE= option. The value of num can be any positive number; the default value is the positive number that has the largest absolute value that can be represented in your operating environment.","type":"standalone"},{"name":"MILP=","optional":true,"description":"Specifies whether to use a mixed-integer linear programming (MILP) solver for solving the traveling salesman problem. The MILP solver attempts to find the overall best TSP tour by using a branch-and-bound based algorithm. This algorithm can be expensive for large-scale problems. If MILP=OFF, then PROC OPTGRAPH uses its initial heuristics to find a feasible, but not necessarily optimal, tour as quickly as possible.","help":"MILP=ON | OFF","type":"choice","arguments":[{"name":"ON","description":"Uses a mixed-integer linear programming","type":"standalone"},{"name":"OFF","description":"Does not use a mixed-integer linear programming solver","type":"standalone"}]},{"name":"NODESEL=","optional":true,"description":"Specifies the branch-and-bound node selection strategy option or its corresponding value num.","help":"NODESEL=AUTOMATIC | BESTBOUND | BESTESTIMATE | DEPTH","type":"choice","arguments":[{"name":"AUTOMATIC","aliases":["-1"],"description":"Uses automatic node select","type":"standalone"},{"name":"BESTBOUND","aliases":["0"],"description":"Chooses the node with the best relaxed objective (best-bound-first strategy)","type":"standalone"},{"name":"BESTESTIMATE","aliases":["1"],"description":"Chooses the node with the best estimate of the integer objective value (best-estimate-first strategy)","type":"standalone"},{"name":"DEPTH","aliases":["2"],"description":"Chooses the most recently created node (depth-first strategy)","type":"standalone"}]},{"name":"OUT=","optional":true,"description":"Specifies the output data set to contain the solution to the traveling salesman problem.","help":"OUT=*SAS-data-set*","type":"dataSet"},{"name":"PROBE=","optional":true,"description":"Specifies a probing option or its corresponding value num:","help":"PROBE=AUTOMATIC | NONE | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"AUTOMATIC","aliases":["-1"],"description":"Uses an automatic probing strategy","type":"standalone"},{"name":"NONE","aliases":["0"],"description":"Disables probing","type":"standalone"},{"name":"MODERATE","aliases":["1"],"description":"Uses the probing moderately","type":"standalone"},{"name":"AGGRESSIVE","aliases":["2"],"description":"Uses the probing aggressively","type":"standalone"}]},{"name":"RELOBJGAP=","optional":true,"description":"Specifies a stopping criterion that is based on the best integer objective (BestInteger) and the objective of the best remaining node (BestBound).","help":"RELOBJGAP=*num*","type":"value"},{"name":"STRONGITER=","optional":true,"description":"Specifies the number of simplex iterations to be performed for each variable in the candidate list when using the strong branching variable selection strategy. The value of num can be any positive number; the default value is automatically calculated by PROC OPTGRAPH.","help":"STRONGITER=*num*","type":"value"},{"name":"STRONGLEN=","optional":true,"description":"Specifies the number of candidates to be used when performing the strong branching variable selection strategy. The value of num can be any positive integer up to the largest four-byte signed integer, which is 2³¹ - 1. The default value is 10.","help":"STRONGLEN=*num*","type":"value"},{"name":"TARGET=","optional":true,"description":"Specifies a stopping criterion for minimization (maximization) problems. If the best integer objective is better than or equal to num, the procedure stops. The value of num can be any number; the default is the negative (positive) number that has the largest absolute value that can be represented in your operating environment.","help":"TARGET=*num*","type":"value"},{"name":"VARSEL=","optional":true,"description":"Specifies the rule for selecting the branching variable.","help":"VARSEL=AUTOMATIC |  MAXINFEAS | MININFEAS | PESUDO | STRONG","type":"choice","arguments":[{"name":"AUTOMATIC","aliases":["-1"],"description":"Uses automatic branching variable selection","type":"standalone"},{"name":"MAXINFEAS","aliases":["0"],"description":"Chooses the variable with maximum infeasibility","help":" MAXINFEAS","type":"standalone"},{"name":"MININFEAS","aliases":["1"],"description":"Chooses the variable with minimum infeasibility","type":"standalone"},{"name":"PESUDO","aliases":["2"],"description":"Chooses a branching variable based on pseudocost","type":"standalone"},{"name":"STRONG","aliases":["3"],"description":"Uses strong branching variable selection strategy","type":"standalone"}]}]}],"supportSiteInformation":{"docsetId":"procgralg","docsetVersion":"v_001","docsetTargetFile":"procgralg_optgraph_toc.htm"}}