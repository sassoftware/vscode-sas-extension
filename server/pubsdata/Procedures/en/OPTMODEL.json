{"name":"OPTMODEL","statements":[{"name":"PROC OPTMODEL","description":"Declaration Statements... Programming Statements... parameter = expression ; (Assignment) ... † The OPTMODEL procedure comprises the powerful OPTMODEL modeling language and state-of-the-art solvers for several classes of mathematical programming problems: † Linear Programming (LP) Mixed Integer Linear Programming (MILP) Quadratic Programming (QP) (experimental) Nonlinear Programming, Unconstrained (NLPU) General Nonlinear Programming (NLPC) General Nonlinear Programming (SQP) General Nonlinear Programming (IPNLP)","help":"PROC OPTMODEL <CDIGITS=number> <ERRORLIMIT=<number> | NONE> <FD=FORWARD | CENTRAL> <FDIGITS=number> <FORCEFD=ALL | CON | NONE... > <FORCEPRESOLVE=number | string> <INITVAR> <INTFUZZ=number> <MAXLABLEN=number> <MISSCHECK> <MSGLIMIT=<number> | NONE> <NOINITVAR> <NOMISSCHECK> <PDIGITS=number> <PMATRIX=number> <PRESOLVER=NONE | AUTOMATIC | BASIC... > <PRESTOL=number> <PRINTLEVEL=0 | 1 | 2> <PWIDTH=number> <VARFUZZ=number>;     \n\tCALL name ( argument-1 [, ...argument-n] ); \n   \n\tCLOSEFILE file-specification(s);   \n \n\tCOFOR { index-set } statement;     \n\tCONSTRAINT constraint [, ...constraint];     \n\tCONTINUE ;     \n\tCREATE DATA <FROM [[ key-column(s) ] [ =key-set ] ] column(s)> ;     \n\tDO ; statement(s) ; END;     \n\tDO UNTIL ( logic-expression ) ; statement(s) ; END;     \n\tDO WHILE ( logic-expression ) ; statement(s) ; END;     \n\tDROP identifier-expression;     \n\tELSE <DO> <IF> <THEN> ...; \n   \n\tEND;     \n\tENDSUBMIT; \n   \n\tEXPAND <FIX> <SOLVE> <VAR> ...; \n   \n\tFILE <LRECL=value> ; \n   \n\tFIX identifier-list [ =( expression ) ]; \n   \n\tFOR { index-set } statement ;     \n\tIF <DO> <THEN> <WHEN> ...; \n   \n\tIMPVAR impvar-decl [, ...impvar-decl] ; \n   \n\tLEAVE ;     \n\tMAX name = expression;     \n\tMIN name = expression; \n   \n\tNUMBER <INIT expression> ; \n   \n\tPERFORMANCE <DETAILS> <NTHREADS=<<num> | CPUCOUNT>> <PARALLELMODE=<DETERMINISTIC|0 | NONDETERMINISTIC|1>> ...; \n   \n\tPRINT <_PAGE_> ; \n   \n\tPROBLEM <FROM> <INCLUDE> ; \n   \n\tPROFILE <OFF> <ON> <PRINT> ...; \n   \n\tPUT <_PAGE_> ;  \n  \n\tREAD DATA <INTO> NOMISS <TRIM> ...; \n   \n\tRESET OPTIONS <CDIGITS=number> <ERRORLIMIT=<<number> | NONE>> <FD=<FORWARD | CENTRAL>> ...; \n   \n\tRESTORE identifier-expression;     \n\tSAVE MPS SAS-data-set  ( OBJECTIVE | OBJ ) name  ;     \n\tSAVE QPS NOOBJECTIVE OBJECTIVE ;     \n\tSET <INIT expression> <NUMBER> <STRING> ...; \n   \n\tSOLVE OBJECTIVE RELAXINT WITH ...; \n   \n\tSOLVE WITH CLP NOOBJECTIVE OBJECTIVE RELAXINT ...; \n   \n\tSOLVE WITH IPNLP NOOBJECTIVE OBJECTIVE RELAXINT ...; \n   \n\tSOLVE WITH LP NOOBJECTIVE OBJECTIVE RELAXINT ...; \n   \n\tSOLVE WITH MILP NOOBJECTIVE OBJECTIVE RELAXINT ...; \n   \n\tSOLVE WITH NETWORK NOOBJECTIVE OBJECTIVE RELAXINT ...;     \n\tSOLVE WITH NLP NOOBJECTIVE OBJECTIVE RELAXINT ...;     \n\tSOLVE WITH NLPC NOOBJECTIVE OBJECTIVE RELAXINT ...;     \n\tSOLVE WITH NLPU NOOBJECTIVE OBJECTIVE RELAXINT ...;     \n\tSOLVE WITH QP NOOBJECTIVE OBJECTIVE RELAXINT ...;     \n\tSOLVE WITH SQP NOOBJECTIVE OBJECTIVE RELAXINT ...;     \n\tSTOP ;     \n\tSTRING <INIT expression> ; \n   \n\tSUBMIT <OK = identifier-expression> <OUT[=] output-argument | (output-arguments)> ;  \n  \n\tUNFIX identifier-list [ =( expression ) ]; \n   \n\tUSE PROBLEM identifier-expression ; \n   \n\tVAR <BINARY> <INIT expression> <INTEGER> ...; ","arguments":[{"name":"CDIGITS=","optional":true,"description":"Specifies the expected number of decimal digits of accuracy for nonlinear constraints. The value can be fractional. PROC OPTMODEL uses this option to choose a step length when numeric derivative approximations are required to evaluate the Jacobian of nonlinear constraints. The default value depends on your operating environment. It is assumed that constraint values are accurate to the limits of machine precision.","help":"CDIGITS=*number*","type":"value"},{"name":"ERRORLIMIT=","optional":true,"description":"Specifies the maximum number of error messages that can be displayed. Specifying a value of number in the range 1 to 2³¹-1 sets a specific limit. Specifying ERRORLIMIT=NONE removes any existing limit.","help":"ERRORLIMIT=&lt;*number*&gt; | NONE","type":"choice","arguments":[{"name":"number","placeholder":true,"description":"Replace <number> with an actual number in the range 1 to 2³¹-1 to set a specific limit.","type":"value"},{"name":"NONE","description":"Specifying ERRORLIMIT=NONE removes any existing limit.","type":"standalone"}]},{"name":"FD=","optional":true,"description":"Selects the method used to approximate numeric derivatives when analytic derivatives are unavailable. Most solvers require the derivatives of the objective and constraints. The methods available are as follows:","help":"FD=FORWARD | CENTRAL","type":"choice","arguments":[{"name":"FORWARD","description":"Uses forward differences","type":"standalone"},{"name":"CENTRAL","description":"Uses central differences","type":"standalone"}]},{"name":"FDIGITS=","optional":true,"description":"Specifies the expected number of decimal digits of accuracy for the objective function. The value can be fractional.","help":"FDIGITS=*number*","type":"value"},{"name":"FORCEFD=","optional":true,"description":"Forces PROC OPTMODEL to use finite differences instead of analytic derivatives for the specified set of nonlinear expressions. This option can be useful with FCMP functions to provide more control over derivative computation.","help":"FORCEFD=ALL | CON | NONE | OBJ","type":"choice","arguments":[{"name":"ALL","description":"Restricts all derivative computations to use finite differences.","type":"standalone"},{"name":"CON","description":"Restricts derivative computations for the nonlinear constraint expressions and any IMPVAR expressions they reference to use finite differences.","type":"standalone"},{"name":"NONE","description":"Requests analytic derivatives where they are available.","type":"standalone"},{"name":"OBJ","description":"Restricts derivative computations for the objective and any IMPVAR expressions it references to use finite differences.","type":"standalone"}]},{"name":"FORCEPRESOLVE=","optional":true,"description":"specifies whether PROC OPTMODEL can use the OPTMODEL presolver with the CLP, LP, MILP, and QP solvers. By default, the OPTMODEL presolver is disabled when PROC OPTMODEL solves linear problems or problems with predicates, or when the CLP, LP, MILP, or QP solver is specified in the SOLVE statement. Table 5.4 shows the valid values for this option. Table 5.4: Values for the FORCEPRESOLVE= Option number string Description 0 OFF Restores the default behavior. 1 ON Enables PROC OPTMODEL to use the OPTMODEL presolver when the CLP, LP, MILP, or QP solver is specified in the SOLVE statement.","type":"value"},{"name":"INITVAR","optional":true,"description":"Selects to pass initial values for variables to the solver when the SOLVE statement is executed.","type":"standalone"},{"name":"INTFUZZ=","optional":true,"description":"Specifies the tolerance for rounding the bounds on integer and binary variables to integer values.","help":"INTFUZZ=*number*","type":"value"},{"name":"MAXLABLEN=","optional":true,"description":"Specifies the maximum length for MPS row and column labels. The allowed range is 8 to 256, with 32 as the default.","help":"MAXLABLEN=*number*","type":"value"},{"name":"MISSCHECK","optional":true,"description":"Requests that a message be produced each time PROC OPTMODEL evaluates an arithmetic operation or built-in function that has missing value operands (except when the operation or function specifically supports missing values).","type":"standalone"},{"name":"MSGLIMIT=","optional":true,"description":"Specifies the maximum number of non-error messages that can be displayed, including notes and warnings. Specifying a value of number in the range 1 to 2³¹-1 sets a specific limit. Specifying ERRORLIMIT=NONE removes any existing limit.","help":"MSGLIMIT=&lt;*number*&gt; | NONE","type":"choice","arguments":[{"name":"number","placeholder":true,"description":"Replace <number> with an actual number in the range 1 to 2³¹-1 to set a specific limit.","type":"value"},{"name":"NONE","description":"Specifying ERRORLIMIT=NONE removes any existing limit.","type":"standalone"}]},{"name":"NOINITVAR","optional":true,"description":"Causes the solver to be invoked without any specific initial values for variables.","type":"standalone"},{"name":"NOMISSCHECK","optional":true,"description":"Turns off detailed checking of missing values in expressions. This is the default.","type":"standalone"},{"name":"PDIGITS=","optional":true,"description":"Requests that the PRINT statement display num significant digits for numeric columns for which no format is specified. The value can range from 1 to 9. The default is 5.","help":"PDIGITS=*number*","type":"value"},{"name":"PMATRIX=","optional":true,"description":"Adjusts the density evaluation of a two-dimensional array to affect how it is displayed. The value num scales the total number of nonempty array elements and is used by the PRINT statement to evaluate whether a two-dimensional array is \"sparse\" or \"dense\".","help":"PMATRIX=*number*","type":"value"},{"name":"PRESOLVER=","optional":true,"description":"Specifies a presolve option.","help":"PRESOLVER=NONE | AUTOMATIC | BASIC | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"NONE","description":"Specifies to disable the presolver.","type":"standalone"},{"name":"AUTOMATIC","description":"Specifies to apply presolver using default setting.","type":"standalone"},{"name":"BASIC","description":"Specifies to perform minimal processing, only substituting fixed variables and removing empty feasible constraints.","type":"standalone"},{"name":"MODERATE","description":"Specifies to apply a higher level of presolve processing..","type":"standalone"},{"name":"AGGRESSIVE","description":"Specifies to apply the highest level of presolve processing.","type":"standalone"}]},{"name":"PRESTOL=","optional":true,"description":"Provides a tolerance so that slightly infeasible constraints can be eliminated by the OPTMODEL presolver.","help":"PRESTOL=*number*","type":"value"},{"name":"PRINTLEVEL=","optional":true,"description":"Controls the level of listing output during a SOLVE command.","help":"PRINTLEVEL=0 | 1 | 2","type":"choice","arguments":[{"name":"0","description":"Disable all tables.","type":"standalone"},{"name":"1","description":"Print Problem Summary and Solution Summary.","type":"standalone"},{"name":"2","description":"Print Problem Summary, Solution Summary, Methods of Derivative Computation (for NLP solvers), Solver Options, Optimization Statistics and solver-specific ODS tables.","type":"standalone"}]},{"name":"PWIDTH=","optional":true,"description":"Sets the width used by the PRINT statement to display numeric columns when no format is specified. The smallest value num can take is the value of the PDIGITS= option plus 7; the largest value num can take is 16. The default value is equal to the value of the PDIGITS= option plus 7.","help":"PWIDTH=*number*","type":"value"},{"name":"VARFUZZ=","optional":true,"description":"Specifies the smallest difference that is permitted by the OPTMODEL presolver between the upper and lower bounds of an unfixed variable.","help":"VARFUZZ=*number*","type":"value"}]},{"name":"CALL","description":"The CALL statement invokes the named library subroutine. The values that are determined for each argument expression are passed to the subroutine when the subroutine is invoked. The subroutine can update the values of PROC OPTMODEL parameters and variables when an argument is an identifier-expression.","help":"CALL name ( argument-1 [, ...argument-n] )"},{"name":"CLOSEFILE","description":"The CLOSEFILE statement closes files that were opened by the FILE statement. Each file is specified by a logical name, a physical filename in quotation marks, or an expression enclosed in parentheses that evaluates to a physical filename.","help":"CLOSEFILE file-specification(s)"},{"name":"COFOR","description":"The COFOR statement executes its statement for each member of the specified index-set , similar to how the FOR statement executes. However, in a COFOR statement, PROC OPTMODEL can execute the SOLVE statement concurrently with other statements. The execution of the COFOR substatement is interleaved between loop iterations so that other iterations can be processed while an iteration waits for a SOLVE statement to complete. Multiple solvers can run concurrently. This interleaving is managed so that in many cases a FOR loop can be replaced by a COFOR loop to achieve concurrency with minimal or no other changes to the code.","help":"COFOR { index-set } statement"},{"name":"CONSTRAINT","aliases":["CON"],"description":"The constraint declaration defines one or more constraints on expressions in terms of the optimization variables. You can specify multiple constraint declaration statements. Constraints can have an upper bound, a lower bound, or both bounds. The allowed forms are as follows: [ name [ { index-set } ] : ] expression = expression [ name [ { index-set } ] : ] expression relation expression [ name [ { index-set } ] : ] bound relation body relation bound where: name defines the name for the constraint. relation is the ≤ or ≥ operator. index-set declares a family of equality/inequality/range constraints expression is any valid SAS expression bound defines the lower/upper bound body refers to a body expression","help":"CONSTRAINT constraint [, ...constraint]"},{"name":"CONTINUE","description":"The CONTINUE statement terminates the current iteration of the loop statement (iterative DO, DO UNTIL, DO WHILE, or FOR) that immediately contains the CONTINUE statement. Execution resumes at the start of the loop after checking WHILE or UNTIL tests. The FOR or iterative DO loops apply new iteration values.","help":"CONTINUE "},{"name":"CREATE DATA","description":"The CREATE DATA statement creates a new SAS data set and copies data into it from PROC OPTMODEL parameters and variables. The arguments to the CREATE DATA statement are as follows: SAS-data-set specifies the output data set name and options. You can specify the data set name and options directly or as the string value of an expression enclosed in parentheses. key-columns declares index values and their corresponding data set variables. The values are used to index array locations in columns. key-set specifies a set of index values for the key-columns. columns specifies data set variables as well as the PROC OPTMODEL source data for the variables.","help":"CREATE DATA &lt;FROM [[ key-column(s) ] [ =key-set ] ] column(s)&gt; ","arguments":[{"name":"FROM","optional":true,"description":"Keyword for specifying the source columns from which the data is created.","type":"standalone"}]},{"name":"DO","description":"The DO statement groups a sequence of statements together as a single statement.","help":"DO ; statement(s) ; END"},{"name":"DO UNTIL","description":"The DO UNTIL loop executes the specified sequence of statements repeatedly until the logic-expression, evaluated after the statements, returns true (a nonmissing nonzero value).","help":"DO UNTIL ( logic-expression ) ; statement(s) ; END"},{"name":"DO WHILE","description":"The DO WHILE loop executes the specified sequence of statements repeatedly as long as the logic-expression, evaluated before the statements, returns true (a nonmissing nonzero value).","help":"DO WHILE ( logic-expression ) ; statement(s) ; END"},{"name":"DROP","description":"The DROP statement causes the solver to ignore the specified constraint, constraint array, or constraint array location. The identifier-expression specifies the dropped constraint.","help":"DROP identifier-expression"},{"name":"ELSE","description":"If the condition in a IF-THEN statement is false and an ELSE statement is present, then the ELSE action is carried out.","help":"ELSE &lt;DO&gt; &lt;IF&gt; &lt;THEN&gt; ...","arguments":[{"name":"AND","optional":true,"description":"","type":"standalone"},{"name":"DO","optional":true,"description":"Action statement in an IF-THEN-ELSE construct.","type":"standalone"},{"name":"IF","optional":true,"description":"Executes a SAS statement for observations that meet specific conditions.","type":"standalone"},{"name":"NOT","optional":true,"description":"","type":"standalone"},{"name":"OR","optional":true,"description":"","type":"standalone"},{"name":"OUTPUT","optional":true,"description":"Action statement in an IF-THEN-ELSE construct.","type":"standalone"},{"name":"THEN","optional":true,"description":"If the conditions that are specified in the IF clause are met, the IF-THEN statement executes a SAS statement for observations that are read from a SAS data set, for records in an external file, or for computed values.","type":"standalone"}]},{"name":"END","description":"Ends DO group processing.","help":"END"},{"name":"ENDSUBMIT","description":"Ends a SUBMIT block.","help":"ENDSUBMIT"},{"name":"EXPAND","description":"The EXPAND statement prints the specified constraint, variable, or objective declaration expressions after expanding aggregation operators, substituting the current value for parameters and indices, and resolving constant subexpressions. Identifier-expression is the name of a variable, objective, or constraint.","help":"EXPAND &lt;FIX&gt; &lt;SOLVE&gt; &lt;VAR&gt; ...","arguments":[{"name":"CONSTRAINT","optional":true,"followsDelimiter":"/","aliases":["CON"],"description":"Requests the output of undropped constraints.","type":"standalone"},{"name":"FIX","optional":true,"followsDelimiter":"/","description":"Requests the output of fixed variables. These variables might have been fixed by the FIX statement (or by the presolver if the SOLVE option is specified).","type":"standalone"},{"name":"IIS","optional":true,"followsDelimiter":"/","description":"Restricts the display to items found in the irreducible infeasible set (IIS) after the most recent SOLVE performed by the LP solver with the IIS=ON option.","type":"standalone"},{"name":"IMPVAR","optional":true,"followsDelimiter":"/","description":"Requests the output of implicit variables referenced in the current problem.","type":"standalone"},{"name":"OBJECTIVE","optional":true,"followsDelimiter":"/","aliases":["OBJ"],"description":"Requests the output of objectives. Only the most recent objective seen in a MAX or MIN declaration or specified in a SOLVE statement is considered when the SOLVE option is used.","type":"standalone"},{"name":"OMITTED","optional":true,"followsDelimiter":"/","description":"Requests the output of variables that are referenced by problem equations but were not included in the current USE PROBLEM instance. The OPTMODEL procedure omits these variables from the generated problem.","type":"standalone"},{"name":"SOLVE","optional":true,"followsDelimiter":"/","description":"Causes the EXPAND statement to print the variables, objectives, and constraints in the same form that would be seen by the solver if a SOLVE statement were executed.","type":"standalone"},{"name":"VAR","optional":true,"followsDelimiter":"/","description":"Requests the output of unfixed variables.","type":"standalone"}]},{"name":"FILE","description":"The FILE statement selects the current output file for the PUT statement.","help":"FILE &lt;LRECL=value&gt; ","arguments":[{"name":"LRECL=","optional":true,"description":"Sets the line length of the output file. If the option is omitted, then the line length defaults to 256 characters.","help":"LRECL=*value*","type":"value"}]},{"name":"FIX","description":"The FIX statement causes the solver to treat a list of variables, variable arrays, or variable array locations as fixed in value. The identifier-list consists of one or more variable names separated by spaces. Each member of the identifier-list is fixed to the same expression.","help":"FIX identifier-list [ =( expression ) ]"},{"name":"FOR","description":"The FOR statement executes its substatement for each member of the specified index-set. The index set can declare local dummy parameters. You can reference the value of these parameters in the substatement. CAUTION: Avoid modifying the parameters that are used by the FOR statement index set from within the substatement. The set value that is used for the left-most index set item is not affected by such changes. However, the effect of parameter changes on later index set items cannot be predicted.","help":"FOR { index-set } statement "},{"name":"IF","description":"","help":"IF &lt;DO&gt; &lt;THEN&gt; &lt;WHEN&gt; ...","arguments":[{"name":"AND","optional":true,"description":"","type":"standalone"},{"name":"DO","optional":true,"description":"Action statement in an IF-THEN construct.","type":"standalone"},{"name":"GO","optional":true,"aliases":["GOTO"],"description":"Jumps to a new statement.","help":"GO TO","type":"standalone"},{"name":"NOT","optional":true,"description":"","type":"standalone"},{"name":"OR","optional":true,"description":"","type":"standalone"},{"name":"OUTPUT","optional":true,"description":"Action statement in an IF-THEN construct.","type":"standalone"},{"name":"PUT","optional":true,"description":"Action statement in an IF-THEN construct.","type":"standalone"},{"name":"SET","optional":true,"description":"Reads an observation from one or more SAS data sets.","type":"standalone"},{"name":"STOP","optional":true,"description":"Action statement in an IF-THEN construct. Stops execution of the current DATA step.","type":"standalone"},{"name":"THEN","optional":true,"description":"If the conditions that are specified in the IF clause are met, the IF-THEN statement executes a SAS statement for observations that are read from a SAS data set, for records in an external file, or for computed values.","type":"standalone"},{"name":"WHEN","optional":true,"description":"WHEN statement in an IF-THEN-WHEN construct.","type":"standalone"}]},{"name":"IMPVAR","description":"The IMPVAR statement declares one or more names that refer to optimization expressions in the model. The declared name is called an implicit variable. An implicit variable is useful for structuring models so that complex expressions do not need to be repeated each time they are used. The value of an implicit variable needs to be computed only once instead 'of at each place where the original expression is used, which helps reduce computational overhead. Implicit variables are evaluated without intervention from the solver. Multiple IMPVAR statements are allowed. The names of implicit variables must be distinct from other model declarations, such as variables and constraints. Implicit variables can be used in model expressions in the same places where ordinary variables are allowed. This is the syntax for an impvar-decl: name [ { index-set } ] = expression ; Each impvar-decl declares a name for an implicit variable. The name can be followed by an index-set specification to declare a family of implicit variables. The expression referenced by the name follows. Dummy parameters declared in the index-set specification can be used in the expression. The expression can reference other model components, including variables and other implicit variables.","help":"IMPVAR impvar-decl [, ...impvar-decl] "},{"name":"LEAVE","description":"The LEAVE statement terminates the execution of the entire loop body (iterative DO, DO UNTIL, DO WHILE, or FOR) that immediately contains the LEAVE statement. Execution resumes at the statement that follows the loop.","help":"LEAVE "},{"name":"MAX","aliases":["MAXIMIZE"],"description":"The MAX or MIN declaration specifies an objective for the solver. The name names the objective function for later reference. The solver maximizes an objective specified with the MAX keyword.","help":"MAX name = expression"},{"name":"MIN","aliases":["MINIMIZE"],"description":"The MIN declaration specifies an objective for the solver. The name names the objective function for later reference. The solver minimizes an objective specified with the MIN keyword.","help":"MIN name = expression"},{"name":"NUMBER","aliases":["NUM"],"description":"Declaration of parameters that have a NUMBER type.","help":"NUMBER &lt;INIT expression&gt; ","arguments":[{"name":"INIT","optional":true,"description":"Specifies a default value that is used when a parameter value is required but no other value has been supplied.","type":"standalone"}]},{"name":"PERFORMANCE","description":"The PERFORMANCE statement defines performance parameters for multithreaded and distributed computing, passes variables about the distributed computing environment, and requests detailed results about the performance characteristics of a High-Performance Analytics procedure. With the PERFORMANCE statement, you can also control whether the HPNLIN procedure executes in SMP or MPP mode.","help":"PERFORMANCE &lt;DETAILS&gt; &lt;NTHREADS=&lt;&lt;num&gt; | CPUCOUNT&gt;&gt; &lt;PARALLELMODE=&lt;DETERMINISTIC|0 | NONDETERMINISTIC|1&gt;&gt; ...","arguments":[{"name":"DETAILS","optional":true,"description":"Requests that the procedure produce the Timing ODS table. This table shows a breakdown of the time used in each step of the procedure.","type":"standalone"},{"name":"NTHREADS=","optional":true,"description":"Specifies the number of threads that a procedure can use. It overrides the SAS system option THREADS | NOTHREADS. The value of number can be any integer between 1 and 256 inclusive. The default value is CPUCOUNT, which sets the thread count to the number that is determined by the SAS system option CPUCOUNT=.","help":"NTHREADS=&lt;*num*&gt; | CPUCOUNT","type":"choice","arguments":[{"name":"num","placeholder":true,"description":"Replace <num> with an actual number. The value of number can be any integer between 1 and 256 inclusive. The default value is CPUCOUNT, which sets the thread count to the number that is determined by the SAS system option CPUCOUNT=.","type":"value"},{"name":"CPUCOUNT","description":"The default value is CPUCOUNT, which sets the thread count to the number that is determined by the SAS system option CPUCOUNT=","type":"standalone"}]},{"name":"PARALLELMODE=","optional":true,"description":"Specifies the parallel processing mode. This mode determines the solution results that are obtained from running the same model with the same option values on the same platform multiple times.","help":"PARALLELMODE=DETERMINISTIC|0 | NONDETERMINISTIC|1","type":"choice","arguments":[{"name":"DETERMINISTIC","description":"Requires algorithms to produce the same results every time.","help":"DETERMINISTIC|0","type":"choice"},{"name":"NONDETERMINISTIC","description":"Permits algorithms to produce different solution results. This mode requires less synchronization and might attain better performance than DETERMINISTIC mode.","help":"NONDETERMINISTIC|1","type":"choice"}]}]},{"name":"PRINT","description":"The PRINT statement outputs string and numeric data in tabular form. The statement specifies a list of arrays or other data items to print. Multiple items can be output together as data columns in the same table.","help":"PRINT &lt;_PAGE_&gt; ","arguments":[{"name":"_PAGE_","optional":true,"description":"Specifies a page break.","type":"standalone"}]},{"name":"PROBLEM","description":"Problems are declared with the PROBLEM declaration. Problem declarations track an objective, a set of included variables and constraints, and some status information that is associated with the variables and constraints. The problem name can optionally be followed by an index-set to create a family of problems. When a problem is first used (via the USE PROBLEM statement), the specifications from the optional FROM and INCLUDE clauses create the initial set of included variables, constraints, and the problem objective. An empty problem is created if neither clause is specified. The clauses are applied only when the problem is first used with the USE PROBLEM statement.","help":"PROBLEM &lt;FROM&gt; &lt;INCLUDE&gt; ","arguments":[{"name":"FROM","optional":true,"description":"Specifies an existing problem from which to copy the included symbols. The problem-id is an identifier expression. The dropped and fixed status for these symbols in the specified problem is also copied.","type":"standalone"},{"name":"INCLUDE","optional":true,"description":"Specifies a list of variables, constraints, and objectives to include in the problem. These items are included with default status (unfixed and undropped) which overrides the status from the FROM clause, if it exists. Each item is specified with one of the following forms: identifier-expression includes the specified items in the problem. The identifier-expression can be a symbol name or an array symbol with explicit index. If an array symbol is used without an index, then all array elements are included.","type":"standalone"}]},{"name":"PROFILE","description":"Syntax:","help":"PROFILE &lt;OFF&gt; &lt;ON&gt; &lt;PRINT&gt; ...","arguments":[{"name":"OFF","optional":true,"description":"Disables the profiler. Note that the profiler is disabled when PROC OPTMODEL begins execution.","type":"standalone"},{"name":"ON","optional":true,"description":"Enables the profiler. Data are collected until the profiler is disabled or PROC OPTMODEL terminates. The profiler is also enabled when no mode is specified in a PROFILE statement.","type":"standalone"},{"name":"PERCENT=","optional":true,"description":"Restricts the output for PROFILE PRINT to items whose net times account for at least the specified percentage of total profiled time, (total time x number) / 100. Items that have smaller times are aggregated into a single item at the end of the table. You can set this option before the display of profile data, and it does not affect the data collection. The value of number can range from 0 to 100. The default value is 1.","help":"PERCENT=*number*","type":"value"},{"name":"PRINT","optional":true,"description":"Prints the current accumulated profiler data. Items for declarations and statements are displayed in a table in descending order of their net time. Accumulated data are printed automatically when PROC OPTMODEL terminates.","type":"standalone"},{"name":"RESET","optional":true,"description":"Discards accumulated profiler data when the PROFILE statement completes execution. Accumulated data are retained until they are explicitly reset.","type":"standalone"},{"name":"STMTDEPTH=","optional":true,"description":"Allows collection of profiler data for nested statements. With the default option, STMTDEPTH=1, profiler data are collected only for top-level statements. The elapsed time for nested statement timing is included in the top-level statement timing. For example, time for a top-level FOR statement would include the execution of its substatement. Use the STMTDEPTH= option to profile the nested statements individually. The value number specifies the maximum nesting depth at which to profile statements individually. The nesting depth of a top-level statement is 1. Otherwise the nesting depth of a statement is one more than the nesting depth of the statement that encloses it, such as a DO , IF , or FOR statement.","help":"STMTDEPTH=&lt;*number*&gt; | ALL","type":"choice","arguments":[{"name":"number","placeholder":true,"description":"Replace <num> with an actual number. The value of number can be any integer between 1 and 256 inclusive. The default value is CPUCOUNT, which sets the thread count to the number that is determined by the SAS system option CPUCOUNT=.","type":"value"},{"name":"ALL","description":"The default value is CPUCOUNT, which sets the thread count to the number that is determined by the SAS system option CPUCOUNT=","type":"standalone"}]}]},{"name":"PUT","description":"The PUT statement writes text data to the current output file. The syntax of the PUT statement in PROC OPTMODEL is similar to the syntax of the PROC IML and DATA step PUT statements.","help":"PUT &lt;_PAGE_&gt; ","arguments":[{"name":"_PAGE_","optional":true,"description":"Outputs any pending line data and moves to the top of the next page.","type":"standalone"}]},{"name":"READ DATA","description":"The READ DATA statement reads data from a SAS data set into PROC OPTMODEL parameter and variable locations. The arguments to the READ DATA statement are as follows: SAS-data-set specifies the input data set name and options. You can specify the data set name and options directly or as the string value of an expression enclosed in parentheses. set-name specifies a set parameter in which to save the set of observation key values read from the input data set. read-key-columns provide the index values for array destinations. read-columns specify the data values to read and the destination locations.","help":"READ DATA &lt;INTO&gt; NOMISS &lt;TRIM&gt; ...","arguments":[{"name":"NOMISS","description":"Exclude missing values.","type":"standalone"},{"name":"INTO","optional":true,"description":"","type":"standalone"},{"name":"LTRIM","optional":true,"aliases":["LT"],"description":"Removes only leading blanks from the data set value.","type":"standalone"},{"name":"NOTRIM","optional":true,"aliases":["NT"],"description":"Copies the data set value with no changes.","type":"standalone"},{"name":"RTRIM","optional":true,"aliases":["RT"],"description":"Removes only trailing blanks from the data set value.","type":"standalone"},{"name":"TRIM","optional":true,"aliases":["TR"],"description":"Removes leading and trailing blanks from the data set value. This is the default behavior.","type":"standalone"}]},{"name":"RESET OPTIONS","aliases":["RESET OPTION"],"description":"The RESET OPTIONS statement sets PROC OPTMODEL option values or restores them to their defaults. Options can be specified by using the same syntax as in the PROC OPTMODEL statement. The RESET OPTIONS statement provides two extensions to the option syntax. If an option normally requires a value (specified with an equal sign (=) operator), then specifying the option name alone resets it to its default value. You can also specify an expression enclosed in parentheses in place of a literal value.","help":"RESET OPTIONS &lt;CDIGITS=number&gt; &lt;ERRORLIMIT=&lt;&lt;number&gt; | NONE&gt;&gt; &lt;FD=&lt;FORWARD | CENTRAL&gt;&gt; ...","arguments":[{"name":"CDIGITS=","optional":true,"description":"Specifies the expected number of decimal digits of accuracy for nonlinear constraints. The value can be fractional.","help":"CDIGITS=*number*","type":"value"},{"name":"ERRORLIMIT=","optional":true,"description":"Specifies the maximum number of error messages that can be displayed. Specifying a value of number in the range 1 to 2³¹-1 sets a specific limit. Specifying ERRORLIMIT=NONE removes any existing limit.","help":"ERRORLIMIT=&lt;*number*&gt; | NONE","type":"choice","arguments":[{"name":"number","placeholder":true,"description":"Replace <number> with an actual number in the range 1 to 2³¹-1 to set a specific limit.","type":"value"},{"name":"NONE","description":"Specifying ERRORLIMIT=NONE removes any existing limit.","type":"standalone"}]},{"name":"FD=","optional":true,"description":"Selects the method used to approximate numeric derivatives when analytic derivatives are unavailable.","help":"FD=FORWARD | CENTRAL","type":"choice","arguments":[{"name":"FORWARD","description":"Use forward differences","type":"standalone"},{"name":"CENTRAL","description":"Use central differences","type":"standalone"}]},{"name":"FDIGITS=","optional":true,"description":"Specifies the expected number of decimal digits of accuracy for the objective function. The value can be fractional.","help":"FDIGITS=*number*","type":"value"},{"name":"FORCEFD=","optional":true,"description":"Forces PROC OPTMODEL to use finite differences instead of analytic derivatives for the specified set of nonlinear expressions. This option can be useful with FCMP functions to provide more control over derivative computation.","help":"FORCEFD=ALL | CON | NONE | OBJ","type":"choice","arguments":[{"name":"ALL","description":"Restricts all derivative computations to use finite differences.","type":"standalone"},{"name":"CON","description":"Restricts derivative computations for the nonlinear constraint expressions and any IMPVAR expressions they reference to use finite differences.","type":"standalone"},{"name":"NONE","description":"Requests analytic derivatives where they are available.","type":"standalone"},{"name":"OBJ","description":"Restricts derivative computations for the objective and any IMPVAR expressions it references to use finite differences.","type":"standalone"}]},{"name":"FORCEPRESOLVE=","optional":true,"description":"specifies whether PROC OPTMODEL can use the OPTMODEL presolver with the CLP, LP, MILP, and QP solvers. By default, the OPTMODEL presolver is disabled when PROC OPTMODEL solves linear problems or problems with predicates, or when the CLP, LP, MILP, or QP solver is specified in the SOLVE statement. Table 5.4 shows the valid values for this option. Table 5.4: Values for the FORCEPRESOLVE= Option number string Description 0 OFF Restores the default behavior. 1 ON Enables PROC OPTMODEL to use the OPTMODEL presolver when the CLP, LP, MILP, or QP solver is specified in the SOLVE statement.","type":"value"},{"name":"INITVAR","optional":true,"description":"Selects to pass initial values for variables to the solver when the SOLVE statement is executed.","type":"standalone"},{"name":"INTFUZZ=","optional":true,"description":"Specifies the tolerance for rounding the bounds on integer and binary variables to integer values.","help":"INTFUZZ=*number*","type":"value"},{"name":"MAXLABLEN=","optional":true,"description":"Specifies the maximum length for MPS row and column labels. The allowed range is 8 to 256, with 32 as the default.","help":"MAXLABLEN=*number*","type":"value"},{"name":"MISSCHECK","optional":true,"description":"Requests that a message be produced each time PROC OPTMODEL evaluates an arithmetic operation or built-in function that has missing value operands (except when the operation or function specifically supports missing values).","type":"standalone"},{"name":"MSGLIMIT=","optional":true,"description":"Specifies the maximum number of non-error messages that can be displayed, including notes and warnings. Specifying a value of number in the range 1 to 2³¹-1 sets a specific limit. Specifying ERRORLIMIT=NONE removes any existing limit.","help":"MSGLIMIT=&lt;*number*&gt; | NONE","type":"choice","arguments":[{"name":"number","placeholder":true,"description":"Replace <number> with an actual number in the range 1 to 2³¹-1 to set a specific limit.","type":"value"},{"name":"NONE","description":"Specifying ERRORLIMIT=NONE removes any existing limit.","type":"standalone"}]},{"name":"NOINITVAR","optional":true,"description":"Causes the solver to be invoked without any specific initial values for variables.","type":"standalone"},{"name":"NOMISSCHECK","optional":true,"description":"Turns off detailed checking of missing values in expressions. This is the default.","type":"standalone"},{"name":"PDIGITS=","optional":true,"description":"Requests that the PRINT statement display num significant digits for numeric columns for which no format is specified. The value can range from 1 to 9. The default is 5.","help":"PDIGITS=*number*","type":"value"},{"name":"PMATRIX=","optional":true,"description":"Adjusts the density evaluation of a two-dimensional array to affect how it is displayed. The value num scales the total number of nonempty array elements and is used by the PRINT statement to evaluate whether a two-dimensional array is \"sparse\" or \"dense\".","help":"PMATRIX=*number*","type":"value"},{"name":"PRESOLVER=","optional":true,"description":"Specifies a presolve option.","help":"PRESOLVER=NONE | AUTOMATIC | BASIC | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"NONE","description":"Disable presolver.","type":"standalone"},{"name":"AUTOMATIC","description":"Apply presolver using default setting.","type":"standalone"},{"name":"BASIC","description":"Perform minimal processing, only substituting fixed variables and removing empty feasible constraints.","type":"standalone"},{"name":"MODERATE","description":"Apply a higher level of presolve processing..","type":"standalone"},{"name":"AGGRESSIVE","description":"Apply the highest level of presolve processing.","type":"standalone"}]},{"name":"PRESTOL=","optional":true,"description":"Provides a tolerance so that slightly infeasible constraints can be eliminated by the OPTMODEL presolver.","help":"PRESTOL=*number*","type":"value"},{"name":"PRINTLEVEL=","optional":true,"description":"Controls the level of listing output during a SOLVE command.","help":"PRINTLEVEL=0 | 1 | 2","type":"choice","arguments":[{"name":"0","description":"Disable all tables.","type":"standalone"},{"name":"1","description":"Print Problem Summary and Solution Summary.","type":"standalone"},{"name":"2","description":"Print Problem Summary, Solution Summary, Methods of Derivative Computation (for NLP solvers), Solver Options, Optimization Statistics and solver-specific ODS tables.","type":"standalone"}]},{"name":"PWIDTH=","optional":true,"description":"Sets the width used by the PRINT statement to display numeric columns when no format is specified. The smallest value num can take is the value of the PDIGITS= option plus 7; the largest value num can take is 16. The default value is equal to the value of the PDIGITS= option plus 7.","help":"PWIDTH=*number*","type":"value"},{"name":"VARFUZZ=","optional":true,"description":"Specifies the smallest difference that is permitted by the OPTMODEL presolver between the upper and lower bounds of an unfixed variable.","help":"VARFUZZ=*number*","type":"value"}]},{"name":"RESTORE","description":"The RESTORE statement adds a constraint, constraint array, or constraint array location that was dropped by the DROP statement back into the solver model. Identifier-expression specifies the constraint. An entire constraint array is restored if the identifier-expression omits the index from an array name.","help":"RESTORE identifier-expression"},{"name":"SAVE MPS","description":"The SAVE MPS statement saves the structure and coefficients for a linear programming model into a SAS data set. This data set can be used as input data for the OPTLP or OPTMILP procedure. NOTE: The OPTMODEL presolver is automatically bypassed so that the statement saves the original model without eliminating fixed variables, tightening bounds, and so on. The SAS-data-set argument specifies the output data set name and options. The generated data set contains observations that define different parts of the linear program. Variables, constraints, and objectives are referenced in the data set by using label text from the corresponding .label suffix value. The default text is based on the name in the model. Labels are limited by default to 32 characters and are abbreviated to fit. You can change the maximum length for labels by using the MAXLABLEN= option. When needed, a programmatically generated number is added to labels to avoid duplication. The current problem objective is included in the data set. If the OBJECTIVE keyword is used, then the problem objective becomes the specified objective.","help":"SAVE MPS SAS-data-set  ( OBJECTIVE | OBJ ) name  "},{"name":"SAVE QPS","description":"The SAVE QPS statement saves the structure and coefficients for a quadratic programming model into a SAS data set. This data set can be used as input data for the OPTQP procedure. NOTE: The OPTMODEL presolver is automatically bypassed so that the statement saves the original model without eliminating fixed variables, tightening bounds, and so on. The SAS-data-set argument specifies the output data set name and options. The generated data set contains observations that define different parts of the quadratic program. Variables, constraints, and objectives are referenced in the data set by using label text from the corresponding .label suffix value. The default text is based on the name in the model. Labels are limited by default to 32 characters and are abbreviated to fit. You can change the maximum length for labels by using the MAXLABLEN= option. When needed, a programmatically generated number is added to labels to avoid duplication. If the OBJECTIVE keyword is used, the objective name becomes the current problem objective. If the NOOBJECTIVE keyword is used or the current problem does not have an objective, then the data set includes a default constant zero objective. Otherwise, the current problem objective is included in the data set. The quadratic coefficients of the objective function appear in the QSECTION section of the output data set.","help":"SAVE QPS NOOBJECTIVE OBJECTIVE ","arguments":[{"name":"NOOBJECTIVE","aliases":["NOOBJ"],"description":"If the NOOBJECTIVE keyword is used or the current problem does not have an objective, then the data set includes a default constant zero objective. Otherwise, the current problem objective is included in the data set.","type":"standalone"},{"name":"OBJECTIVE","aliases":["OBJ"],"description":"If the OBJECTIVE keyword is used, the objective name becomes the current problem objective.","type":"standalone"}]},{"name":"SET","description":"Declaration of parameters that have a SET type.","help":"SET &lt;INIT expression&gt; &lt;NUMBER&gt; &lt;STRING&gt; ...","arguments":[{"name":"INIT","optional":true,"description":"Specifies a default value that is used when a parameter value is required but no other value has been supplied.","type":"standalone"},{"name":"NUMBER","optional":true,"aliases":["NUM"],"description":"[Number type declaration","type":"standalone"},{"name":"STRING","optional":true,"aliases":["STR"],"description":"[String type declaration","type":"standalone"}]},{"name":"SOLVE","description":"The SOLVE statement invokes a PROC OPTMODEL solver. solver selects the named solver: LP, MILP, QP, or NLP. If no WITH clause is specified, then a solver is chosen automatically, depending on the problem type. name specifies the objective to use. This sets the current objective for the problem. You can abbreviate the OBJECTIVE keyword as OBJ. If this argument is not specified, then the problem objective is unchanged. RELAXINT requests that any integral variables be relaxed to be continuous. RELAXINT can be used with linear and nonlinear problems in addition to any solver. options specifies solver options. You can specify solver options directly only when you use the WITH clause. A list of the options available with the solver is provided in the individual chapters that describe each solver.","help":"SOLVE OBJECTIVE RELAXINT WITH ...","arguments":[{"name":"CLP","description":"Solver for Constraint Programming using constraint propagation and backtracking search algorithm","type":"standalone"},{"name":"IPNLP","description":"Solver for General Nonlinear Programming.","type":"standalone"},{"name":"LP","description":"Solver for Linear Programming using dual simplex algorithm.","type":"standalone"},{"name":"MILP","description":"Solver for Mixed Integer Linear Programming using branch-and-cut algorithm.","type":"standalone"},{"name":"NLP","description":"The sparse nonlinear programming (NLP) solver is a component of the OPTMODEL procedure that can solve optimization problems containing both nonlinear equality and inequality constraints.","type":"standalone"},{"name":"NLPC","description":"Solver for General Nonlinear Programming.","type":"standalone"},{"name":"NLPU","description":"Solver for Nonlinear Programming, Unconstrained.","type":"standalone"},{"name":"NOOBJECTIVE","aliases":["NOOBJ"],"description":"Requests that the solver ignore the current objective for the problem and use a constant zero objective instead. This keyword enables the solver to process the current model as a feasibility problem.","type":"standalone"},{"name":"OBJECTIVE","aliases":["OBJ"],"description":"A keyword used when specifying the name of the objective to use.","type":"standalone"},{"name":"QP","description":"Solver for Quadratic Programming.","type":"standalone"},{"name":"RELAXINT","description":"Requests that any integral variables be relaxed to be continuous. RELAXINT can be used with linear and nonlinear problems in addition to any solver.","type":"standalone"},{"name":"SQP","description":"Solver for General Nonlinear Programming.","type":"standalone"},{"name":"WITH","description":"A keyword used when specifying the name of the solver to use.","type":"standalone"}]},{"name":"SOLVE WITH CLP","description":"The SOLVE WITH CLP statement invokes the CLP solver.","help":"SOLVE WITH CLP NOOBJECTIVE OBJECTIVE RELAXINT ...","arguments":[{"name":"NOOBJECTIVE","aliases":["NOOBJ"],"description":"Requests that the solver ignore the current objective for the problem and use a constant zero objective instead. This keyword enables the solver to process the current model as a feasibility problem.","type":"standalone"},{"name":"OBJECTIVE","aliases":["OBJ"],"description":"A keyword used when specifying the name of the objective to use.","type":"standalone"},{"name":"RELAXINT","description":"Requests that any integral variables be relaxed to be continuous. RELAXINT can be used with linear and nonlinear problems in addition to any solver.","type":"standalone"},{"name":"FINDALLSOLNS","optional":true,"followsDelimiter":"/","aliases":["ALLSOLNS","FINDALL"],"description":"Attempts to find all possible solutions to the CSP.","type":"standalone"},{"name":"MAXSOLNS=","optional":true,"followsDelimiter":"/","description":"Specifies the number of solution attempts to be generated for the CSP. By default, MAXSOLNS=1.","help":"MAXSOLNS=*number*","type":"value"},{"name":"MAXTIME=","optional":true,"followsDelimiter":"/","description":"Specifies the maximum time to spend calculating results. The type of time (either CPU time or real time) is determined by the value of the TIMETYPE= option. The value of number can be any positive number; the default value is the positive number that has the largest absolute value that can be represented in your operating environment.","help":"MAXTIME=*number*","type":"value"},{"name":"NOPREPROCESS","optional":true,"followsDelimiter":"/","description":"[Suppresses any preprocessing that would usually be performed for the problem.","type":"standalone"},{"name":"OBJTOL=","optional":true,"followsDelimiter":"/","description":"Specifies the tolerance of the objective value. By default, OBJTOL=1E–6.","help":"OBJTOL=*number*","type":"value"},{"name":"PREPROCESS","optional":true,"followsDelimiter":"/","description":"[Permits any preprocessing that would usually be performed for the problem.","type":"standalone"},{"name":"SHOWPROGRESS","optional":true,"followsDelimiter":"/","description":"Prints a message to the log whenever a solution is found.","type":"standalone"},{"name":"TIMETYPE=","optional":true,"followsDelimiter":"/","description":"Specifies whether to use CPU time or real time for the MAXTIME= option. The following describes the valid values of the TIMETYPE= option. number string Description 0 CPU Specifies units of CPU time 1 REAL Specifies units of real time","type":"value"},{"name":"VARASSIGN=","optional":true,"followsDelimiter":"/","description":"Specifies the variable assignment strategy. You can specify two value selection strategies: MAX, which selects the maximum value from the domain of the selected variable MIN, which selects the minimum value from the domain of the selected variable","help":"VARASSIGN=MAX | MIN*string*","type":"value","arguments":[{"name":"MAX","followsDelimiter":"/","description":"Selects the maximum value from the domain of the selected variable.","type":"standalone"},{"name":"MIN","followsDelimiter":"/","description":"Selects the minimum value from the domain of the selected variable.","type":"standalone"}]},{"name":"VARSELECT=","optional":true,"followsDelimiter":"/","description":"Specifies the variable selection strategy. The strategy could be static, dynamic, or conflict-directed. Typically, static strategies exploit information about the initial state of the search, whereas dynamic strategies exploit information about the current state of the search process. Conflict-directed strategies exploit information from previous states of the search process as well as the current state (Boussemart et al. 2004).","help":"VARSELECT=FIFO | MAXCS | DOMDDEG | DOMDEG | MAXC | MINR | MINRMAXC | DOMWDEG | WDEG*string*","type":"value","arguments":[{"name":"FIFO","followsDelimiter":"/","description":"Uses the first-in, first-out ordering of the variables as encountered by the procedure after adjusting for the values in the .priority suffix","type":"standalone"},{"name":"MAXCS","followsDelimiter":"/","description":"Selects the variable that has the maximum number of constraints","type":"standalone"},{"name":"DOMDDEG","followsDelimiter":"/","description":"Selects the variable that has the smallest ratio of domain size to dynamic degree","type":"standalone"},{"name":"DOMDEG","followsDelimiter":"/","description":"Selects the variable that has the smallest ratio of domain size to degree","type":"standalone"},{"name":"MAXC","followsDelimiter":"/","description":"Selects the variable that has the largest number of active constraints","type":"standalone"},{"name":"MINR","followsDelimiter":"/","description":"Selects the variable that has the smallest range (that is, the minimum value of the upper bound minus the lower bound)","type":"standalone"},{"name":"MINRMAXC","followsDelimiter":"/","description":"Selects the variable that has the smallest range, breaking ties by selecting one that has the largest number of active constraints","type":"standalone"},{"name":"DOMWDEG","followsDelimiter":"/","description":"Selects the variable that has the smallest ratio of domain size to weighted degree","type":"standalone"},{"name":"WDEG","followsDelimiter":"/","description":"Selects the variable that has the largest weighted degree","type":"standalone"}]}]},{"name":"SOLVE WITH IPNLP","description":"The interior point nonlinear programming (IPNLP) solver component of the OPTMODEL procedure can solve nonlinear programming (NLP) problems that contain both nonlinear equality and inequality constraints.","help":"SOLVE WITH IPNLP NOOBJECTIVE OBJECTIVE RELAXINT ...","arguments":[{"name":"NOOBJECTIVE","aliases":["NOOBJ"],"description":"Requests that the solver ignore the current objective for the problem and use a constant zero objective instead. This keyword enables the solver to process the current model as a feasibility problem.","type":"standalone"},{"name":"OBJECTIVE","aliases":["OBJ"],"description":"A keyword used when specifying the name of the objective to use.","type":"standalone"},{"name":"RELAXINT","description":"Requests that any integral variables be relaxed to be continuous. RELAXINT can be used with linear and nonlinear problems in addition to any solver.","type":"standalone"},{"name":"MAXITER=","optional":true,"followsDelimiter":"/","description":"Specifies that the solver take at most N major iterations to determine an optimum of the NLP problem. The value of N is an integer between zero and the largest four-byte, signed integer, which is 2^31-1. A major iteration in IPNLP consists of finding a descent direction and a step size along which the next approximation of the optimum will reside. The default value of N is 5,000 iterations.","help":"MAXITER=*N*","type":"value"},{"name":"MAXTIME=","optional":true,"followsDelimiter":"/","description":"Specifies an upper limit of T seconds of real time for the solver to find a local optimum. Note that the time specified by the MAXTIME= option is checked only once at the end of each major iteration. The default value is 7,200 seconds (two hours).","help":"MAXTIME=*T*","type":"value"},{"name":"OBJLIMIT=","optional":true,"followsDelimiter":"/","description":"Specifies an upper limit on the magnitude of the objective value. For a minimization problem, the algorithm terminates when the objective value becomes less than -M; for a maximization problem, the algorithm stops when the objective value exceeds M.","help":"OBJLIMIT=*M*","type":"value"},{"name":"OPTOL=","optional":true,"followsDelimiter":"/","aliases":["RELOPTOL="],"description":"Defines the measure by which you can decide whether the current iterate is an acceptable approximation of a local minimum. The value of this option is a positive real number. The IPNLP solver determines that the current iterate is a local minimum when the norm of the scaled vector of the optimality conditions is less than є. The default value is є=1E–6.","type":"value"},{"name":"TECHNIQUE=","optional":true,"followsDelimiter":"/","aliases":["TECH=","SOLVER="],"description":"Specifies the optimization technique.","help":"TECHNIQUE=IPKRYLOV | IPQN","type":"choice","arguments":[{"name":"IPKRYLOV","followsDelimiter":"/","description":"Uses a trust-region interior point method. This technique is recommended for large-scale optimization problems (that is, problems with many variables and constraints).","type":"standalone"},{"name":"IPQN","followsDelimiter":"/","description":"Uses a quasi-Newton interior point method. This technique can efficiently solve small-to-medium size optimization problems (that is, problems that contain up to 1,000 variables and constraints). It is recommended for problems whose second derivatives are computationally expensive to compute.","type":"standalone"}]}]},{"name":"SOLVE WITH LP","description":"Statement for specifying and solving linear programs (LPs).","help":"SOLVE WITH LP NOOBJECTIVE OBJECTIVE RELAXINT ...","arguments":[{"name":"NOOBJECTIVE","aliases":["NOOBJ"],"description":"Requests that the solver ignore the current objective for the problem and use a constant zero objective instead. This keyword enables the solver to process the current model as a feasibility problem.","type":"standalone"},{"name":"OBJECTIVE","aliases":["OBJ"],"description":"A keyword used when specifying the name of the objective to use.","type":"standalone"},{"name":"RELAXINT","description":"Requests that any integral variables be relaxed to be continuous. RELAXINT can be used with linear and nonlinear problems in addition to any solver.","type":"standalone"},{"name":"ALGORITHM2=","optional":true,"followsDelimiter":"/","aliases":["SOLVER2=","SOL2="],"description":"Specifies an LP algorithm if ALGORITHM=NETWORK (NS):.","help":"ALGORITHM2=PRIMAL | DUAL","type":"choice","arguments":[{"name":"PRIMAL","followsDelimiter":"/","description":"Uses primal simplex algorithm (after network simplex).","type":"standalone"},{"name":"DUAL","followsDelimiter":"/","description":"Uses dual simplex algorithm (after network simplex).","type":"standalone"}]},{"name":"ALGORITHM=","optional":true,"followsDelimiter":"/","aliases":["SOLVER=","SOL="],"description":"Specifies an LP algorithm.","help":"ALGORITHM=PRIMAL | DUAL | NETWORK | INTERIORPOINT | CONCURRENT","type":"choice","arguments":[{"name":"PRIMAL","followsDelimiter":"/","description":"Uses primal simplex algorithm.","type":"standalone"},{"name":"DUAL","followsDelimiter":"/","description":"Uses dual simplex algorithm.","type":"standalone"},{"name":"NETWORK","followsDelimiter":"/","description":"Uses network simplex algorithm.","type":"standalone"},{"name":"INTERIORPOINT","followsDelimiter":"/","description":"Uses interior point algorithm.","type":"standalone"},{"name":"CONCURRENT","followsDelimiter":"/","description":"Uses several different algorithms in parallel.","type":"standalone"}]},{"name":"BASIS=","optional":true,"followsDelimiter":"/","description":"Specifies one of three available options for generating an initial basis.","help":"BASIS=CRASH | SLACK | WARMSTART","type":"choice","arguments":[{"name":"CRASH","followsDelimiter":"/","description":"Generate an initial basis by using crash techniques (Maros 2003). The procedure creates a triangular basic matrix consisting of both decision variables and slack variables. This is the default setting.","type":"standalone"},{"name":"SLACK","followsDelimiter":"/","description":"Generate an initial basis by using all slack variables.","type":"standalone"},{"name":"WARMSTART","followsDelimiter":"/","description":"Start the simplex solvers with a user-specified initial basis. The PRIMALIN= and DUALIN= data sets are required to specify an initial basis.","type":"standalone"}]},{"name":"CROSSOVER=","optional":true,"followsDelimiter":"/","description":"Specifies whether to convert the interior point solution to a basic simplex solution.","help":"CROSSOVER=OFF | ON","type":"choice","arguments":[{"name":"OFF","followsDelimiter":"/","description":"Disable crossover.","type":"standalone"},{"name":"ON","followsDelimiter":"/","description":"Apply the crossover algorithm to the interior point solution.","type":"standalone"}]},{"name":"DECOMP=","optional":true,"followsDelimiter":"/","description":"Enables the decomposition algorithm and specifies overall control options for the algorithm.","help":"DECOMP=BLOCKS= | ABSOBJGAP= | COMPRESSFREQ= | HYBRID= | INITVARS= | LOGLEVEL= | MAXBLOCKS= | MAXCOLSPASS= | MAXTIME= | METHOD= | NBLOCKS= | NTHREADS= | RELOBJGAP= | LOGFREQ= | MASTER_IP_BEG= | MASTER_IP_END= | MASTER_IP_FREQ= | MAXITER=","type":"choice","arguments":[{"name":"BLOCKS=","type":"value"},{"name":"ABSOBJGAP=","type":"value"},{"name":"COMPRESSFREQ=","type":"value"},{"name":"HYBRID=","type":"value"},{"name":"INITVARS=","type":"value"},{"name":"LOGLEVEL=","type":"value"},{"name":"MAXBLOCKS=","type":"value"},{"name":"MAXCOLSPASS=","type":"value"},{"name":"MAXTIME=","type":"value"},{"name":"METHOD=","type":"value"},{"name":"NBLOCKS=","type":"value"},{"name":"NTHREADS=","type":"value"},{"name":"RELOBJGAP=","type":"value"},{"name":"LOGFREQ=","type":"value"},{"name":"MASTER_IP_BEG=","type":"value"},{"name":"MASTER_IP_END=","type":"value"},{"name":"MASTER_IP_FREQ=","type":"value"},{"name":"MAXITER=","type":"value"}]},{"name":"DECOMPMASTER=","optional":true,"followsDelimiter":"/","description":"Specifies options for the master problem.","help":"DECOMPMASTER=BLOCKS= | ABSOBJGAP= | COMPRESSFREQ= | HYBRID= | INITVARS= | LOGLEVEL= | MAXBLOCKS= | MAXCOLSPASS= | MAXTIME= | METHOD= | NBLOCKS= | NTHREADS= | RELOBJGAP= | LOGFREQ= | MASTER_IP_BEG= | MASTER_IP_END= | MASTER_IP_FREQ= | MAXITER= | INITPRESOLVER= | INITPRESOL=","type":"choice","arguments":[{"name":"BLOCKS=","type":"value"},{"name":"ABSOBJGAP=","type":"value"},{"name":"COMPRESSFREQ=","type":"value"},{"name":"HYBRID=","type":"value"},{"name":"INITVARS=","type":"value"},{"name":"LOGLEVEL=","type":"value"},{"name":"MAXBLOCKS=","type":"value"},{"name":"MAXCOLSPASS=","type":"value"},{"name":"MAXTIME=","type":"value"},{"name":"METHOD=","type":"value"},{"name":"NBLOCKS=","type":"value"},{"name":"NTHREADS=","type":"value"},{"name":"RELOBJGAP=","type":"value"},{"name":"LOGFREQ=","type":"value"},{"name":"MASTER_IP_BEG=","type":"value"},{"name":"MASTER_IP_END=","type":"value"},{"name":"MASTER_IP_FREQ=","type":"value"},{"name":"MAXITER=","type":"value"},{"name":"INITPRESOLVER=","type":"value"},{"name":"INITPRESOL=","type":"value"}]},{"name":"DECOMPMASTERIP=","optional":true,"followsDelimiter":"/","description":"Specifies options for the (restricted) master problem solved as a MILP with the current set of columns in an effort to obtain an integer feasible solution.","help":"DECOMPMASTERIP=BLOCKS= | ABSOBJGAP= | COMPRESSFREQ= | HYBRID= | INITVARS= | LOGLEVEL= | MAXBLOCKS= | MAXCOLSPASS= | MAXTIME= | METHOD= | NBLOCKS= | NTHREADS= | RELOBJGAP= | LOGFREQ= | MASTER_IP_BEG= | MASTER_IP_END= | MASTER_IP_FREQ= | MAXITER=","type":"choice","arguments":[{"name":"BLOCKS=","type":"value"},{"name":"ABSOBJGAP=","type":"value"},{"name":"COMPRESSFREQ=","type":"value"},{"name":"HYBRID=","type":"value"},{"name":"INITVARS=","type":"value"},{"name":"LOGLEVEL=","type":"value"},{"name":"MAXBLOCKS=","type":"value"},{"name":"MAXCOLSPASS=","type":"value"},{"name":"MAXTIME=","type":"value"},{"name":"METHOD=","type":"value"},{"name":"NBLOCKS=","type":"value"},{"name":"NTHREADS=","type":"value"},{"name":"RELOBJGAP=","type":"value"},{"name":"LOGFREQ=","type":"value"},{"name":"MASTER_IP_BEG=","type":"value"},{"name":"MASTER_IP_END=","type":"value"},{"name":"MASTER_IP_FREQ=","type":"value"},{"name":"MAXITER=","type":"value"}]},{"name":"DECOMPSUBPROB=","optional":true,"followsDelimiter":"/","description":"Specifies option for the subproblem.","help":"DECOMPSUBPROB=BLOCKS= | ABSOBJGAP= | COMPRESSFREQ= | HYBRID= | INITVARS= | LOGLEVEL= | MAXBLOCKS= | MAXCOLSPASS= | MAXTIME= | METHOD= | NBLOCKS= | NTHREADS= | RELOBJGAP= | LOGFREQ= | MASTER_IP_BEG= | MASTER_IP_END= | MASTER_IP_FREQ= | MAXITER=","type":"choice","arguments":[{"name":"BLOCKS=","type":"value"},{"name":"ABSOBJGAP=","type":"value"},{"name":"COMPRESSFREQ=","type":"value"},{"name":"HYBRID=","type":"value"},{"name":"INITVARS=","type":"value"},{"name":"LOGLEVEL=","type":"value"},{"name":"MAXBLOCKS=","type":"value"},{"name":"MAXCOLSPASS=","type":"value"},{"name":"MAXTIME=","type":"value"},{"name":"METHOD=","type":"value"},{"name":"NBLOCKS=","type":"value"},{"name":"NTHREADS=","type":"value"},{"name":"RELOBJGAP=","type":"value"},{"name":"LOGFREQ=","type":"value"},{"name":"MASTER_IP_BEG=","type":"value"},{"name":"MASTER_IP_END=","type":"value"},{"name":"MASTER_IP_FREQ=","type":"value"},{"name":"MAXITER=","type":"value"}]},{"name":"DUALIZE=","optional":true,"followsDelimiter":"/","description":"Controls the dualization of the problem.","help":"DUALIZE=AUTOMATIC | OFF | ON","type":"choice","arguments":[{"name":"AUTOMATIC","followsDelimiter":"/","description":"The presolver uses a heuristic to decide whether to dualize the problem or not.","type":"standalone"},{"name":"OFF","followsDelimiter":"/","description":"Disables dualization. The optimization problem is solved in the form that you specify.","type":"standalone"},{"name":"ON","followsDelimiter":"/","description":"The presolver formulates the dual of the linear optimization problem.","type":"standalone"}]},{"name":"FEASTOL=","optional":true,"followsDelimiter":"/","description":"Specifies the feasibility tolerance for determining the feasibility of a variable value. The default value is 1E-6.","type":"value"},{"name":"IIS=","optional":true,"followsDelimiter":"/","description":"Specifies whether the LP solver attempts to identify a set of constraints and variables that form an irreducible infeasible set (IIS).","help":"IIS=OFF | ON","type":"choice","arguments":[{"name":"OFF","followsDelimiter":"/","description":"Disables IIS detection. This is the default.","type":"standalone"},{"name":"ON","followsDelimiter":"/","description":"Enables IIS detection.","type":"standalone"}]},{"name":"LOGFREQ=","optional":true,"followsDelimiter":"/","aliases":["PRINTFREQ="],"description":"Specifies that the printing of the solution progress to the iteration log is to occur after every k iterations.","type":"value"},{"name":"LOGLEVEL=","optional":true,"followsDelimiter":"/","aliases":["PRINTFREQ2="],"description":"Controls the amount of information displayed in the SAS log by the LP solver, from a short description of presolve information and summary to details at each iteration.","help":"LOGLEVEL=NONE | BASIC | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"NONE","followsDelimiter":"/","description":"Turns off all solver-related messages to SAS log.","type":"standalone"},{"name":"BASIC","followsDelimiter":"/","description":"Displays a solver summary after stopping.","type":"standalone"},{"name":"MODERATE","followsDelimiter":"/","description":"Prints a solver summary and an iteration log by using the interval dictated by the LOGFREQ= option.","type":"standalone"},{"name":"AGGRESSIVE","followsDelimiter":"/","description":"Prints a detailed solver summary and an iteration log by using the interval dictated by the LOGFREQ= option.","type":"standalone"}]},{"name":"MAXITER=","optional":true,"followsDelimiter":"/","description":"Specifies the maximum number of iterations.","help":"MAXITER=*k*","type":"value"},{"name":"MAXTIME=","optional":true,"followsDelimiter":"/","description":"Specifies an upper limit of k seconds of real time for reading in the data and performing the optimization process.","help":"MAXTIME=*k*","type":"value"},{"name":"OPTTOL=","optional":true,"followsDelimiter":"/","description":"Specifies the optimality tolerance for declaring optimality. The default value is 1E-6.","type":"value"},{"name":"PRESOLVER=","optional":true,"followsDelimiter":"/","description":"Specifies a presolve option.","help":"PRESOLVER=NONE | AUTOMATIC | BASIC | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"NONE","followsDelimiter":"/","description":"Disable presolver.","type":"standalone"},{"name":"AUTOMATIC","followsDelimiter":"/","description":"Apply presolver by using default setting.","type":"standalone"},{"name":"BASIC","followsDelimiter":"/","description":"Perform basic presolve like removing empty rows, columns, and fixed variables.","type":"standalone"},{"name":"MODERATE","followsDelimiter":"/","description":"Perform basic presolve and apply other inexpensive presolve techniques.","type":"standalone"},{"name":"AGGRESSIVE","followsDelimiter":"/","description":"Perform moderate presolve and apply other aggressive (but expensive) presolve techniques.","type":"standalone"}]},{"name":"PRICETYPE=","optional":true,"followsDelimiter":"/","description":"Specifies one of 5 available pricing strategies for the simplex solvers.","help":"PRICETYPE=HYBRID | PARTIAL | FULL | DEVEX | STEEPESTEDGE","type":"choice","arguments":[{"name":"HYBRID","followsDelimiter":"/","description":"Use a hybrid of Devex and steepest-edge pricing strategies. Available for the primal simplex solver only.","type":"standalone"},{"name":"PARTIAL","followsDelimiter":"/","description":"Use the Dantzig's rule on a queue of decision variables. Optionally, you can specify QUEUESIZE=. Available for the primal simplex solver only.","type":"standalone"},{"name":"FULL","followsDelimiter":"/","description":"Use the Dantzig's rule on all decision variables.","type":"standalone"},{"name":"DEVEX","followsDelimiter":"/","description":"Use Devex pricing strategy.","type":"standalone"},{"name":"STEEPESTEDGE","followsDelimiter":"/","description":"Use steepest-edge pricing strategy.","type":"standalone"}]},{"name":"QUEUESIZE=","optional":true,"followsDelimiter":"/","description":"Specifies the queue size. The default value is chosen adaptively based on the number of decision variables. This option is used only when PRICETYPE=PARTIAL.","help":"QUEUESIZE=*k*","type":"value"},{"name":"SCALE=","optional":true,"followsDelimiter":"/","description":"Specifies a scaling option.","help":"SCALE=NONE | AUTOMATIC","type":"choice","arguments":[{"name":"NONE","followsDelimiter":"/","description":"Disable scaling.","type":"standalone"},{"name":"AUTOMATIC","followsDelimiter":"/","description":"Automatically apply scaling procedure if necessary.","type":"standalone"}]},{"name":"SEED=","optional":true,"followsDelimiter":"/","description":"Specifies the initial seed for the random number generator.","help":"SEED=*number*","type":"value"},{"name":"STOP_DG=","optional":true,"followsDelimiter":"/","description":"Specifies the desired relative duality gap, δ ϵ [1E–9, 1E–4]. This is the relative difference between the primal and dual objective function values and is the primary solution quality parameter. The default value is 1E–6.","type":"value"},{"name":"STOP_DI=","optional":true,"followsDelimiter":"/","description":"Specifies the maximum allowed relative dual constraints violation, β ϵ [1E–9, 1E–4]. The default value is 1E–6.","type":"value"},{"name":"STOP_PI=","optional":true,"followsDelimiter":"/","description":"Specifies the maximum allowed relative bound and primal constraints violation, α ϵ [1E–9, 1E–4]. The default value is 1E–6.","type":"value"},{"name":"TIMETYPE=","optional":true,"followsDelimiter":"/","description":"Specifies the units of time used by the MAXTIME= option and reported by the PRESOLVE_TIME and SOLUTION_TIME terms in the _OROPTMODEL_ macro variable.","help":"TIMETYPE=CPU | REAL","type":"choice","arguments":[{"name":"CPU","followsDelimiter":"/","description":"Uses CPU time. This is the default.","type":"standalone"},{"name":"REAL","followsDelimiter":"/","description":"Uses real time.","type":"standalone"}]}]},{"name":"SOLVE WITH MILP","description":"Statement for specifying and solving mixed integer linear programs (MILPs).","help":"SOLVE WITH MILP NOOBJECTIVE OBJECTIVE RELAXINT ...","arguments":[{"name":"NOOBJECTIVE","aliases":["NOOBJ"],"description":"Requests that the solver ignore the current objective for the problem and use a constant zero objective instead. This keyword enables the solver to process the current model as a feasibility problem.","type":"standalone"},{"name":"OBJECTIVE","aliases":["OBJ"],"description":"A keyword used when specifying the name of the objective to use.","type":"standalone"},{"name":"RELAXINT","description":"Requests that any integral variables be relaxed to be continuous. RELAXINT can be used with linear and nonlinear problems in addition to any solver.","type":"standalone"},{"name":"ABSOBJGAP=","optional":true,"followsDelimiter":"/","description":"Specifies a stopping criterion. When the absolute difference between the best integer objective and the objective of the best node remaining falls below the value of num, the procedure stops. The value of num can be any positive number; the default value is 1E-6.","help":"ABSOBJGAP=*number*","type":"value"},{"name":"ALLCUTS=","optional":true,"followsDelimiter":"/","description":"Provides a shorthand way of setting all the cuts-related options in one setting. In other words, ALLCUTS=num is equivalent to setting each of the individual cuts parameters to the same value num.","help":"ALLCUTS=AUTOMATIC | NONE | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"AUTOMATIC","followsDelimiter":"/","description":"Generate cutting planes based on a strategy determined by the MILP solver.","type":"standalone"},{"name":"NONE","followsDelimiter":"/","description":"Disable generation of cutting planes.","type":"standalone"},{"name":"MODERATE","followsDelimiter":"/","description":"Use a moderate cut strategy.","type":"standalone"},{"name":"AGGRESSIVE","followsDelimiter":"/","description":"Use an aggressive cut strategy.","type":"standalone"}]},{"name":"CONFLICTSEARCH=","optional":true,"followsDelimiter":"/","description":"Specifies the level of conflict search performed by the MILP solver.","help":"CONFLICTSEARCH=AUTOMATIC | NONE | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"AUTOMATIC","followsDelimiter":"/","description":"Performs conflict search based on a strategy determined by the MILP solver","type":"standalone"},{"name":"NONE","followsDelimiter":"/","description":"Disables conflict search","type":"standalone"},{"name":"MODERATE","followsDelimiter":"/","description":"Performs a moderate conflict search","type":"standalone"},{"name":"AGGRESSIVE","followsDelimiter":"/","description":"Performs an aggressive conflict search","type":"standalone"}]},{"name":"CUTCLIQUE=","optional":true,"followsDelimiter":"/","description":"Specifies the level of clique cuts generated by the MILP solver.","help":"CUTCLIQUE=AUTOMATIC | NONE | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"AUTOMATIC","followsDelimiter":"/","description":"Generate cutting planes based on a strategy determined by the MILP solver.","type":"standalone"},{"name":"NONE","followsDelimiter":"/","description":"Disable generation of cutting planes.","type":"standalone"},{"name":"MODERATE","followsDelimiter":"/","description":"Use a moderate cut strategy.","type":"standalone"},{"name":"AGGRESSIVE","followsDelimiter":"/","description":"Use an aggressive cut strategy.","type":"standalone"}]},{"name":"CUTFLOWCOVER=","optional":true,"followsDelimiter":"/","description":"Specifies the level of flow cover cuts generated by the MILP solver.","help":"CUTFLOWCOVER=AUTOMATIC | NONE | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"AUTOMATIC","followsDelimiter":"/","description":"Generate cutting planes based on a strategy determined by the MILP solver.","type":"standalone"},{"name":"NONE","followsDelimiter":"/","description":"Disable generation of cutting planes.","type":"standalone"},{"name":"MODERATE","followsDelimiter":"/","description":"Use a moderate cut strategy.","type":"standalone"},{"name":"AGGRESSIVE","followsDelimiter":"/","description":"Use an aggressive cut strategy.","type":"standalone"}]},{"name":"CUTFLOWPATH=","optional":true,"followsDelimiter":"/","description":"Specifies the level of flow path cuts generated by the MILP solver.","help":"CUTFLOWPATH=AUTOMATIC | NONE | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"AUTOMATIC","followsDelimiter":"/","description":"Generate cutting planes based on a strategy determined by the MILP solver.","type":"standalone"},{"name":"NONE","followsDelimiter":"/","description":"Disable generation of cutting planes.","type":"standalone"},{"name":"MODERATE","followsDelimiter":"/","description":"Use a moderate cut strategy.","type":"standalone"},{"name":"AGGRESSIVE","followsDelimiter":"/","description":"Use an aggressive cut strategy.","type":"standalone"}]},{"name":"CUTGOMORY=","optional":true,"followsDelimiter":"/","description":"Specifies the level of Gomory cuts generated by the MILP solver.","help":"CUTGOMORY=AUTOMATIC | NONE | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"AUTOMATIC","followsDelimiter":"/","description":"Generate cutting planes based on a strategy determined by the MILP solver.","type":"standalone"},{"name":"NONE","followsDelimiter":"/","description":"Disable generation of cutting planes.","type":"standalone"},{"name":"MODERATE","followsDelimiter":"/","description":"Use a moderate cut strategy.","type":"standalone"},{"name":"AGGRESSIVE","followsDelimiter":"/","description":"Use an aggressive cut strategy.","type":"standalone"}]},{"name":"CUTGUB=","optional":true,"followsDelimiter":"/","description":"Specifies the level of generalized upper bound (GUB) cover cuts generated by the MILP solver.","help":"CUTGUB=AUTOMATIC | NONE | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"AUTOMATIC","followsDelimiter":"/","description":"Generate cutting planes based on a strategy determined by the MILP solver.","type":"standalone"},{"name":"NONE","followsDelimiter":"/","description":"Disable generation of cutting planes.","type":"standalone"},{"name":"MODERATE","followsDelimiter":"/","description":"Use a moderate cut strategy.","type":"standalone"},{"name":"AGGRESSIVE","followsDelimiter":"/","description":"Use an aggressive cut strategy.","type":"standalone"}]},{"name":"CUTIMPLIED=","optional":true,"followsDelimiter":"/","description":"Specifies the level of implied bound cuts generated by the MILP solver.","help":"CUTIMPLIED=AUTOMATIC | NONE | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"AUTOMATIC","followsDelimiter":"/","description":"Generate cutting planes based on a strategy determined by the MILP solver.","type":"standalone"},{"name":"NONE","followsDelimiter":"/","description":"Disable generation of cutting planes.","type":"standalone"},{"name":"MODERATE","followsDelimiter":"/","description":"Use a moderate cut strategy.","type":"standalone"},{"name":"AGGRESSIVE","followsDelimiter":"/","description":"Use an aggressive cut strategy.","type":"standalone"}]},{"name":"CUTKNAPSACK=","optional":true,"followsDelimiter":"/","description":"Specifies the level of knapsack cover cuts generated by the MILP solver.","help":"CUTKNAPSACK=AUTOMATIC | NONE | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"AUTOMATIC","followsDelimiter":"/","description":"Generate cutting planes based on a strategy determined by the MILP solver.","type":"standalone"},{"name":"NONE","followsDelimiter":"/","description":"Disable generation of cutting planes.","type":"standalone"},{"name":"MODERATE","followsDelimiter":"/","description":"Use a moderate cut strategy.","type":"standalone"},{"name":"AGGRESSIVE","followsDelimiter":"/","description":"Use an aggressive cut strategy.","type":"standalone"}]},{"name":"CUTLAP=","optional":true,"followsDelimiter":"/","description":"Specifies the level of lift-and-project (LAP) cuts generated by the MILP solver.","help":"CUTLAP=AUTOMATIC | NONE | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"AUTOMATIC","followsDelimiter":"/","description":"Generate cutting planes based on a strategy determined by the MILP solver.","type":"standalone"},{"name":"NONE","followsDelimiter":"/","description":"Disable generation of cutting planes.","type":"standalone"},{"name":"MODERATE","followsDelimiter":"/","description":"Use a moderate cut strategy.","type":"standalone"},{"name":"AGGRESSIVE","followsDelimiter":"/","description":"Use an aggressive cut strategy.","type":"standalone"}]},{"name":"CUTMILIFTED=","optional":true,"followsDelimiter":"/","description":"Specifies the level of mixed lifted 0-1 cuts that are generated by the MILP solver.","help":"CUTMILIFTED=AUTOMATIC | NONE | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"AUTOMATIC","followsDelimiter":"/","description":"Generate cutting planes based on a strategy determined by the MILP solver.","type":"standalone"},{"name":"NONE","followsDelimiter":"/","description":"Disable generation of cutting planes.","type":"standalone"},{"name":"MODERATE","followsDelimiter":"/","description":"Use a moderate cut strategy.","type":"standalone"},{"name":"AGGRESSIVE","followsDelimiter":"/","description":"Use an aggressive cut strategy.","type":"standalone"}]},{"name":"CUTMIR=","optional":true,"followsDelimiter":"/","description":"Specifies the level of mixed integer rounding (MIR) cuts generated by the MILP solver.","help":"CUTMIR=AUTOMATIC | NONE | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"AUTOMATIC","followsDelimiter":"/","description":"Generate cutting planes based on a strategy determined by the MILP solver.","type":"standalone"},{"name":"NONE","followsDelimiter":"/","description":"Disable generation of cutting planes.","type":"standalone"},{"name":"MODERATE","followsDelimiter":"/","description":"Use a moderate cut strategy.","type":"standalone"},{"name":"AGGRESSIVE","followsDelimiter":"/","description":"Use an aggressive cut strategy.","type":"standalone"}]},{"name":"CUTMULTICOMMODITY=","optional":true,"followsDelimiter":"/","description":"","help":"CUTMULTICOMMODITY=AUTOMATIC | NONE | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"AUTOMATIC","followsDelimiter":"/","description":"Generate cutting planes based on a strategy determined by the MILP solver.","type":"standalone"},{"name":"NONE","followsDelimiter":"/","description":"Disable generation of cutting planes.","type":"standalone"},{"name":"MODERATE","followsDelimiter":"/","description":"Use a moderate cut strategy.","type":"standalone"},{"name":"AGGRESSIVE","followsDelimiter":"/","description":"Use an aggressive cut strategy.","type":"standalone"}]},{"name":"CUTOFF=","optional":true,"followsDelimiter":"/","description":"Cuts off any nodes in a minimization (maximization) problem with an objective value above (below) num. The value of num can be any number; the default value is the positive (negative) number that has the largest absolute value representable in your operating environment.","help":"CUTOFF=*number*","type":"value"},{"name":"CUTSFACTOR=","optional":true,"followsDelimiter":"/","description":"Specifies a row multiplier factor for cuts. The number of cuts added is limited to num times the original number of rows. The value of num can be any nonnegative number less than or equal to 100; the default value is 3.0.","help":"CUTSFACTOR=*m*","type":"value"},{"name":"CUTSTRATEGY=","optional":true,"followsDelimiter":"/","aliases":["CUTS="],"description":"Specifies the overall aggressiveness of the cut generation in the solver. Setting a nondefault value adjusts a number of cut parameters such that the cut generation is basic, moderate, or aggressive compared to the default value.","help":"CUTSTRATEGY=AUTOMATIC | NONE | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"AUTOMATIC","followsDelimiter":"/","description":"Generate cutting planes based on a strategy determined by the MILP solver.","type":"standalone"},{"name":"NONE","followsDelimiter":"/","description":"Disable generation of cutting planes.","type":"standalone"},{"name":"MODERATE","followsDelimiter":"/","description":"Use a moderate cut strategy.","type":"standalone"},{"name":"AGGRESSIVE","followsDelimiter":"/","description":"Use an aggressive cut strategy.","type":"standalone"}]},{"name":"CUTZEROHALF=","optional":true,"followsDelimiter":"/","description":"","help":"CUTZEROHALF=AUTOMATIC | NONE | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"AUTOMATIC","followsDelimiter":"/","description":"Generate cutting planes based on a strategy determined by the MILP solver.","type":"standalone"},{"name":"NONE","followsDelimiter":"/","description":"Disable generation of cutting planes.","type":"standalone"},{"name":"MODERATE","followsDelimiter":"/","description":"Use a moderate cut strategy.","type":"standalone"},{"name":"AGGRESSIVE","followsDelimiter":"/","description":"Use an aggressive cut strategy.","type":"standalone"}]},{"name":"DECOMP=","optional":true,"followsDelimiter":"/","description":"Enables the decomposition algorithm and specifies overall control options for the algorithm.","help":"DECOMP=BLOCKS= | ABSOBJGAP= | COMPRESSFREQ= | HYBRID= | INITVARS= | LOGLEVEL= | MAXBLOCKS= | MAXCOLSPASS= | MAXTIME= | METHOD= | NBLOCKS= | NTHREADS= | RELOBJGAP= | LOGFREQ= | MASTER_IP_BEG= | MASTER_IP_END= | MASTER_IP_FREQ= | MAXITER=","type":"choice","arguments":[{"name":"BLOCKS=","type":"value"},{"name":"ABSOBJGAP=","type":"value"},{"name":"COMPRESSFREQ=","type":"value"},{"name":"HYBRID=","type":"value"},{"name":"INITVARS=","type":"value"},{"name":"LOGLEVEL=","type":"value"},{"name":"MAXBLOCKS=","type":"value"},{"name":"MAXCOLSPASS=","type":"value"},{"name":"MAXTIME=","type":"value"},{"name":"METHOD=","type":"value"},{"name":"NBLOCKS=","type":"value"},{"name":"NTHREADS=","type":"value"},{"name":"RELOBJGAP=","type":"value"},{"name":"LOGFREQ=","type":"value"},{"name":"MASTER_IP_BEG=","type":"value"},{"name":"MASTER_IP_END=","type":"value"},{"name":"MASTER_IP_FREQ=","type":"value"},{"name":"MAXITER=","type":"value"}]},{"name":"DECOMPMASTER=","optional":true,"followsDelimiter":"/","description":"Specifies options for the master problem.","help":"DECOMPMASTER=BLOCKS= | ABSOBJGAP= | COMPRESSFREQ= | HYBRID= | INITVARS= | LOGLEVEL= | MAXBLOCKS= | MAXCOLSPASS= | MAXTIME= | METHOD= | NBLOCKS= | NTHREADS= | RELOBJGAP= | LOGFREQ= | MASTER_IP_BEG= | MASTER_IP_END= | MASTER_IP_FREQ= | MAXITER= | INITPRESOLVER= | INITPRESOL=","type":"choice","arguments":[{"name":"BLOCKS=","type":"value"},{"name":"ABSOBJGAP=","type":"value"},{"name":"COMPRESSFREQ=","type":"value"},{"name":"HYBRID=","type":"value"},{"name":"INITVARS=","type":"value"},{"name":"LOGLEVEL=","type":"value"},{"name":"MAXBLOCKS=","type":"value"},{"name":"MAXCOLSPASS=","type":"value"},{"name":"MAXTIME=","type":"value"},{"name":"METHOD=","type":"value"},{"name":"NBLOCKS=","type":"value"},{"name":"NTHREADS=","type":"value"},{"name":"RELOBJGAP=","type":"value"},{"name":"LOGFREQ=","type":"value"},{"name":"MASTER_IP_BEG=","type":"value"},{"name":"MASTER_IP_END=","type":"value"},{"name":"MASTER_IP_FREQ=","type":"value"},{"name":"MAXITER=","type":"value"},{"name":"INITPRESOLVER=","type":"value"},{"name":"INITPRESOL=","type":"value"}]},{"name":"DECOMPMASTERIP=","optional":true,"followsDelimiter":"/","description":"Specifies options for the (restricted) master problem solved as a MILP with the current set of columns in an effort to obtain an integer feasible solution.","help":"DECOMPMASTERIP=BLOCKS= | ABSOBJGAP= | COMPRESSFREQ= | HYBRID= | INITVARS= | LOGLEVEL= | MAXBLOCKS= | MAXCOLSPASS= | MAXTIME= | METHOD= | NBLOCKS= | NTHREADS= | RELOBJGAP= | LOGFREQ= | MASTER_IP_BEG= | MASTER_IP_END= | MASTER_IP_FREQ= | MAXITER=","type":"choice","arguments":[{"name":"BLOCKS=","type":"value"},{"name":"ABSOBJGAP=","type":"value"},{"name":"COMPRESSFREQ=","type":"value"},{"name":"HYBRID=","type":"value"},{"name":"INITVARS=","type":"value"},{"name":"LOGLEVEL=","type":"value"},{"name":"MAXBLOCKS=","type":"value"},{"name":"MAXCOLSPASS=","type":"value"},{"name":"MAXTIME=","type":"value"},{"name":"METHOD=","type":"value"},{"name":"NBLOCKS=","type":"value"},{"name":"NTHREADS=","type":"value"},{"name":"RELOBJGAP=","type":"value"},{"name":"LOGFREQ=","type":"value"},{"name":"MASTER_IP_BEG=","type":"value"},{"name":"MASTER_IP_END=","type":"value"},{"name":"MASTER_IP_FREQ=","type":"value"},{"name":"MAXITER=","type":"value"}]},{"name":"DECOMPSUBPROB=","optional":true,"followsDelimiter":"/","description":"Specifies option for the subproblem.","help":"DECOMPSUBPROB=BLOCKS= | ABSOBJGAP= | COMPRESSFREQ= | HYBRID= | INITVARS= | LOGLEVEL= | MAXBLOCKS= | MAXCOLSPASS= | MAXTIME= | METHOD= | NBLOCKS= | NTHREADS= | RELOBJGAP= | LOGFREQ= | MASTER_IP_BEG= | MASTER_IP_END= | MASTER_IP_FREQ= | MAXITER=","type":"choice","arguments":[{"name":"BLOCKS=","type":"value"},{"name":"ABSOBJGAP=","type":"value"},{"name":"COMPRESSFREQ=","type":"value"},{"name":"HYBRID=","type":"value"},{"name":"INITVARS=","type":"value"},{"name":"LOGLEVEL=","type":"value"},{"name":"MAXBLOCKS=","type":"value"},{"name":"MAXCOLSPASS=","type":"value"},{"name":"MAXTIME=","type":"value"},{"name":"METHOD=","type":"value"},{"name":"NBLOCKS=","type":"value"},{"name":"NTHREADS=","type":"value"},{"name":"RELOBJGAP=","type":"value"},{"name":"LOGFREQ=","type":"value"},{"name":"MASTER_IP_BEG=","type":"value"},{"name":"MASTER_IP_END=","type":"value"},{"name":"MASTER_IP_FREQ=","type":"value"},{"name":"MAXITER=","type":"value"}]},{"name":"EMPHASIS=","optional":true,"followsDelimiter":"/","description":"Specifies a search emphasis option.","help":"EMPHASIS=BALANCE | OPTIMAL | FEASIBLE","type":"choice","arguments":[{"name":"BALANCE","followsDelimiter":"/","description":"Perform a balanced search.","type":"standalone"},{"name":"OPTIMAL","followsDelimiter":"/","description":"Emphasize optimality over feasibility.","type":"standalone"},{"name":"FEASIBLE","followsDelimiter":"/","description":"Emphasize feasibility over optimality.","type":"standalone"}]},{"name":"FEASTOL=","optional":true,"followsDelimiter":"/","description":"Specifies the tolerance that the MILP solver uses to check the feasibility of a solution.","help":"FEASTOL=*number*","type":"value"},{"name":"HEURISTICS=","optional":true,"followsDelimiter":"/","description":"Enables the user to control the level of primal heuristics applied by the MILP solver.","help":"HEURISTICS=AUTOMATIC | NONE | BASIC | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"AUTOMATIC","followsDelimiter":"/","description":"Apply default level of heuristics, similar to MODERATE.","type":"standalone"},{"name":"NONE","followsDelimiter":"/","description":"Disable all primal heuristics.","type":"standalone"},{"name":"BASIC","followsDelimiter":"/","description":"Apply basic primal heuristics at low frequency.","type":"standalone"},{"name":"MODERATE","followsDelimiter":"/","description":"Apply most primal heuristics at moderate frequency.","type":"standalone"},{"name":"AGGRESSIVE","followsDelimiter":"/","description":"Apply all primal heuristics at high frequency.","type":"standalone"}]},{"name":"INTTOL=","optional":true,"followsDelimiter":"/","description":"Specifies the amount by which an integer variable value can differ from an integer and still be considered integer feasible. The value of num can be any number between 0.0 and 1.0; the default value is 1E-5.","help":"INTTOL=*number*","type":"value"},{"name":"LOGFREQ=","optional":true,"followsDelimiter":"/","aliases":["PRINTFREQ="],"description":"Specifies how often information is printed in the node log. The value of number can be any nonnegative integer up to the largest four-byte signed integer, which is 2³¹-1.","type":"value"},{"name":"LOGLEVEL=","optional":true,"followsDelimiter":"/","aliases":["PRINTLEVEL2="],"description":"Controls the amount of information displayed in the SAS log by the MILP solver, from a short description of presolve information and summary to details at each node.","help":"LOGLEVEL=NONE | BASIC | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"NONE","followsDelimiter":"/","description":"Turn off all solver-related messages in SAS log.","type":"standalone"},{"name":"BASIC","followsDelimiter":"/","description":"Display a solver summary after stopping.","type":"standalone"},{"name":"MODERATE","followsDelimiter":"/","description":"Print a solver summary and a node log by using the interval dictated by the PRINTFREQ= option.","type":"standalone"},{"name":"AGGRESSIVE","followsDelimiter":"/","description":"Print a detailed solver summary and a node log by using the interval dictated by the PRINTFREQ= option.","type":"standalone"}]},{"name":"MAXNODES=","optional":true,"followsDelimiter":"/","description":"Specifies the maximum number of branch-and-bound nodes to be processed. The value of num can be any nonnegative integer up to the largest four-byte signed integer, which is 2³¹-1. The default value is 2³¹-1.","help":"MAXNODES=*number*","type":"value"},{"name":"MAXSOLS=","optional":true,"followsDelimiter":"/","description":"Specifies a stopping criterion. If num solutions have been found, then the procedure stops. The value of num can be any positive integer up to the largest four-byte signed integer, which is 2³¹-1. The default value is 2³¹-1.","help":"MAXSOLS=*number*","type":"value"},{"name":"MAXTIME=","optional":true,"followsDelimiter":"/","description":"Specifies the maximum time allowed for the MILP solver to find a solution.","help":"MAXTIME=*k*","type":"value"},{"name":"NODESEL=","optional":true,"followsDelimiter":"/","description":"Specifies the node selection strategy string or its corresponding value number. Specifies the node selection strategy option.","help":"NODESEL=AUTOMATIC | BESTBOUND | BESTESTIMATE | DEPTH","type":"choice","arguments":[{"name":"AUTOMATIC","followsDelimiter":"/","description":"Use automatic node selection.","type":"standalone"},{"name":"BESTBOUND","followsDelimiter":"/","description":"Choose the node with the best relaxed objective (best-bound-first strategy).","type":"standalone"},{"name":"BESTESTIMATE","followsDelimiter":"/","description":"Choose the node with the best estimate of the integer objective value (best-estimate-first strategy).","type":"standalone"},{"name":"DEPTH","followsDelimiter":"/","description":"Choose the most recently created node (depth-first strategy).","type":"standalone"}]},{"name":"OPTTOL=","optional":true,"followsDelimiter":"/","description":"Specifies the tolerance used to determine the optimality of nodes in the branch-and-bound tree. The value of number can be any value between (and including) 1E–4 and 1E–9. The default is 1E–6.","help":"OPTTOL=*number*","type":"value"},{"name":"PRESOLVER=","optional":true,"followsDelimiter":"/","description":"Specifies a presolve option.","help":"PRESOLVER=NONE | AUTOMATIC | BASIC | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"NONE","followsDelimiter":"/","description":"Disable presolver.","type":"standalone"},{"name":"AUTOMATIC","followsDelimiter":"/","description":"Apply the default level of presolve processing.","type":"standalone"},{"name":"BASIC","followsDelimiter":"/","description":"Perform minimal presolve processing.","type":"standalone"},{"name":"MODERATE","followsDelimiter":"/","description":"Apply a higher level of presolve processing.","type":"standalone"},{"name":"AGGRESSIVE","followsDelimiter":"/","description":"Apply the highest level of presolve processing.","type":"standalone"}]},{"name":"PRIMALIN","optional":true,"followsDelimiter":"/","description":"Enables you to input an integer feasible solution in PROC OPTMODEL before invoking the MILP solver. Adding the PRIMALIN option to the SOLVE statement requests that the MILP solver use the current variable values as a starting integer feasible solution (warm start). If the MILP solver finds that the input solution is valid, then the input solution provides an incumbent solution and a bound for the branch-and-bound algorithm. If the solution is not valid, then the PRIMALIN data are ignored.","type":"standalone"},{"name":"PRIORITY=","optional":true,"followsDelimiter":"/","description":"Indicates whether to use specified branching priorities for integer variables.","help":"PRIORITY=0 | 1","type":"choice","arguments":[{"name":"0","followsDelimiter":"/","description":"Ignores variable priorities.","type":"standalone"},{"name":"1","followsDelimiter":"/","description":"Uses priorities when they exist. This is the default.","type":"standalone"}]},{"name":"PROBE=","optional":true,"followsDelimiter":"/","description":"Specifies a probing option.","help":"PROBE=AUTOMATIC | NONE | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"AUTOMATIC","followsDelimiter":"/","description":"Probing strategy determined by the MILP solver.","type":"standalone"},{"name":"NONE","followsDelimiter":"/","description":"Disable probing.","type":"standalone"},{"name":"MODERATE","followsDelimiter":"/","description":"Use probing moderately.","type":"standalone"},{"name":"AGGRESSIVE","followsDelimiter":"/","description":"Use probing aggressively.","type":"standalone"}]},{"name":"RELOBJGAP=","optional":true,"followsDelimiter":"/","description":"Specifies a stopping criterion based on the best integer objective (BestInteger) and the objective of the best remaining node (BestBound).","help":"RELOBJGAP=*number*","type":"value"},{"name":"RESTARTS=","optional":true,"followsDelimiter":"/","description":"Specifies the strategy for restarting the processing of the root node.","help":"RESTARTS=AUTOMATIC | NONE | BASIC | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"AUTOMATIC","followsDelimiter":"/","description":"Uses a restarting strategy determined by the MILP solver","type":"standalone"},{"name":"NONE","followsDelimiter":"/","description":"Disables restarting","type":"standalone"},{"name":"BASIC","followsDelimiter":"/","description":"Uses a basic restarting strategy","type":"standalone"},{"name":"MODERATE","followsDelimiter":"/","description":"Uses a moderate restarting strategy","type":"standalone"},{"name":"AGGRESSIVE","followsDelimiter":"/","description":"Uses an aggressive restarting strategy","type":"standalone"}]},{"name":"SCALE=","optional":true,"followsDelimiter":"/","description":"Indicates whether or not to scale the problem matrix.","help":"SCALE=NONE | AUTOMATIC","type":"choice","arguments":[{"name":"NONE","followsDelimiter":"/","description":"Disables scaling.","type":"standalone"},{"name":"AUTOMATIC","followsDelimiter":"/","description":"Scales the matrix as determined by the MILP solver. This is the default.","type":"standalone"}]},{"name":"SEED=","optional":true,"followsDelimiter":"/","description":"Specifies the initial seed of the random number generator.","help":"SEED=*number*","type":"value"},{"name":"STRONGITER=","optional":true,"followsDelimiter":"/","description":"Specifies the number of simplex iterations performed for each variable in the candidate list when using the strong branching variable selection strategy. The value of num can be any positive number up to the largest four-byte signed integer, which is 2^31 - 1. If you specify the keyword AUTOMATIC or the value –1, the MILP solver uses the default value; this value is calculated automatically.","type":"value"},{"name":"STRONGLEN=","optional":true,"followsDelimiter":"/","description":"Specifies the number of candidates used when the strong branching variable selection strategy is performed. The value of number can be any positive integer up to the largest four-byte signed integer, which is 2^31 - 1. If you specify the keyword AUTOMATIC or the value –1, the MILP solver uses the default value; this value is calculated automatically.","type":"value"},{"name":"SYMMETRY=","optional":true,"followsDelimiter":"/","description":"Specifies the level of symmetry detection. Symmetry detection identifies groups of equivalent decision variables and uses this information to solve the problem more efficiently.","help":"SYMMETRY=AUTOMATIC | NONE | BASIC | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"AUTOMATIC","followsDelimiter":"/","description":"Performs symmetry detection based on a strategy that is determined by the MILP solver","type":"standalone"},{"name":"NONE","followsDelimiter":"/","description":"Disables symmetry detection","type":"standalone"},{"name":"BASIC","followsDelimiter":"/","description":"Performs a basic symmetry detection","type":"standalone"},{"name":"MODERATE","followsDelimiter":"/","description":"Performs a moderate symmetry detection","type":"standalone"},{"name":"AGGRESSIVE","followsDelimiter":"/","description":"Performs an aggressive symmetry detection","type":"standalone"}]},{"name":"TARGET=","optional":true,"followsDelimiter":"/","description":"Specifies a stopping criterion for minimization (maximization) problems. If the best integer objective is better than or equal to num, the procedure stops. The value of num can be any number; the default value is the negative (positive) number that has the largest absolute value representable in your operating environment.","help":"TARGET=*number*","type":"value"},{"name":"TIMETYPE=","optional":true,"followsDelimiter":"/","description":"Specifies the measurement of time used by the MILP solver.","help":"TIMETYPE=CPU | REAL","type":"choice","arguments":[{"name":"CPU","followsDelimiter":"/","description":"Uses CPU time. This is the default.","type":"standalone"},{"name":"REAL","followsDelimiter":"/","description":"Uses real time.","type":"standalone"}]},{"name":"VARSEL=","optional":true,"followsDelimiter":"/","description":"Specifies the rule for selecting the branching variable.","help":"VARSEL=AUTOMATIC | MAXINFEAS | MININFEAS | PSEUDO | STRONG","type":"choice","arguments":[{"name":"AUTOMATIC","followsDelimiter":"/","description":"Use automatic branching variable selection.","type":"standalone"},{"name":"MAXINFEAS","followsDelimiter":"/","description":"Choose the variable with maximum infeasibility.","type":"standalone"},{"name":"MININFEAS","followsDelimiter":"/","description":"Choose the variable with minimum infeasibility.","type":"standalone"},{"name":"PSEUDO","followsDelimiter":"/","description":"Choose a branching variable based on pseudocost.","type":"standalone"},{"name":"STRONG","followsDelimiter":"/","description":"Use strong branching variable selection strategy.","type":"standalone"}]}]},{"name":"SOLVE WITH NETWORK","description":"The SOLVE WITH NETWORK statement invokes the network solver.","help":"SOLVE WITH NETWORK NOOBJECTIVE OBJECTIVE RELAXINT ...","arguments":[{"name":"NOOBJECTIVE","aliases":["NOOBJ"],"description":"Requests that the solver ignore the current objective for the problem and use a constant zero objective instead. This keyword enables the solver to process the current model as a feasibility problem.","type":"standalone"},{"name":"OBJECTIVE","aliases":["OBJ"],"description":"A keyword used when specifying the name of the objective to use.","type":"standalone"},{"name":"RELAXINT","description":"Requests that any integral variables be relaxed to be continuous. RELAXINT can be used with linear and nonlinear problems in addition to any solver.","type":"standalone"},{"name":"BICONCOMP","optional":true,"followsDelimiter":"/","description":"Finds biconnected components and articulation points of an undirected input graph.","type":"standalone"},{"name":"CLIQUE=","optional":true,"followsDelimiter":"/","description":"Finds maximal cliques in the input graph. You can specify the following suboption:","help":"CLIQUE=MAXCLIQUES=","type":"choice","arguments":[{"name":"MAXCLIQUES=","type":"value"}]},{"name":"CONCOMP=","optional":true,"followsDelimiter":"/","description":"Finds the connected components of the input graph. You can specify the following suboption:","help":"CONCOMP=ALGORITHM=","type":"choice","arguments":[{"name":"ALGORITHM=","type":"value"}]},{"name":"CYCLE=","optional":true,"followsDelimiter":"/","description":"Finds the cycles (or the existence of a cycle) in the input graph. You can specify the following suboptions in the CYCLE= option:","help":"CYCLE=MAXCYCLES= | MAXLENGTH= | MAXLINKWEIGHT= | MAXNODEWEIGHT= | MINLENGTH= | MINLINKWEIGHT= | MINNODEWEIGHT= | MODE=","type":"choice","arguments":[{"name":"MAXCYCLES=","type":"value"},{"name":"MAXLENGTH=","type":"value"},{"name":"MAXLINKWEIGHT=","type":"value"},{"name":"MAXNODEWEIGHT=","type":"value"},{"name":"MINLENGTH=","type":"value"},{"name":"MINLINKWEIGHT=","type":"value"},{"name":"MINNODEWEIGHT=","type":"value"},{"name":"MODE=","type":"value"}]},{"name":"GRAPH_DIRECTION=","optional":true,"followsDelimiter":"/","aliases":["DIRECTION="],"description":"Specifies directed or undirected graphs.","help":"GRAPH_DIRECTION=DIRECTED | UNDIRECTED","type":"choice","arguments":[{"name":"DIRECTED","followsDelimiter":"/","description":"Requests a directed graph.","type":"standalone"},{"name":"UNDIRECTED","followsDelimiter":"/","description":"Requests an undirected graph.","type":"standalone"}]},{"name":"INCLUDE_SELFLINK","optional":true,"followsDelimiter":"/","description":"Includes self links in the graph definition—for example, $(i,i)$—when an input graph is read. By default, when the network solver reads the LINKS= data, it removes all self links.","type":"standalone"},{"name":"LINEAR_ASSIGNMENT=","optional":true,"followsDelimiter":"/","description":"LAP<=() >","help":"LINEAR_ASSIGNMENT=LAP","type":"choice","arguments":[{"name":"LAP","type":"standalone"}]},{"name":"LINKS=","optional":true,"followsDelimiter":"/","description":"Groups link-indexed data. You can specify the following suboptions: INCLUDE=set-name names a set of links to include in the graph definition even if no weights or bounds are available for them. LOWER=array-name specifies the flow lower bound for each link. The array must be numeric, and it must be indexed over a subset of the inks of the graph. UPPER=array-name specifies the flow upper bound for each link. The array must be numeric, and it must be indexed over a subset of the links of the graph.","help":"LINKS=INCLUDE= | LOWER= | UPPER= | WEIGHT=","type":"choice","arguments":[{"name":"INCLUDE=","type":"value"},{"name":"LOWER=","type":"value"},{"name":"UPPER=","type":"value"},{"name":"WEIGHT=","type":"value"}]},{"name":"LOGFREQ=","optional":true,"followsDelimiter":"/","description":"Controls the frequency with which an algorithm reports progress from its underlying solver. This setting is recognized by the traveling salesman problem and minimum-cost flow algorithms. You can set number to 0 to turn off log updates from underlying algorithms.","help":"LOGFREQ=*number*","type":"value"},{"name":"LOGLEVEL=","optional":true,"followsDelimiter":"/","description":"Controls the amount of information that is displayed in the SAS log. This setting sets the log level for all algorithms. The following describes the valid values of the this option. number string Description 0 NONE Turns off all procedure-related messages in the SAS log 1 BASIC Displays a basic summary of the input, output, and algorithmic processing 2 MODERATE Displays a summary of the input, output, and algorithmic processing 3 AGGRESSIVE Displays a detailed summary of the input, output, and algorithmic processing","type":"value"},{"name":"MAXTIME=","optional":true,"followsDelimiter":"/","description":"Specifies the maximum time to spend calculating results. The type of time (either CPU time or real time) is determined by the value of the TIMETYPE= option. The value of number can be any positive number; the default value is the positive number that has the largest absolute value that can be represented in your operating environment.","help":"MAXTIME=*number*","type":"value"},{"name":"MINCOSTFLOW=","optional":true,"followsDelimiter":"/","description":"Solves the minimum-cost network flow problem.","help":"MINCOSTFLOW=MCF","type":"choice","arguments":[{"name":"MCF","type":"standalone"}]},{"name":"MINCUT=","optional":true,"followsDelimiter":"/","description":"Finds the minimum link-weighted cut of an input graph. You can specify the following suboptions in the MINCUT= option: MAXNUMCUTS=number specifies the maximum number of cuts to return from the algorithm. The minimal cut and any others found during the search, up to number, are returned. By default, MAXNUMCUTS=1.","help":"MINCUT=MAXNUMCUTS= | MAXWEIGHT=","type":"choice","arguments":[{"name":"MAXNUMCUTS=","type":"value"},{"name":"MAXWEIGHT=","type":"value"}]},{"name":"MINSPANTREE=","optional":true,"followsDelimiter":"/","description":"Solves the minimum link-weighted spanning tree problem on an input graph.","help":"MINSPANTREE=MST","type":"choice","arguments":[{"name":"MST","type":"standalone"}]},{"name":"NODES=","optional":true,"followsDelimiter":"/","description":"Groups node-indexed data. You can specify the following suboptions: INCLUDE=set-name names a set of nodes to include in the graph definition even if no weights are available for them. WEIGHT=array-name specifies node weights. The array must be numeric, and it must be indexed over a subset of the nodes of the graph.","help":"NODES=INCLUDE= | WEIGHT= | WEIGHT2=","type":"choice","arguments":[{"name":"INCLUDE=","type":"value"},{"name":"WEIGHT=","type":"value"},{"name":"WEIGHT2=","type":"value"}]},{"name":"OUT=","optional":true,"followsDelimiter":"/","description":"Specifies the output sets or arrays for each algorithm. You can specify the following suboptions:","help":"OUT=ARTPOINTS= | ASSIGNMENTS= | BICONCOMP= | CLIQUES= | CONCOMP= | CUTSETS= | CYCLES= | FLOW= | FOREST= | LINKS= | NODES= | ORDER= | PARTITIONS= | SPPATHS= | TOUR= | SPWEIGHTS= | TRANSCL=","type":"choice","arguments":[{"name":"ARTPOINTS=","type":"value"},{"name":"ASSIGNMENTS=","type":"value"},{"name":"BICONCOMP=","type":"value"},{"name":"CLIQUES=","type":"value"},{"name":"CONCOMP=","type":"value"},{"name":"CUTSETS=","type":"value"},{"name":"CYCLES=","type":"value"},{"name":"FLOW=","type":"value"},{"name":"FOREST=","type":"value"},{"name":"LINKS=","type":"value"},{"name":"NODES=","type":"value"},{"name":"ORDER=","type":"value"},{"name":"PARTITIONS=","type":"value"},{"name":"SPPATHS=","type":"value"},{"name":"TOUR=","type":"value"},{"name":"SPWEIGHTS=","type":"value"},{"name":"TRANSCL=","type":"value"}]},{"name":"SHORTPATH=","optional":true,"followsDelimiter":"/","description":"Calculates shortest paths between sets of nodes on the input graph. You can specify the following suboptions:","help":"SHORTPATH=PATHS= | SINK= | SOURCE= | USEWEIGHT=","type":"choice","arguments":[{"name":"PATHS=","type":"value"},{"name":"SINK=","type":"value"},{"name":"SOURCE=","type":"value"},{"name":"USEWEIGHT=","type":"value"}]},{"name":"SUBGRAPH=","optional":true,"followsDelimiter":"/","description":"Specifies the input sets that enable you to solve a problem over a subgraph. You can specify the following suboptions: LINKS=set-name specifies the subset of links to use. If you specify a node pair that is not referenced in any of the suboptions of the LINKS= option, then the network solver returns an error.","help":"SUBGRAPH=LINKS= | NODES=","type":"choice","arguments":[{"name":"LINKS=","type":"value"},{"name":"NODES=","type":"value"}]},{"name":"TIMETYPE=","optional":true,"followsDelimiter":"/","description":"Specifies whether to use CPU time or real time for the MAXTIME= option. The following describes the valid values of the TIMETYPE= option. number string Description 0 CPU Specifies units of CPU time 1 REAL Specifies units of real time","type":"value"},{"name":"TRANSITIVE_CLOSURE=","optional":true,"followsDelimiter":"/","description":"Calculates the transitive closure of an input graph.","help":"TRANSITIVE_CLOSURE=TRANSCL","type":"choice","arguments":[{"name":"TRANSCL","type":"standalone"}]},{"name":"TSP=","optional":true,"followsDelimiter":"/","description":"Solves the traveling salesman problem. The algorithm that is used to solve this problem is built around the same method as is used in PROC OPTMILP: a branch-and-cut algorithm. Many of the following suboptions are the same as those described for the OPTMILP procedure in the SAS/OR User's Guide: Mathematical Programming. You can specify the following suboptions:","help":"TSP=ABSOBJGAP= | CONFLICTSEARCH= | CUTOFF= | CUTSTRATEGY= | EMPHASIS= | HEURISTICS= | MAXNODES= | MAXSOLS= | MILP= | NODESEL= | PROBE= | RELOBJGAP= | STRONGITER= | STRONGLEN= | TARGET= | VARSEL=","type":"choice","arguments":[{"name":"ABSOBJGAP=","type":"value"},{"name":"CONFLICTSEARCH=","type":"value"},{"name":"CUTOFF=","type":"value"},{"name":"CUTSTRATEGY=","type":"value"},{"name":"EMPHASIS=","type":"value"},{"name":"HEURISTICS=","type":"value"},{"name":"MAXNODES=","type":"value"},{"name":"MAXSOLS=","type":"value"},{"name":"MILP=","type":"value"},{"name":"NODESEL=","type":"value"},{"name":"PROBE=","type":"value"},{"name":"RELOBJGAP=","type":"value"},{"name":"STRONGITER=","type":"value"},{"name":"STRONGLEN=","type":"value"},{"name":"TARGET=","type":"value"},{"name":"VARSEL=","type":"value"}]}]},{"name":"SOLVE WITH NLP","description":"where options specify the technique name, termination criteria, and how to display the results in the iteration log. The sparse nonlinear programming (NLP) solver is a component of the OPTMODEL procedure that can solve optimization problems containing both nonlinear equality and inequality constraints.","help":"SOLVE WITH NLP NOOBJECTIVE OBJECTIVE RELAXINT ...","arguments":[{"name":"NOOBJECTIVE","aliases":["NOOBJ"],"description":"Requests that the solver ignore the current objective for the problem and use a constant zero objective instead. This keyword enables the solver to process the current model as a feasibility problem.","type":"standalone"},{"name":"OBJECTIVE","aliases":["OBJ"],"description":"A keyword used when specifying the name of the objective to use.","type":"standalone"},{"name":"RELAXINT","description":"Requests that any integral variables be relaxed to be continuous. RELAXINT can be used with linear and nonlinear problems in addition to any solver.","type":"standalone"},{"name":"ALGORITHM=","optional":true,"followsDelimiter":"/","aliases":["TECHNIQUE=","TECH=","SOLVER="],"description":"Specifies the optimization technique to be used to solve the problem.","help":"ALGORITHM=INTERIORPOINT | ACTIVESET | CONCURRENT","type":"choice","arguments":[{"name":"INTERIORPOINT","followsDelimiter":"/","description":"Uses a primal-dual interior point method. This technique is recommended for both small- and large-scale nonlinear optimization problems. This is the preferred solver if the problem includes a large number of inactive constraints.","type":"standalone"},{"name":"ACTIVESET","followsDelimiter":"/","description":"Uses a primal-dual active-set method. This technique is recommended for both small- and largescale nonlinear optimization problems. This is the preferred solver if the problem includes only bound constraints or if the optimal active set can be quickly determined by the solver.","type":"standalone"},{"name":"CONCURRENT","followsDelimiter":"/","description":"Runs the INTERIORPOINT and ACTIVESET techniques in parallel, with one thread using the INTERIORPOINT technique and the other thread using the ACTIVESET technique. The solution is returned by the first method that terminates.","type":"standalone"}]},{"name":"COVEST=","optional":true,"followsDelimiter":"/","description":"Requests that the NLP solver produce a covariance matrix. When this option is applied, the following PROC OPTMODEL options are automatically set: PRESOLVER=NONE and SOLTYPE=0. You can specify the following suboptions:","help":"COVEST=ASINGULAR= | COV= | COVOUT= | COVSING= | MSINGULAR= | NDF= | NTERMS= | SIGSQ= | VARDEF=","type":"choice","arguments":[{"name":"ASINGULAR=","type":"value"},{"name":"COV=","type":"value"},{"name":"COVOUT=","type":"value"},{"name":"COVSING=","type":"value"},{"name":"MSINGULAR=","type":"value"},{"name":"NDF=","type":"value"},{"name":"NTERMS=","type":"value"},{"name":"SIGSQ=","type":"value"},{"name":"VARDEF=","type":"value"}]},{"name":"FEASTOL=","optional":true,"followsDelimiter":"/","description":"Defines the feasible tolerance. The solver will exit if the constraint violation is less than FEASTOL and the scaled optimality conditions are less than OPTTOL. The default is ɛ=1E–6.","type":"value"},{"name":"HESSTYPE=","optional":true,"followsDelimiter":"/","description":"Specifies the type of Hessian to be used by the solver. The valid keywords for this option are FULL and PRODUCT.","help":"HESSTYPE=FULL | PRODUCT","type":"choice","arguments":[{"name":"FULL","followsDelimiter":"/","description":"If HESSTYPE=FULL, the solver uses a full Hessian.","type":"standalone"},{"name":"PRODUCT","followsDelimiter":"/","description":"If HESSTYPE=PRODUCT, the solver uses only Hessian-vector products, not the full Hessian.","type":"standalone"}]},{"name":"IIS=","optional":true,"followsDelimiter":"/","description":"IIS=number | string Specifies whether the NLP solver attempts to identify a set of linear constraints and variables that form an irreducible infeasible set (IIS).","help":"IIS=OFF | ON","type":"choice","arguments":[{"name":"OFF","followsDelimiter":"/","description":"Disables IIS detection.","type":"standalone"},{"name":"ON","followsDelimiter":"/","description":"Enables IIS detection.","type":"standalone"}]},{"name":"LOGFREQ=","optional":true,"followsDelimiter":"/","aliases":["PRINTFREQ="],"description":"Specifies how often the iterations are displayed in the SAS log. N should be an integer between zero and the largest four-byte, signed integer, which is 2³¹ - 1. If N >= 1, the solver prints only those iterations that are a multiple of N. If N = 0, no iteration is displayed in the log. The default value is 1.","type":"value"},{"name":"MAXITER=","optional":true,"followsDelimiter":"/","description":"Specifies that the solver take at most N major iterations to determine an optimum of the NLP problem. The value of N is an integer between zero and the largest four-byte, signed integer, which is 2ⁿ - 1 (where n-31). A major iteration in NLP consists of finding a descent direction and a step size along which the next approximation of the optimum resides. The default is 5,000 iterations.","help":"MAXITER=*N*","type":"value"},{"name":"MAXTIME=","optional":true,"followsDelimiter":"/","description":"Specifies an upper limit of t units of time for the optimization process, including problem generation time and solution time. The value of the TIMETYPE= option determines the type of units used. If you do not specify the MAXTIME= option, the solver does not stop based on the amount of time elapsed. The value of t can be any positive number; the default value is the positive number that has the largest absolute value that can be represented in your operating environment.","help":"MAXTIME=*t*","type":"value"},{"name":"MSBNDRANGE=","optional":true,"followsDelimiter":"/","description":"Defines the range from which each variable can take values during the sampling process. This option affects only the sampling process that determines starting points for the local solver. It does not affect the bounds of the original nonlinear optimization problem.","help":"MSBNDRANGE=*M*","type":"value"},{"name":"MSDISTTOL=","optional":true,"followsDelimiter":"/","description":"defines the tolerance by which two optimal points are considered distinct. Optimal points are considered distinct if the Euclidean distance between them is at least ϵ. This option is effective only when the MULTISTART option is specified. The default is ϵ=1.0E–6.","type":"value"},{"name":"MSLOGLEVEL=","optional":true,"followsDelimiter":"/","aliases":["MSPRINTLEVEL="],"description":"Defines the amount of information displayed in the SAS log by the MULTISTART option.","help":"MSLOGLEVEL=0 | 1 | 2 | 3","type":"choice","arguments":[{"name":"0","followsDelimiter":"/","description":"Turns off all solver-related messages to SAS log","type":"standalone"},{"name":"1","followsDelimiter":"/","description":"Displays multistart summary information when the algorithm terminates","type":"standalone"},{"name":"2","followsDelimiter":"/","description":"Displays multistart iteration log and summary information when the algorithm terminates","type":"standalone"},{"name":"3","followsDelimiter":"/","description":"Displays the same information as MSLOGLEVEL=2 and might display additional information","type":"standalone"}]},{"name":"MSMAXSTARTS=","optional":true,"followsDelimiter":"/","description":"Defines the maximum number of starting points to be used for local optimization. That is, there will be no more than N local optimization calls in the multistart algorithm. You can specify N to be any nonnegative integer. When N = 0, the algorithm uses the default value of this option. In a shared memory computing environment, the default value is 100. In a distributed computing environment, the default value is a number proportional to the number of threads across all the grid nodes (usually more than 100). This option is effective only when the MULTISTART option is specified.","help":"MSMAXSTARTS=*N*","type":"value"},{"name":"MSMAXTIME=","optional":true,"followsDelimiter":"/","description":"Defines the maximum allowable time T (in seconds) for the NLP solver to locate the best local optimum in multistart mode. The value of the TIMETYPE= option determines the type of units used.","help":"MSMAXTIME=*T*","type":"value"},{"name":"MULTISTART=","optional":true,"followsDelimiter":"/","aliases":["MS="],"description":"Enables multistart mode. In this mode, the local solver solves the problem from multiple starting points, possibly finding a better local minimum as a result. This option is disabled by default.","help":"MULTISTART=BNDRANGE= | DISTTOL= | LOGLEVEL= | PRINTLEVEL= | MAXTIME= | MAXSTARTS=","type":"choice","arguments":[{"name":"BNDRANGE=","type":"value"},{"name":"DISTTOL=","type":"value"},{"name":"LOGLEVEL=","type":"value"},{"name":"PRINTLEVEL=","type":"value"},{"name":"MAXTIME=","type":"value"},{"name":"MAXSTARTS=","type":"value"}]},{"name":"OBJLIMIT=","optional":true,"followsDelimiter":"/","description":"Specifies an upper limit on the magnitude of the objective value. For a minimization problem, the algorithm terminates when the objective value becomes less than -M; for a maximization problem, \\ the algorithm stops when the objective value exceeds M. The algorithm stopping implies that either the problem is unbounded or the algorithm diverges. If optimization were allowed to continue, numerical difficulty might be encountered. The default is M=1E+20. The minimum acceptable value of M is 1E+8. If the specified value of M is less than 1E+8, the value is reset to the default value 1E+20.","help":"OBJLIMIT=*M*","type":"value"},{"name":"OPTTOL=","optional":true,"followsDelimiter":"/","aliases":["RELOPTTOL="],"description":"Defines the measure by which you can decide whether the current iterate is an acceptable approximation of a local minimum. The value of this option is a positive real number. The NLP solver determines that the current iterate is a local minimum when the norm of the scaled vector of the optimality conditions is less than ϵ and the true constraint violation is less than FEASTOL. The default is ɛ=1E–6.","type":"value"},{"name":"SEED=","optional":true,"followsDelimiter":"/","description":"Specifies a positive integer to be used as the seed for generating random number sequences. You can use this option to replicate results from different runs.","help":"SEED=*N*","type":"value"},{"name":"SOLTYPE=","optional":true,"followsDelimiter":"/","description":"Specifies whether the NLP solver should return only a solution that is locally optimal. If SOLTYPE=0, the solver returns a locally optimal solution, provided it locates one. If SOLTYPE=1, the solver returns the best feasible solution found, provided its objective value is better than that of the locally optimal solution found. The default is 1.","help":"SOLTYPE=0 | 1","type":"choice","arguments":[{"name":"0","followsDelimiter":"/","description":"The solver returns a locally optimal solution, provided it locates one.","type":"standalone"},{"name":"1","followsDelimiter":"/","description":"The solver returns the best feasible solution found, provided its objective value is better than that of the locally optimal solution found.","type":"standalone"}]},{"name":"TIMETYPE=","optional":true,"followsDelimiter":"/","description":"Specifies the units of time used by the MAXTIME= option and reported by the PRESOLVE_TIME and SOLUTION_TIME terms in the _OROPTMODEL_ macro variable.","help":"TIMETYPE=CPU|0 | REAL|1","type":"choice","arguments":[{"name":"CPU","followsDelimiter":"/","description":"Specifies units of CPU time","help":"CPU|0","type":"choice"},{"name":"REAL","followsDelimiter":"/","description":"Specifies units of real time","help":"REAL|1","type":"choice"}]}]},{"name":"SOLVE WITH NLPC","description":"Statement for specifying and solving general nonlinear programming problems.","help":"SOLVE WITH NLPC NOOBJECTIVE OBJECTIVE RELAXINT ...","arguments":[{"name":"NOOBJECTIVE","aliases":["NOOBJ"],"description":"Requests that the solver ignore the current objective for the problem and use a constant zero objective instead. This keyword enables the solver to process the current model as a feasibility problem.","type":"standalone"},{"name":"OBJECTIVE","aliases":["OBJ"],"description":"A keyword used when specifying the name of the objective to use.","type":"standalone"},{"name":"RELAXINT","description":"Requests that any integral variables be relaxed to be continuous. RELAXINT can be used with linear and nonlinear problems in addition to any solver.","type":"standalone"},{"name":"ABSOPTTOL=","optional":true,"followsDelimiter":"/","description":"Specifies the tolerance for the absolute optimality error.","help":"ABSOPTTOL=*delta*","type":"value"},{"name":"MAXFEVAL=","optional":true,"followsDelimiter":"/","description":"","type":"value"},{"name":"MAXFUNC=","optional":true,"followsDelimiter":"/","description":"Specifies that the optimization process stop after a maximum of N function calls.","help":"MAXFUNC=*N*","type":"value"},{"name":"MAXITER=","optional":true,"followsDelimiter":"/","description":"Specifies that the optimization process stop after a maximum of N iterations.","help":"MAXITER=*N*","type":"value"},{"name":"MAXTIME=","optional":true,"followsDelimiter":"/","description":"Specifies an upper limit of M seconds of real time for the optimization process.","help":"MAXTIME=*M*","type":"value"},{"name":"OBJLIMIT=","optional":true,"followsDelimiter":"/","description":"Specifies an upper limit on the magnitude of the objective value. For a minimization problem, the algorithm terminates when the objective value becomes less than -M; for a maximization problem, \\ the algorithm stops when the objective value exceeds M.","help":"OBJLIMIT=*M*","type":"value"},{"name":"PRINTFREQ=","optional":true,"followsDelimiter":"/","description":"Specifies that the printing of the solution progress to the iteration log should occur after every j iterations.","help":"PRINTFREQ=*j*","type":"value"},{"name":"RELOPTTOL=","optional":true,"followsDelimiter":"/","description":"Specifies the tolerance for the relative optimality error.","help":"RELOPTTOL=*delta*","type":"value"},{"name":"TECHNIQUE=","optional":true,"followsDelimiter":"/","description":"Specifies the optimization technique.","help":"TECHNIQUE=CONGRA | NEWTYP | TRUREG | QUANEW","type":"choice","arguments":[{"name":"CONGRA","followsDelimiter":"/","description":"Uses a conjugate gradient method.","type":"standalone"},{"name":"NEWTYP","followsDelimiter":"/","description":"Uses a Newton-type method with line search.","type":"standalone"},{"name":"TRUREG","followsDelimiter":"/","description":"Uses a trust region method.","type":"standalone"},{"name":"QUANEW","followsDelimiter":"/","description":"Uses a quasi-Newton method with the BFGS update. QUANEW is the optimization technique in the NLPC solver to solve problems with nonlinear constraints.","type":"standalone"}]}]},{"name":"SOLVE WITH NLPU","description":"Statement for specifying and solving unconstrained nonlinear programming problems.","help":"SOLVE WITH NLPU NOOBJECTIVE OBJECTIVE RELAXINT ...","arguments":[{"name":"NOOBJECTIVE","aliases":["NOOBJ"],"description":"Requests that the solver ignore the current objective for the problem and use a constant zero objective instead. This keyword enables the solver to process the current model as a feasibility problem.","type":"standalone"},{"name":"OBJECTIVE","aliases":["OBJ"],"description":"A keyword used when specifying the name of the objective to use.","type":"standalone"},{"name":"RELAXINT","description":"Requests that any integral variables be relaxed to be continuous. RELAXINT can be used with linear and nonlinear problems in addition to any solver.","type":"standalone"},{"name":"LBFGSCORR=","optional":true,"followsDelimiter":"/","description":"Specifies the number of Hessian corrections for the L-BFGS algorithms. The value of n can be any integer between 2 and 100. The default value is 7 corrections.","help":"LBFGSCORR=*n*","type":"value"},{"name":"LSARMIJO=","optional":true,"followsDelimiter":"/","description":"Specifies the Armijo parameter c1 for the line-search technique. The default value is 2.0E-3.","help":"LSARMIJO=*c1*","type":"value"},{"name":"LSMAXITER=","optional":true,"followsDelimiter":"/","description":"Specifies the maximum number of line-search iterations within one L-BFGS or conjugate gradient method.","type":"value"},{"name":"LSWOLFE=","optional":true,"followsDelimiter":"/","description":"Specifies the Wolfe parameter c2 for the line-search technique. The default value is 0.7.","help":"LSWOLFE=*c2*","type":"value"},{"name":"MAXITER=","optional":true,"followsDelimiter":"/","description":"Specifies that the optimization process stop after a maximum of N iterations.","help":"MAXITER=*N*","type":"value"},{"name":"MAXTIME=","optional":true,"followsDelimiter":"/","description":"Specifies an upper limit of M seconds of real time for the optimization process.","help":"MAXTIME=*M*","type":"value"},{"name":"OBJLIMIT=","optional":true,"followsDelimiter":"/","description":"Specifies an upper limit on the magnitude of the objective value. For a minimization problem, the algorithm terminates when the objective value becomes less than -M; for a maximization problem, the algorithm stops when the objective value exceeds M.","help":"OBJLIMIT=*M*","type":"value"},{"name":"OPTTOL=","optional":true,"followsDelimiter":"/","description":"Specifies the desired tolerance of the relative gradient norm.","type":"value"},{"name":"PRINTFREQ=","optional":true,"followsDelimiter":"/","description":"Specifies that the printing of the solution progress to the iteration log should occur after every j iterations.","help":"PRINTFREQ=*j*","type":"value"},{"name":"TECHNIQUE=","optional":true,"followsDelimiter":"/","description":"Specifies the optimization technique.","help":"TECHNIQUE=FLETREEV | LBFGS | POLRIB | CGTR","type":"choice","arguments":[{"name":"FLETREEV","followsDelimiter":"/","description":"Uses the Fletcher-Reeves nonlinear conjugate gradient algorithm.","type":"standalone"},{"name":"LBFGS","followsDelimiter":"/","description":"Uses the limited-memory Broyden-Fletcher-Goldfarb-Shanno algorithm. This is the default solver.","type":"standalone"},{"name":"POLRIB","followsDelimiter":"/","description":"Uses the Polak-Ribière nonlinear conjugate gradient algorithm.","type":"standalone"},{"name":"CGTR","followsDelimiter":"/","description":"Uses the conjugate gradient method and a trust-region method to solve bound-constrained optimization problems.","type":"standalone"}]}]},{"name":"SOLVE WITH QP","description":"Statement for specifying and solving quadratic programs.","help":"SOLVE WITH QP NOOBJECTIVE OBJECTIVE RELAXINT ...","arguments":[{"name":"NOOBJECTIVE","aliases":["NOOBJ"],"description":"Requests that the solver ignore the current objective for the problem and use a constant zero objective instead. This keyword enables the solver to process the current model as a feasibility problem.","type":"standalone"},{"name":"OBJECTIVE","aliases":["OBJ"],"description":"A keyword used when specifying the name of the objective to use.","type":"standalone"},{"name":"RELAXINT","description":"Requests that any integral variables be relaxed to be continuous. RELAXINT can be used with linear and nonlinear problems in addition to any solver.","type":"standalone"},{"name":"IIS=","optional":true,"followsDelimiter":"/","description":"IIS=number | string Specifies whether the NLP solver attempts to identify a set of linear constraints and variables that form an irreducible infeasible set (IIS).","help":"IIS=OFF | ON","type":"choice","arguments":[{"name":"OFF","followsDelimiter":"/","description":"Disables IIS detection.","type":"standalone"},{"name":"ON","followsDelimiter":"/","description":"Enables IIS detection.","type":"standalone"}]},{"name":"LOGFREQ=","optional":true,"followsDelimiter":"/","aliases":["PRINTFREQ="],"description":"Specifies that the printing of the solution progress to the iteration log is to occur after every k iterations.","type":"value"},{"name":"MAXITER=","optional":true,"followsDelimiter":"/","description":"Specifies the maximum number of iterations.","help":"MAXITER=*k*","type":"value"},{"name":"MAXTIME=","optional":true,"followsDelimiter":"/","description":"Specifies an upper limit of k seconds of real time for the optimization process.","help":"MAXTIME=*k*","type":"value"},{"name":"PRESOLVER=","optional":true,"followsDelimiter":"/","aliases":["PRESOL="],"description":"Specifies one of the following presolve options:","help":"PRESOLVER=NONE | AUTOMATIC","type":"choice","arguments":[{"name":"NONE","followsDelimiter":"/","description":"Disable presolver.","type":"standalone"},{"name":"AUTOMATIC","followsDelimiter":"/","description":"Apply presolver by using default setting.","type":"standalone"}]},{"name":"STOP_DG=","optional":true,"followsDelimiter":"/","description":"Specifies the desired relative duality gap, δ ϵ [1E–9, 1E–4]. This is the relative difference between the primal and dual objective function values and is the primary solution quality parameter. The default value is 1E–6.","type":"value"},{"name":"STOP_DI=","optional":true,"followsDelimiter":"/","description":"Specifies the maximum allowed relative dual constraints violation, β ϵ [1E–9, 1E–4]. The default value is 1E–6.","type":"value"},{"name":"STOP_PI=","optional":true,"followsDelimiter":"/","description":"Specifies the maximum allowed relative bound and primal constraints violation, α ϵ [1E–9, 1E–4]. The default value is 1E–6.","type":"value"},{"name":"TIMETYPE=","optional":true,"followsDelimiter":"/","description":"Specifies the units of time used by the MAXTIME= option and reported by the PRESOLVE_TIME and SOLUTION_TIME terms in the _OROPTMODEL_ macro variable.","help":"TIMETYPE=CPU|0 | REAL|1","type":"choice","arguments":[{"name":"CPU","followsDelimiter":"/","description":"Specifies units of CPU time","help":"CPU|0","type":"choice"},{"name":"REAL","followsDelimiter":"/","description":"Specifies units of real time","help":"REAL|1","type":"choice"}]}]},{"name":"SOLVE WITH SQP","description":"The sequential quadratic programming (SQP) solver is a component of the OPTMODEL procedure, and it can be used for solving general nonlinear programming (NLP) problems.","help":"SOLVE WITH SQP NOOBJECTIVE OBJECTIVE RELAXINT ...","arguments":[{"name":"NOOBJECTIVE","aliases":["NOOBJ"],"description":"Requests that the solver ignore the current objective for the problem and use a constant zero objective instead. This keyword enables the solver to process the current model as a feasibility problem.","type":"standalone"},{"name":"OBJECTIVE","aliases":["OBJ"],"description":"A keyword used when specifying the name of the objective to use.","type":"standalone"},{"name":"RELAXINT","description":"Requests that any integral variables be relaxed to be continuous. RELAXINT can be used with linear and nonlinear problems in addition to any solver.","type":"standalone"},{"name":"FEASTOL=","optional":true,"followsDelimiter":"/","description":"Specifies the convergence tolerance for feasibility. The value of this option is a positive real number. The default value is 1E-6.","type":"value"},{"name":"HESCHECK","optional":true,"followsDelimiter":"/","description":"Specifies that the solver check the second-order optimality of the solution found - i.e., the nonnegativity of the projected Hessian of the Lagrangian function at the solution.","type":"standalone"},{"name":"MAXITER=","optional":true,"followsDelimiter":"/","description":"Specifies that the optimization process stop after a maximum of N iterations.","help":"MAXITER=*N*","type":"value"},{"name":"MAXTIME=","optional":true,"followsDelimiter":"/","description":"Specifies an upper limit of r seconds of real time for the optimization process.","help":"MAXTIME=*r*","type":"value"},{"name":"NOHESCHECK","optional":true,"followsDelimiter":"/","description":"Specifies that the solver does not check the second-order optimality of the solution found.","type":"standalone"},{"name":"OPTTOL=","optional":true,"followsDelimiter":"/","description":"Specifies the convergence tolerance for both stationary and complementary conditions. The value of this option is a positive real number. The default value is 1E-5.","type":"value"},{"name":"PENALTY=","optional":true,"followsDelimiter":"/","description":"Specifies the rate at which the penalty parameters used in the Lagrangian function are reduced. The default value for the PENALTY= option is 0.75.","type":"value"},{"name":"PRINTFREQ=","optional":true,"followsDelimiter":"/","description":"Specifies that the printing of the solution progress to the iteration log should occur after every j iterations.","help":"PRINTFREQ=*j*","type":"value"}]},{"name":"STOP","description":"The STOP statement halts the execution of all statements that contain it, including DO statements and other control or looping statements. Execution continues with the next top-level source statement.","help":"STOP "},{"name":"STRING","aliases":["STR"],"description":"Declaration of parameters that have a STRING type.","help":"STRING &lt;INIT expression&gt; ","arguments":[{"name":"INIT","optional":true,"description":"Specifies a default value that is used when a parameter value is required but no other value has been supplied.","type":"standalone"}]},{"name":"SUBMIT","description":"The SUBMIT statement allows SAS code to be executed before PROC OPTMODEL processing continues. For example, you can use the SUBMIT statement to invoke other SAS procedures to perform analysis or to display results. The arguments list specifies macro variables to initialize in the SUBMIT block environment before the SUBMIT block is executed. List items are separated by spaces. Each of the arguments takes one of the following forms: name copies the value of the PROC OPTMODEL parameter name to the macro variable that has the same name. name = identifier-expression copies the value of the PROC OPTMODEL parameter specified by identifier-expression to the macro variable name. name = number | “string” | ‘string’ copies the value of the specified number or string constant to the macro variable name. name = ( expression ) copies the result of evaluating expression to the macro variable name.","help":"SUBMIT &lt;OK = identifier-expression&gt; &lt;OUT[=] output-argument | (output-arguments)&gt; ","arguments":[{"name":"OK=","optional":true,"followsDelimiter":"/","description":"specifies a PROC OPTMODEL numeric parameter location, identifier-expression, that is updated to indicate the success of the SUBMIT block execution. The location is set to 1 if execution is successful or 0 if errors are detected. PROC OPTMODEL continues execution when the SUBMIT block encounters errors only if the OK= option is specified.","type":"value"},{"name":"OUT=","optional":true,"followsDelimiter":"/","description":"specifies a single output-argument for retrieving macro variable values from the SUBMIT block environment after each execution of the block, or a list of space-delimited output-arguments for retrieving macro variable values from the SUBMIT block environment after the block is executed. Each output-argument item specifies a macro variable to copy out of the SUBMIT block environment after the block is executed. Each item takes one of the following two forms:","type":"value"}]},{"name":"UNFIX","description":"The UNFIX statement reverses the effect of FIX statements.","help":"UNFIX identifier-list [ =( expression ) ]"},{"name":"USE PROBLEM","description":"The USE PROBLEM programming statement makes the problem specified by the identifier-expression be the current problem. If the problem has not been previously used, the problem is created using the PROBLEM declaration corresponding to the name. The problem must have been previously declared.","help":"USE PROBLEM identifier-expression "},{"name":"VAR","description":"The VAR statement declares one or more optimization variables. Multiple VAR statements are permitted. A variable is not allowed to have the same name as a parameter or constraint.","help":"VAR &lt;BINARY&gt; &lt;INIT expression&gt; &lt;INTEGER&gt; ...","arguments":[{"name":"BINARY","optional":true,"description":"Requests that the solver assign the variable a value of either 0 or 1.","type":"standalone"},{"name":"INIT","optional":true,"description":"Sets an initial value for the variable. The expression is used only the first time the value is required. If no initial value is specified, then 0 is used by default.","type":"standalone"},{"name":"INTEGER","optional":true,"description":"Requests that the solver assign the variable an integer value.","type":"standalone"}]}],"interactive":true,"supportSiteInformation":{"docsetId":"casmopt","docsetVersion":"v_025","docsetTargetFile":"casmopt_optmodel_toc.htm"}}