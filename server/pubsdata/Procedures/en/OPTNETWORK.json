{"name":"OPTNETWORK","statements":[{"name":"PROC OPTNETWORK","description":"The OPTNETWORK procedure includes a number of graph theory and network optimization algorithms that can augment more generic mathematical optimization approaches. Many practical applications of optimization depend on an underlying network. For example, retailers face the problem of shipping goods from warehouses to stores in a distribution network to satisfy demand at minimum cost. Commuters choose routes in a road network to travel from home to work in the shortest amount of time.","help":"PROC OPTNETWORK <DIRECTION=DIRECTED | UNDIRECTED> <INCLUDESELFLINK> <INDEXOFFSET=number> <LINKS=CAS-libref.data-table> <LOGFREQTIME=number | LOGFREQUENCYTIME=number> <LOGLEVEL=NONE | BASIC | MODERATE... > <NODES=CAS-libref.data-table> <NODESSUBSET=CAS-libref.data-table> <NTHREADS=number> <OUTLINKS=CAS-libref.data-table> <OUTNODES=CAS-libref.data-table> <STANDARDIZEDLABELS> <TIMETYPE=CPU | REAL>;     \n\tBICONNECTEDCOMPONENTS ;     \n\tBY variables;     \n\tCLIQUE <MAXCLIQUES=number | ALL> <MAXTIME=number> <OUT=CAS-libref.data-table> ...; \n   \n\tCONNECTEDCOMPONENTS <ALGORITHM=<AUTOMATIC | DFS | PARALLEL>... > <INTERNALFORMAT=<FULL | THIN>> ; \n   \n\tCYCLE <ALGORITHM=<BACKTRACK | BUILD>> <MAXCYCLES=number | ALL> <MAXLENGTH=number> ...; \n   \n\tDISPLAY <CASESENSITIVE> <EXCLUDE> <EXCLUDEALL> ...; \n   \n\tDISPLAYOUT <INCLUDEALL> <NOREPLACE> <REPEATED> ...; \n   \n\tLINEARASSIGNMENT <OUT=CAS-libref.data-table> ; \n   \n\tLINKSVAR <AUXWEIGHT=column> <FROM=column> <LOWER=column> ...; \n   \n\tMINCOSTFLOW <INTERNALFORMAT=<FULL | THIN>> <LOGFREQ=number | LOGFREQUENCY=number> <MAXTIME=number> ...; \n   \n\tMINCUT <MAXCUTS=number> <MAXWEIGHT=number> <OUTCUTSETS=CAS-libref.data-table | OUT=CAS-libref.data-table> ...;     \n\tMINSPANTREE <INTERNALFORMAT=<FULL | THIN>> <OUT=CAS-libref.data-table> ; \n   \n\tNODESSUBSETVAR <NODE=column> <SINK=column> <SOURCE=column> ...; \n   \n\tNODESVAR <LOWER=column> <NODE=column> <UPPER=column> ...; \n   \n\tPATH <INTERNALFORMAT=<FULL | THIN>> <MAXLENGTH=number> <MAXLINKWEIGHT=number> ...; \n   \n\tSHORTESTPATH <MAXPATHWEIGHT=number> <OUTPATHS=CAS-libref.data-table | OUT=CAS-libref.data-table> <OUTWEIGHTS=CAS-libref.data-table> ...; \n   \n\tSUMMARY <BICONNECTEDCOMPONENTS> <CONNECTEDCOMPONENTS> <DIAMETERAPPROX=<WEIGHT | UNWEIGHT | BOTH>> ...; \n   \n\tTRANSITIVECLOSURE <OUT=CAS-libref.data-table> ; \n   \n\tTSP <ABSOBJGAP=number | ABSOLUTEOBJECTIVEGAP=number> <CUTOFF=number> <CUTSTRATEGY=<AUTOMATIC | NONE | MODERATE>... > ...; ","arguments":[{"name":"DETERMINISTIC=","optional":true,"description":"specifies whether to enforce determinism.","help":"DETERMINISTIC=TRUE |  FALSE","type":"choice","arguments":[{"name":"TRUE","description":"Ensures that each invocation (with the same machine configuration and parameter settings) produces the same final result.","type":"standalone"},{"name":"FALSE","description":"Specifying DETERMINISTIC=FALSE might improve performance, but the final results might differ. In some cases, this difference is simply a permutation of identifiers (for example, connected components).","type":"standalone"}]},{"name":"DIRECTION=","optional":true,"description":"Specifies whether the input graph should be considered directed or undirected.","help":"DIRECTION=DIRECTED | UNDIRECTED","type":"choice","arguments":[{"name":"DIRECTED","description":"Specifies the graph as directed.","type":"standalone"},{"name":"UNDIRECTED","description":"Specifies the graph as undirected.","type":"standalone"}]},{"name":"DISTRIBUTED=","optional":true,"description":"specifies whether to use a distributed graph.","help":"DISTRIBUTED=TRUE |  FALSE","type":"choice","arguments":[{"name":"TRUE","description":"A distributed graph is used.","type":"standalone"},{"name":"FALSE","description":"Means that a distributed graph is not used.","type":"standalone"}]},{"name":"GRAPH=","optional":true,"description":"Specifies the in-memory graph to use. This option can be used with any algorithm that supports in-memory execution.","help":"GRAPH=*number*","type":"value"},{"name":"INCLUDESELFLINK","optional":true,"description":"Includes self-links, such as (i,i), when an input graph is read. By default, when PROC OPTNETWORK reads the LINKS= data table, it removes all self-links.","type":"standalone"},{"name":"INDEXOFFSET=","optional":true,"description":"Specifies the index offset for identifiers in the log and results output data tables. For example, if three cycles are found in cycle enumeration, they are labeled cycles 1, 2, and 3 by default. If INDEXOFFSET=4, they are labeled cycles 4, 5, and 6. The value of number must be an integer greater than or equal to 0. By default, INDEXOFFSET=1.","help":"INDEXOFFSET=*number*","type":"value"},{"name":"LINKS=","optional":true,"description":"Specifies the input data table that contains the graph link information. CAS-libref.data-table is a two-level name, where CAS-libref refers to the caslib and session identifier, and data-table specifies the name of the input data table.","help":"LINKS=*CAS-libref.data-table*","type":"dataSet"},{"name":"LOGFREQUENCYTIME=","optional":true,"aliases":["LOGFREQTIME="],"description":"Controls the frequency, in number of seconds, for displaying iteration logs for some algorithms. This option is useful for computationally intensive algorithms. Setting this value too low can hurt algorithm performance. The value of number can be any integer greater than or equal to 1.","help":"LOGFREQUENCYTIME=*number*","type":"value"},{"name":"LOGLEVEL=","optional":true,"description":"Controls the amount of information that is displayed in the SAS log.","help":"LOGLEVEL=NONE | BASIC | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"NONE","description":"Turns off all procedure-related messages in the SAS log.","type":"standalone"},{"name":"BASIC","description":"Displays a brief summary of the algorithmic processing.","type":"standalone"},{"name":"MODERATE","description":"Displays a moderately detailed summary of the input, output, and algorithmic processing.","type":"standalone"},{"name":"AGGRESSIVE","description":"Displays a more detailed summary of the input, output, and algorithmic processing.","type":"standalone"}]},{"name":"MULTILINKS=","optional":true,"description":"Specifies whether to include or aggregate multilinks when an input graph (specified by the LINKS= option) is read.","help":"MULTILINKS=TRUE |  FALSE","type":"choice","arguments":[{"name":"TRUE","description":"Includes multilinks.","type":"standalone"},{"name":"FALSE","description":"Aggregates multilinks.","type":"standalone"}]},{"name":"NODES=","optional":true,"description":"Specifies the input data table that contains the graph node information.","help":"NODES=*CAS-libref.data-table*","type":"dataSet"},{"name":"NODESSUBSET=","optional":true,"description":"Specifies the input data table that contains the graph node subset information.","help":"NODESSUBSET=*CAS-libref.data-table*","type":"dataSet"},{"name":"NTHREADS=","optional":true,"description":"Specifies the maximum number of threads to use for multithreaded processing. Some of the algorithms can take advantage of multicore machines and can run faster when number is greater than 1. Algorithms that cannot take advantage of this option use only one thread even if number is greater than 1. For distributed execution, number specifies the maximum number of threads to use on each machine. The value of number can be any integer between 1 and 256, inclusive. The default is the number of cores on the machine that executes the process or the number of cores permissible based on your installation (whichever is less). The number of simultaneously active CPUs is limited by your installation and license configuration.","help":"NTHREADS=*number*","type":"value"},{"name":"OUTGRAPHLIST=","optional":true,"description":"specifies the output data table to contain summary information about in-memory graphs. CAS-libref.data-table is a two-level name, where CAS-libref refers to the caslib and session identifier, and data-table specifies the name of the output data table.","help":"OUTGRAPHLIST=*CAS-libref.data-table*","type":"dataSet"},{"name":"OUTLINKS=","optional":true,"description":"Specifies the output data table to contain the graph link information along with any results from the algorithms that calculate metrics on links. CAS-libref.data-table is a two-level name, where CAS-libref refers to the caslib and session identifier, and data-table specifies the name of the output data table.","help":"OUTLINKS=*CAS-libref.data-table*","type":"dataSet"},{"name":"OUTNODES=","optional":true,"description":"Specifies the output data table to contain the graph node information along with any results from the algorithms that calculate metrics on nodes. CAS-libref.data-table is a two-level name, where CAS-libref refers to the caslib and session identifier, and data-table specifies the name of the output data table.","help":"OUTNODES=*CAS-libref.data-table*","type":"dataSet"},{"name":"SELFLINKS=","optional":true,"description":"Specifies whether to include or remove self-links when an input graph (specified by the LINKS= option) is read.","help":"SELFLINKS=TRUE |  FALSE","type":"choice","arguments":[{"name":"TRUE","description":"Includes self-links.","type":"standalone"},{"name":"FALSE","description":"Removes self-links.","type":"standalone"}]},{"name":"STANDARDIZEDLABELS","optional":true,"description":"Specifies that the input graph data are in a standardized format.","type":"standalone"},{"name":"STANDARDIZEDLABELSOUT","optional":true,"description":"Specifies that the output graph data include standardized format.","type":"standalone"},{"name":"TIMETYPE=","optional":true,"description":"Specifies whether CPU time or real time is used for each algorithm’s MAXTIME= option (where applicable).","help":"TIMETYPE=CPU | REAL","type":"choice","arguments":[{"name":"CPU","description":"Specifies units of CPU time. The time restriction is applied per processing machine (not across all machines).","type":"standalone"},{"name":"REAL","description":"Specifies units of real time.","type":"standalone"}]}]},{"name":"BICONNECTEDCOMPONENTS","description":"The BICONNECTEDCOMPONENTS statement requests that PROC OPTNETWORK find biconnected components and articulation points of an undirected input graph.","help":"BICONNECTEDCOMPONENTS ","arguments":[{"name":"OUT=","optional":true,"description":"specifies the output data table to contain the biconnected components summary results. CAS-libref.data-table is a two-level name, where CAS-libref refers to the caslib and session identifier, and data-table specifies the name of the output data table.","help":"OUT=*CAS-libref.data-table*","type":"dataSet"}]},{"name":"BY","description":"You can specify a BY statement in PROC OPTNETWORK to obtain separate analyses of observations in groups that are defined by the values of the BY variables. If you specify more than one BY statement, only the last one specified is used. The BY statement in PROC OPTNETWORK is not supported when either a nodes or nodes subset data table is used. The BY variable must come from the LINKS= data table.","help":"BY variables"},{"name":"CLIQUE","description":"The CLIQUE statement invokes an algorithm that finds maximal cliques in the input graph.","help":"CLIQUE &lt;MAXCLIQUES=number | ALL&gt; &lt;MAXTIME=number&gt; &lt;OUT=CAS-libref.data-table&gt; ...","arguments":[{"name":"CLIQUENUMBER=","optional":true,"description":"Specifies whether to calculate the clique number of the graph.","help":"CLIQUENUMBER=TRUE | FALSE","type":"choice","arguments":[{"name":"TRUE","description":"Calculates the node clique number for each node, if CLIQUENUMBER=TRUE and you specify the OUTNODES= option in the PROC OPTNETWORK statement.","type":"standalone"},{"name":"FALSE","description":"Does not calculate the node clique number for each node.","type":"standalone"}]},{"name":"MAXCLIQUES=","optional":true,"description":"Specifies the maximum number of cliques to return during clique enumeration. You can specify either a number (which can be any 32-bit integer greater than or equal to 1) or ALL (which represents the maximum that can be represented by a 32-bit integer). By default, MAXCLIQUES=1.","help":"MAXCLIQUES=*number* | ALL","type":"choice","arguments":[{"name":"number","placeholder":true,"type":"value"},{"name":"ALL","type":"standalone"}]},{"name":"MAXLINKWEIGHT=","optional":true,"description":"Specifies the maximum sum of link weights in a clique.","help":"MAXLINKWEIGHT=*number*","type":"value"},{"name":"MAXNODEWEIGHT=","optional":true,"description":"Specifies the maximum sum of node weights in a clique.","help":"MAXNODEWEIGHT=*number*","type":"value"},{"name":"MAXSIZE=","optional":true,"description":"Specifies the maximum number of nodes in a clique.","help":"MAXSIZE=*number*","type":"value"},{"name":"MAXTIME=","optional":true,"description":"Specifies the maximum amount of time to spend finding cliques. The type of time (either CPU time or real time) is determined by the value of the TIMETYPE= option in the PROC OPTNETWORK statement. The default is the largest number that can be represented by a double.","help":"MAXTIME=*number*","type":"value"},{"name":"MINLINKWEIGHT=","optional":true,"description":"Specifies the minimum sum of link weights in a clique.","help":"MINLINKWEIGHT=*number*","type":"value"},{"name":"MINNODEWEIGHT=","optional":true,"description":"Specifies the minimum sum of node weights in a clique.","help":"MINNODEWEIGHT=*number*","type":"value"},{"name":"MINSIZE=","optional":true,"description":"Specifies the minimum number of nodes in a clique.","help":"MINSIZE=number","type":"value"},{"name":"OUT=","optional":true,"description":"Specifies the output data table to contain the maximal cliques. CAS-libref.data-table is a two-level name, where CAS-libref refers to the caslib and session identifier, and data-table specifies the name of the output data table.","help":"OUT=*CAS-libref.data-table*","type":"dataSet"}]},{"name":"CONNECTEDCOMPONENTS","description":"The CONNECTEDCOMPONENTS statement invokes an algorithm that finds the connected components of the input graph.","help":"CONNECTEDCOMPONENTS &lt;ALGORITHM=&lt;AUTOMATIC | DFS | PARALLEL&gt;... &gt; &lt;INTERNALFORMAT=&lt;FULL | THIN&gt;&gt; ","arguments":[{"name":"ALGORITHM=","optional":true,"description":"Specifies the algorithm to use for calculating connected components.","help":"ALGORITHM=AUTOMATIC | DFS | PARALLEL | UNIONFIND","type":"choice","arguments":[{"name":"AUTOMATIC","description":"Automatically determines the algorithm for connected components.","type":"standalone"},{"name":"DFS","description":"Uses the depth-first search algorithm for connected components.","type":"standalone"},{"name":"PARALLEL","description":"Uses the distributed parallel union-find algorithm for connected components. You can specify this value when the number of machines in your session is greater than 1. You can use this algorithm only with undirected graphs.","type":"standalone"},{"name":"UNIONFIND","description":"Uses the union-find algorithm for connected components. You can use this algorithm only with undirected graphs.","type":"standalone"}]},{"name":"INTERNALFORMAT=","optional":true,"description":"Specifies the internal graph format for the connected components algorithm to use.","help":"INTERNALFORMAT=FULL | THIN","type":"choice","arguments":[{"name":"FULL","description":"Stores the graph in standard (adjacency-list-based) format.","type":"standalone"},{"name":"THIN","description":"Stores the graph in thin (simple list of links) format. This option can improve performance in some cases both by reducing memory and by simplifying the construction of the internal data structures. This option causes PROC OPTNETWORK to skip the removal of duplicate links when it reads in the graph (which has no effect on the resulting components).","type":"standalone"}]},{"name":"OUT=","optional":true,"description":"Specifies the output data table to contain the connected components summary results. CAS-libref.data-table is a two-level name, where CAS-libref refers to the caslib and session identifier, and data-table specifies the name of the output data table.","help":"OUT=*CAS-libref.data-table*","type":"dataSet"}]},{"name":"CYCLE","description":"The CYCLE statement invokes an algorithm that finds the cycles (or the existence of a cycle) in the input graph.","help":"CYCLE &lt;ALGORITHM=&lt;BACKTRACK | BUILD&gt;&gt; &lt;MAXCYCLES=number | ALL&gt; &lt;MAXLENGTH=number&gt; ...","arguments":[{"name":"ALGORITHM=","optional":true,"description":"Specifies which algorithm to use in enumerating cycles.","help":"ALGORITHM=BACKTRACK | BUILD","type":"choice","arguments":[{"name":"BACKTRACK","description":"Uses a backtracking algorithm based on Johnson (1975).","type":"standalone"},{"name":"BUILD","description":"Uses a building algorithm based on Liu and Wang (2006).","type":"standalone"}]},{"name":"MAXCYCLES=","optional":true,"description":"Specifies the maximum number of cycles to return during cycle enumeration. You can specify either a number (which can be any 32-bit integer greater than or equal to 1) or ALL (which represents the maximum that can be represented by a 32-bit integer). By default, MAXCYCLES=1.","help":"MAXCYCLES=*number* | ALL","type":"choice","arguments":[{"name":"number","placeholder":true,"description":"Specifies the maximum number of cycles to return during cycle enumeration. number can be any 32-bit integer greater than or equal to 1.","type":"value"},{"name":"ALL","description":"Represents the maximum value that can be represented by a 64-bit integer.","type":"standalone"}]},{"name":"MAXLENGTH=","optional":true,"description":"Specifies the maximum number of links in a cycle. Any cycle whose length is greater than number is removed from the results. The default is the largest number that can be represented by a 32-bit integer, which causes no cycles to be removed from the results.","help":"MAXLENGTH=*number*","type":"value"},{"name":"MAXLINKWEIGHT=","optional":true,"description":"Specifies the maximum sum of link weights in a cycle. Any cycle whose sum of link weights is greater than number is removed from the results. The default is the largest number that can be represented by a double, which causes no cycles to be removed from the results.","help":"MAXLINKWEIGHT=*number*","type":"value"},{"name":"MAXNODEWEIGHT=","optional":true,"description":"Specifies the maximum sum of node weights in a cycle. Any cycle whose sum of node weights is greater than number is removed from the results. The default is the largest number that can be represented by a double, which causes no cycles to be removed from the results.","help":"MAXNODEWEIGHT=*number*","type":"value"},{"name":"MAXTIME=","optional":true,"description":"Specifies the maximum amount of time to spend finding cycles. The type of time (either CPU time or real time) is determined by the value of the TIMETYPE= option in the PROC OPTNETWORK statement. The default is the largest number that can be represented by a double.","help":"MAXTIME=*number*","type":"value"},{"name":"MINLENGTH=","optional":true,"description":"Specifies the minimum number of links in a cycle. Any cycle that has fewer links than number is removed from the results. By default, MINLENGTH=1 and no cycles are removed from the results.","help":"MINLENGTH=*number*","type":"value"},{"name":"MINLINKWEIGHT=","optional":true,"description":"Specifies the minimum sum of link weights in a cycle. Any cycle whose sum of link weights is less than number is removed from the results. The default is the largest (in magnitude) negative number that can be represented by a double, which causes no cycles to be removed from the results.","help":"MINLINKWEIGHT=*number*","type":"value"},{"name":"MINNODEWEIGHT=","optional":true,"description":"Specifies the minimum sum of node weights in a cycle. Any cycle whose sum of node weights is less than number is removed from the results. The default is the largest (in magnitude) negative number that can be represented by a double, which causes no cycles to be removed from the results.","help":"MINNODEWEIGHT=*number*","type":"value"},{"name":"OUTCYCLESLINKS=","optional":true,"description":"specifies the output data table to contain the links of the cycles found. CAS-libref.data-table is a two-level name, where CAS-libref refers to the caslib and session identifier, and data-table specifies the name of the output data table.","help":"OUTCYCLESLINKS=*CAS-libref.data-table*","type":"dataSet"},{"name":"OUT=","optional":true,"aliases":["OUTCYCLESNODES="],"description":"Specifies the output data table to contain the cycles found.","help":"OUT=*CAS-libref.data-table*","type":"dataSet"}]},{"name":"DISPLAY","description":"The DISPLAY statement enables you to specify a list of display tables to display or exclude. This statement is similar to the ODS SELECT, ODS EXCLUDE, and ODS TRACE statements. However, the DISPLAY statement can improve performance when a large number of tables could be generated (such as in BY-group processing). The procedure processes the DISPLAY statement on a CAS server and thus sends only a subset of ODS tables to the SAS client. Because ODS statements are processed on a SAS client, first all the generated display tables are sent to the client, and then the client creates a subset. If you use both DISPLAY and ODS statements together, the DISPLAY statement takes precedence over the ODS statements.","help":"DISPLAY &lt;CASESENSITIVE&gt; &lt;EXCLUDE&gt; &lt;EXCLUDEALL&gt; ...","arguments":[{"name":"CASESENSITIVE","optional":true,"followsDelimiter":"/","description":"Performs a case-sensitive comparison of table names in the table-list to display table names when tables are subsetted for display. To preserve case, you must enclose table names in the table-list in quotation marks.","type":"standalone"},{"name":"EXCLUDE","optional":true,"followsDelimiter":"/","description":"Displays all display tables except those specified in the table-list.","type":"standalone"},{"name":"EXCLUDEALL","optional":true,"followsDelimiter":"/","description":"Suppresses display of all tables. This option takes precedence over the other options.","type":"standalone"},{"name":"TRACE","optional":true,"followsDelimiter":"/","description":"Displays the display table names, labels, and paths.","type":"standalone"}]},{"name":"DISPLAYOUT","description":"The DISPLAYOUT statement enables you to create CAS output tables from your displayed output. This statement is similar to the ODS OUTPUT statement. The table-spec-list specifies a list of CAS output tables to create. Each entry in the list has either a key or a key=value format: key=value specifies key as the ODS table name, path, or partial pathname, and specifies value as the CAS output table name. key specifies key as the ODS table name and also as the CAS output table name. Table names and partial pathnames are discussed under the DISPLAY statement. The DISPLAYOUT statement does not support regular expressions.","help":"DISPLAYOUT &lt;INCLUDEALL&gt; &lt;NOREPLACE&gt; &lt;REPEATED&gt; ...","arguments":[{"name":"INCLUDEALL","optional":true,"followsDelimiter":"/","description":"Creates output CAS tables for all display tables. The name of the created output CAS table is the same as the corresponding display table name. If you specify this option, the table-spec-list specification is ignored.","type":"standalone"},{"name":"NOREPLACE","optional":true,"followsDelimiter":"/","description":"Does not replace an existing CAS output table of the same name.","type":"standalone"},{"name":"REPEATED","optional":true,"followsDelimiter":"/","description":"Replicates the CAS output tables on all nodes.","type":"standalone"}]},{"name":"LINEARASSIGNMENT","aliases":["LAP"],"description":"The LINEARASSIGNMENT statement invokes an algorithm that solves the minimal-cost linear assignment problem. In graph terms, this problem is also known as the minimum link-weighted matching problem on a bipartite graph. You define the input data as a directed graph by specifying the LINKS= option in the PROC OPTNETWORK statement, where the costs are defined as link weights. Internally, the graph is treated as a bipartite graph in which the from nodes define one part and the to nodes define the other part.","help":"LINEARASSIGNMENT &lt;OUT=CAS-libref.data-table&gt; ","arguments":[{"name":"MAXTIME=","optional":true,"description":"Specifies the maximum amount of time to spend for linear assignment.","help":"MAXTIME=*number*","type":"value"},{"name":"OUT=","optional":true,"description":"Specifies the output data table to contain the solution to the linear assignment problem.","help":"OUT=*CAS-libref.data-table*","type":"dataSet"}]},{"name":"LINKSVAR","description":"The LINKSVAR statement enables you to explicitly specify the data variable names for PROC OPTNETWORK to use when it reads the data table that you specify in the LINKS= option in the PROC OPTNETWORK statement.","help":"LINKSVAR &lt;AUXWEIGHT=column&gt; &lt;FROM=column&gt; &lt;LOWER=column&gt; ...","arguments":[{"name":"AUXWEIGHT=","optional":true,"description":"Specifies the name of the data variable for the auxiliary link weights. The value of the column variable must be numeric.","help":"AUXWEIGHT=*column*","type":"value"},{"name":"FROM=","optional":true,"description":"Specifies the name of the data variable for the from nodes. The value of the column variable can be numeric or character.","help":"FROM=*column*","type":"value"},{"name":"LOWER=","optional":true,"description":"Specifies the name of the data variable for the link lower bounds. The value of the column variable must be numeric.","help":"LOWER=*column*","type":"value"},{"name":"TO=","optional":true,"description":"Specifies the name of the data variable for the to nodes. The value of the column variable can be numeric or character.","help":"TO=*column*","type":"value"},{"name":"UPPER=","optional":true,"description":"Specifies the name of the data variable for the link upper bounds. The value of the column variable must be numeric.","help":"UPPER=*column*","type":"value"},{"name":"VARS=","optional":true,"description":"Specifies the names of the additional data variables to read.","help":"VARS=(*columns*)","type":"value"},{"name":"VARSOUT=","optional":true,"description":"Specifies the names of the additional data variables to write to the output results.","help":"VARSOUT=(*columns*)","type":"value"},{"name":"WEIGHT=","optional":true,"description":"Specifies the name of the data variable for the link weights. The value of the column variable must be numeric.","help":"WEIGHT=*column*","type":"value"}]},{"name":"LOADGRAPH","description":"The LOADGRAPH statement reads the input graph from tables that are specified by the LINKS= option or the NODES= option (or both) in the PROC OPTNETWORK statement, and it retains the graph in memory (within the current CAS session).","help":"LOADGRAPH ;"},{"name":"MAXFLOW","description":"The MAXFLOW statement invokes an algorithm that solves the maximum network flow problem on an input graph.","help":"MAXFLOW &lt; SINK=t SOURCE=s&gt;;","arguments":[{"name":"SINK=","optional":true,"description":"Specifies the sink node for maximum network flow calculations.","help":"SINK=*t* ","type":"value"},{"name":"SOURCE=","optional":true,"description":"Specifies the source node for maximum network flow calculations.","help":"SOURCE=*s*","type":"value"}]},{"name":"MINCOSTFLOW","aliases":["MCF"],"description":"The MINCOSTFLOW statement invokes an algorithm that solves the minimum-cost network flow problem on an input graph.","help":"MINCOSTFLOW &lt;INTERNALFORMAT=&lt;FULL | THIN&gt;&gt; &lt;LOGFREQ=number | LOGFREQUENCY=number&gt; &lt;MAXTIME=number&gt; ...","arguments":[{"name":"INTERNALFORMAT=","optional":true,"description":"Specifies the internal graph format for the minimum-cost network flow algorithm to use.","help":"INTERNALFORMAT=FULL | THIN","type":"choice","arguments":[{"name":"FULL","description":"Stores the graph in standard (adjacency-list-based) format.","type":"standalone"},{"name":"THIN","description":"Stores the graph in thin (simple list of links) format. This option can improve performance in some cases both by reducing memory and by simplifying the construction of the internal data structures. This option causes PROC OPTNETWORK to skip the removal of duplicate links when it reads in the graph.","type":"standalone"}]},{"name":"LOGFREQUENCY=","optional":true,"aliases":["LOGFREQ="],"description":"Controls the frequency for displaying iteration logs for minimum-cost network flow calculations that use the network simplex algorithm. For graphs that contain one component, this option displays progress every number of simplex iterations; the default is 10,000. For graphs that contain multiple components, when you also specify LOGLEVEL=MODERATE, this option displays progress after processing every number of components; the default is based on the number of components. When you also specify LOGLEVEL=AGGRESSIVE, the simplex iteration log for each component is displayed with a frequency of number.","help":"LOGFREQUENCY=*number*","type":"value"},{"name":"MAXTIME=","optional":true,"description":"Specifies the maximum amount of time to spend calculating minimum-cost network flows. The type of time (either CPU time or real time) is determined by the value of the TIMETYPE= option in the PROC OPTNETWORK statement. The default is the largest number that can be represented by a double.","help":"MAXTIME=*number*","type":"value"}]},{"name":"MINCUT","description":"The MINCUT statement invokes an algorithm that finds the minimum link-weighted cut of an input graph.","help":"MINCUT &lt;MAXCUTS=number&gt; &lt;MAXWEIGHT=number&gt; &lt;OUTCUTSETS=CAS-libref.data-table | OUT=CAS-libref.data-table&gt; ...","arguments":[{"name":"MAXCUTS=","optional":true,"description":"Specifies the maximum number of cuts for the algorithm to return. The minimal cut and any others that it finds during the search, up to number, are returned. By default, MAXCUTS=1.","help":"MAXCUTS=*number*","type":"value"},{"name":"MAXWEIGHT=","optional":true,"description":"Specifies the maximum weight of the cuts for the algorithm to return. Only cuts whose weight is less than or equal to number are returned. The default is the largest number that can be represented by a double.","help":"MAXWEIGHT=*number*","type":"value"},{"name":"OUTCUTSETS=","optional":true,"aliases":["OUT="],"description":"Specifies the output data table to contain the minimum cut sets to the minimum-cut problem.","type":"value"},{"name":"OUTPARTITIONS=","optional":true,"description":"Specifies the output data table to contain the minimum cut partitions to the minimum-cut problem.","help":"OUTPARTITIONS=*CAS-libref.data-table*","type":"dataSet"},{"name":"SINK=","optional":true,"description":"Specifies the sink node for minimum cut calculations. If this option is specified, the SOURCE= option must also be specified.","help":"SINK=*t*","type":"value"},{"name":"SOURCE=","optional":true,"description":"Specifies the source node for minimum cut calculations. If this option is specified, the SINK= option must also be specified.","help":"SOURCE=*s*","type":"value"}]},{"name":"MINSPANTREE","aliases":["MST"],"description":"The MINSPANTREE statement invokes an algorithm that solves the minimum link-weighted spanning tree problem on an input graph.","help":"MINSPANTREE &lt;INTERNALFORMAT=&lt;FULL | THIN&gt;&gt; &lt;OUT=CAS-libref.data-table&gt; ","arguments":[{"name":"INTERNALFORMAT=","optional":true,"description":"Specifies the internal graph format for the minimum spanning tree algorithm to use.","help":"INTERNALFORMAT=FULL | THIN","type":"choice","arguments":[{"name":"FULL","description":"Stores the graph in standard (adjacency-list-based) format.","type":"standalone"},{"name":"THIN","description":"Stores the graph in thin (simple list of links) format. This option can improve performance in some cases both by reducing memory and by simplifying the construction of the internal data structures. This option causes PROC OPTNETWORK to skip the removal of duplicate links when it reads in the graph.","type":"standalone"}]},{"name":"OUT=","optional":true,"description":"Specifies the output data table to contain the solution to the minimum link-weighted spanning tree problem.","help":"OUT=*CAS-libref.data-table*","type":"dataSet"}]},{"name":"NODESSUBSETVAR","description":"The NODESSUBSETVAR statement enables you to explicitly specify the data variable names for PROC OPTNETWORK to use when it reads the data table that you specify in the NODESSUBSET= option in the PROC OPTNETWORK statement.","help":"NODESSUBSETVAR &lt;NODE=column&gt; &lt;SINK=column&gt; &lt;SOURCE=column&gt; ...","arguments":[{"name":"NODE=","optional":true,"description":"Specifies the name of the data variable for the nodes. The value of the column variable can be numeric or character.","help":"NODE=*column*","type":"value"},{"name":"SINK=","optional":true,"description":"Specifies the name of the data variable for the sink indicator. The value of the column variable must be numeric.","help":"SINK=*column*","type":"value"},{"name":"SOURCE=","optional":true,"description":"Specifies the name of the data variable for the source indicator. The value of the column variable must be numeric.","help":"SOURCE=*column*","type":"value"}]},{"name":"NODESVAR","description":"The NODESVAR statement enables you to explicitly specify the data variable names for PROC OPTNETWORK to use when it reads the data table that you specify in the NODES= option in the PROC OPTNETWORK statement.","help":"NODESVAR &lt;LOWER=column&gt; &lt;NODE=column&gt; &lt;UPPER=column&gt; ...","arguments":[{"name":"LOWER=","optional":true,"description":"Specifies the name of the data variable for the node lower bounds. The value of the column variable must be numeric.","help":"LOWER=*column*","type":"value"},{"name":"NODE=","optional":true,"description":"Specifies the name of the data variable for the nodes. The value of the column variable can be numeric or character.","help":"NODE=*column*","type":"value"},{"name":"UPPER=","optional":true,"description":"Specifies the name of the data variable for the node upper bounds. The value of the column variable must be numeric.","help":"UPPER=*column*","type":"value"},{"name":"VARS=","optional":true,"description":"Specifies the names of the additional data variables to read. The value of the variables can be numeric or character.","help":"VARS=(*columns*)","type":"value"},{"name":"VARSOUT=","optional":true,"description":"Specifies the names of the additional data variables to write to the output results. The value of the variables can be numeric or character.","help":"VARSOUT=(*columns*)","type":"value"},{"name":"WEIGHT=","optional":true,"description":"Specifies the name of the data variable for the node weights. The value of the column variable must be numeric.","help":"WEIGHT=*column*","type":"value"}]},{"name":"PATH","description":"The PATH statement invokes an algorithm that finds the paths in the input graph.","help":"PATH &lt;INTERNALFORMAT=&lt;FULL | THIN&gt;&gt; &lt;MAXLENGTH=number&gt; &lt;MAXLINKWEIGHT=number&gt; ...","arguments":[{"name":"INTERNALFORMAT=","optional":true,"description":"Specifies the internal graph format for the path enumeration algorithm to use.","help":"INTERNALFORMAT=FULL | THIN","type":"choice","arguments":[{"name":"FULL","description":"Stores the graph in standard (adjacency-list-based) format.","type":"standalone"},{"name":"THIN","description":"Stores the graph in thin (simple list of links) format. This option can improve performance in some cases both by reducing memory and by simplifying the construction of the internal data structures. This option causes PROC OPTNETWORK to skip the removal of duplicate links when it reads in the graph.","type":"standalone"}]},{"name":"MAXLENGTH=","optional":true,"description":"Specifies the maximum number of links in a path. Any path whose length is greater than number is removed from the results. The default is the largest number that can be represented by a 32-bit integer, which causes no paths to be removed from the results.","help":"MAXLENGTH=*number*","type":"value"},{"name":"MAXLINKWEIGHT=","optional":true,"description":"Specifies the maximum sum of link weights in a path. Any path whose sum of link weights is greater than number is removed from the results. The default is the largest number that can be represented by a double, which causes no paths to be removed from the results.","help":"MAXLINKWEIGHT=*number*","type":"value"},{"name":"MAXNODEWEIGHT=","optional":true,"description":"Specifies the maximum sum of node weights in a path. Any path whose sum of node weights is greater than number is removed from the results. The default is the largest number that can be represented by a double, which causes no paths to be removed from the results.","help":"MAXNODEWEIGHT=*number*","type":"value"},{"name":"MAXTIME","optional":true,"description":"Specifies the maximum amount of time to spend finding paths. The type of time (either CPU time or real time) is determined by the value of the TIMETYPE= option in the PROC OPTNETWORK statement. The default is the largest number that can be represented by a double.","type":"standalone"},{"name":"MINLENGTH=","optional":true,"description":"Specifies the minimum number of links in a path. Any path that has fewer links than number is removed from the results. By default, MINLENGTH=1 and no paths are removed from the results.","help":"MINLENGTH=*number*","type":"value"},{"name":"MINLINKWEIGHT=","optional":true,"description":"Specifies the minimum sum of link weights in a path. Any path whose sum of link weights is less than number is removed from the results. The default is the largest (in magnitude) negative number that can be represented by a double, which causes no paths to be removed from the results.","help":"MINLINKWEIGHT=*number*","type":"value"},{"name":"MINNODEWEIGHT=","optional":true,"description":"Specifies the minimum sum of node weights in a path. Any path whose sum of node weights is less than number is removed from the results. The default is the largest (in magnitude) negative number that can be represented by a double, which causes no paths to be removed from the results.","help":"MINNODEWEIGHT=*number*","type":"value"},{"name":"OUTPATHSLINKS=","optional":true,"aliases":["OUTPATHS="],"description":"Specifies the output data table to contain the path links. CAS-libref.data-table is a two-level name, where CAS-libref refers to the caslib and session identifier, and data-table specifies the name of the output data table.","type":"value"},{"name":"OUTPATHSNODES=","optional":true,"description":"Specifies the output data table to contain the path nodes.","help":"OUTPATHSNODES=*CAS-libref.data-table*","type":"dataSet"},{"name":"SINK=","optional":true,"description":"Specifies the sink node for path calculations. This setting overrides the use of the variable sink in the data table that you specify in the NODESSUBSET= option in the PROC OPTNETWORK statement.","help":"SINK=*sink-node*","type":"value"},{"name":"SOURCE=","optional":true,"description":"Specifies the source node for path calculations. This setting overrides the use of the variable source in the data table that you specify in the NODESSUBSET= option in the PROC OPTNETWORK statement.","help":"SOURCE=*source-node*","type":"value"}]},{"name":"SHORTESTPATH","description":"The SHORTESTPATH statement invokes an algorithm that calculates shortest paths between pairs of nodes in the input graph. By default, PROC OPTNETWORK finds a shortest path for each possible combination of source and sink nodes.","help":"SHORTESTPATH &lt;MAXPATHWEIGHT=number&gt; &lt;OUTPATHS=CAS-libref.data-table | OUT=CAS-libref.data-table&gt; &lt;OUTWEIGHTS=CAS-libref.data-table&gt; ...","arguments":[{"name":"MAXABSOLUTEOBJECTIVEGAP=","optional":true,"aliases":["MAXABSOBJGAP="],"description":"Specifies an acceptance criterion for the sum of link weights (CandidatePath) in paths relative to the sum of link weights in the shortest path (ShortestPath).","help":"MAXABSOLUTEOBJECTIVEGAP=*number*","type":"value"},{"name":"MAXPATHSPERPAIR=","optional":true,"description":"sSpecifies the maximum number of ranked paths to find for each source-sink pair.","help":"MAXPATHSPERPAIR=*number*","type":"value"},{"name":"MAXPATHWEIGHT=","optional":true,"aliases":["MAXLINKWEIGHT="],"description":"Specifies the maximum path weight. Any shortest path whose sum of link weights is greater than number is removed from the results. The default is the largest number that can be represented by a double, which causes no paths to be removed from the results.","help":"MAXPATHWEIGHT=*number*","type":"value"},{"name":"MAXRELATIVEOBJECTIVEGAP=","optional":true,"aliases":["MAXRELOBJGAP="],"description":"specifies an acceptance criterion for the sum of link weights (CandidatePath) in paths relative to the sum of link weights in the shortest path (ShortestPath).","help":"MAXRELATIVEOBJECTIVEGAP=number","type":"value"},{"name":"MINPATHWEIGHT=","optional":true,"aliases":["MINLINKWEIGHT="],"description":"Specifies the minimum sum of link weights in a path. Any shortest path whose sum of link weights is less than number is removed from the results.","help":"MINPATHWEIGHT=number","type":"value"},{"name":"OUTPATHS=","optional":true,"aliases":["OUT=","OUTPATHSLINKS="],"description":"Specifies the output data table to contain the shortest paths.","help":"OUTPATHS=*CAS-libref.data-table*","type":"dataSet"},{"name":"OUTPATHSNODES=","optional":true,"description":"Specifies the output data table to contain the shortest path nodes. CAS-libref.data-table is a two-level name, where CAS-libref refers to the caslib and session identifier, and data-table specifies the name of the output data table.","help":"OUTPATHSNODES=*CAS-libref.data-table*","type":"dataSet"},{"name":"OUTSUMMARY=","optional":true,"description":"Specifies the output data table to contain descriptive statistics of the finite shortest paths for each source. CAS-libref.data-table is a two-level name, where CAS-libref refers to the caslib and session identifier, and data-table specifies the name of the output data table.","help":"OUTSUMMARY=*CAS-libref.data-table*","type":"dataSet"},{"name":"OUTWEIGHTS=","optional":true,"description":"Specifies the output data table to contain the shortest path summaries.","help":"OUTWEIGHTS=*CAS-libref.data-table*","type":"dataSet"},{"name":"SEQUENCE=","optional":true,"description":"Specifies which data variable in the nodes subset table defines the sequence of nodes to visit. The variable data type must be numeric. The values must define an ordering from lowest (visit first) to highest (visit last). The resulting path contains a node subsequence that matches the specified node sequence. You cannot use this SEQUENCE= option in combination with the SOURCE= or SINK= option in the SHORTESTPATH statement. In addition, the nodes subset table cannot contain a source or sink variable. To specify the source and sink nodes for the path, include them as the first and last nodes, respectively, in the sequence of nodes that you specify with the SEQUENCE= option.","help":"SEQUENCE=*column*","type":"value"},{"name":"SINK=","optional":true,"description":"Specifies the sink node for shortest path calculations. This setting overrides the use of the variable sink in the data table that you specify in the NODESSUBSET= option in the PROC OPTNETWORK statement.","help":"SINK=*sink-node*","type":"value"},{"name":"SOURCE=","optional":true,"description":"Specifies the source node for shortest path calculations. This setting overrides the use of the variable source in the data table that you specify in the NODESSUBSET= option in the PROC OPTNETWORK statement.","help":"SOURCE=*source-node*","type":"value"}]},{"name":"SUMMARY","description":"The SUMMARY statement invokes an algorithm that calculates various summary metrics for an input graph.","help":"SUMMARY &lt;BICONNECTEDCOMPONENTS&gt; &lt;CONNECTEDCOMPONENTS&gt; &lt;DIAMETERAPPROX=&lt;WEIGHT | UNWEIGHT | BOTH&gt;&gt; ...","arguments":[{"name":"BICONNECTEDCOMPONENTS","optional":true,"description":"Calculates information about biconnected components. You can use this option only for an undirected graph.","type":"standalone"},{"name":"CLUSTERINGCOEFFICIENT","optional":true,"aliases":["CLUSTERINGCOEF"],"description":"Calculates information about clustering coefficients. You can use this option only for an undirected graph.","type":"standalone"},{"name":"CONNECTEDCOMPONENTS","optional":true,"description":"Calculates information about connected components.","type":"standalone"},{"name":"DIAMETERAPPROX=","optional":true,"description":"Calculates information about the approximate diameter and specifies which type of calculation to perform. Use this option when calculating the exact diameter (by calculating all shortest paths) is too computationally expensive.","help":"DIAMETERAPPROX=WEIGHT | UNWEIGHT | BOTH","type":"choice","arguments":[{"name":"WEIGHT","description":"Calculates the approximate diameter by using the weighted graph.","type":"standalone"},{"name":"UNWEIGHT","description":"Calculates the approximate diameter by using the unweighted graph.","type":"standalone"},{"name":"BOTH","description":"Calculates the approximate diameter by using both the weighted and unweighted graphs.","type":"standalone"}]},{"name":"FINITEPATH","optional":true,"description":"Includes only finite values when calculating descriptive statistics that are related to shortest paths (eccentricity, diameter, and so on).","type":"standalone"},{"name":"OUT=","optional":true,"description":"Specifies the output data table to contain the summary results.","help":"OUT=*CAS-libref.data-table*","type":"dataSet"},{"name":"SHORTESTPATH=","optional":true,"description":"Calculates information about shortest paths and specifies which type of calculation to perform.","help":"SHORTESTPATH=WEIGHT | UNWEIGHT | BOTH","type":"choice","arguments":[{"name":"WEIGHT","description":"Calculates shortest paths by using the weighted graph.","type":"standalone"},{"name":"UNWEIGHT","description":"Calculates shortest paths by using the unweighted graph.","type":"standalone"},{"name":"BOTH","description":"Calculates shortest paths by using both the weighted and unweighted graphs.","type":"standalone"}]}]},{"name":"TOPOLOGICALSORT","aliases":["TOPSORT"],"description":"The TOPOLOGICALSORT statement calculates a topological ordering of the nodes of a directed acyclic input graph.","help":"TOPOLOGICALSORT ;"},{"name":"TRANSITIVECLOSURE","description":"The TRANSITIVECLOSURE statement invokes an algorithm that calculates the transitive closure of an input graph.","help":"TRANSITIVECLOSURE &lt;OUT=CAS-libref.data-table&gt; ","arguments":[{"name":"OUT=","optional":true,"description":"Specifies the output data table to contain the transitive closure results.","help":"OUT=*CAS-libref.data-table*","type":"dataSet"}]},{"name":"TSP","description":"The TSP statement invokes an algorithm that solves the traveling salesman problem, which is described in the section Traveling Salesman Problem. The algorithm that is used to solve this problem is built around the same method that is used in PROC OPTMILP: a branch-and-cut algorithm.","help":"TSP &lt;ABSOBJGAP=number | ABSOLUTEOBJECTIVEGAP=number&gt; &lt;CUTOFF=number&gt; &lt;CUTSTRATEGY=&lt;AUTOMATIC | NONE | MODERATE&gt;... &gt; ...","arguments":[{"name":"ABSOBJGAP=","optional":true,"aliases":["ABSOLUTEOBJECTIVEGAP="],"description":"Specifies a stopping criterion. When the absolute difference between the best integer objective and the objective of the best remaining branch-and-bound node becomes less than the value of number, the solver stops. The value of number can be any nonnegative number; the default value is 1E–6.","type":"value"},{"name":"CUTOFF=","optional":true,"description":"Cuts off any branch-and-bound nodes in a minimization problem that has an objective value greater than number. The default is the largest number that can be represented by a double.","help":"CUTOFF=*number*","type":"value"},{"name":"CUTSTRATEGY=","optional":true,"description":"Specifies the level of mixed integer linear programming cutting planes to be generated by PROC OPTNETWORK. TSP-specific cutting planes are always generated.","help":"CUTSTRATEGY=AUTOMATIC | NONE | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"AUTOMATIC","description":"Generate cutting planes based on a strategy determined by the mixed integer linear programming solver.","type":"standalone"},{"name":"NONE","description":"Disables the generation of mixed integer linear programming cutting planes (some TSP-specific cutting planes are still active for validity).","type":"standalone"},{"name":"MODERATE","description":"Uses a moderate cutting strategy.","type":"standalone"},{"name":"AGGRESSIVE","description":"Uses an aggressive cutting strategy.","type":"standalone"}]},{"name":"HEURISTICS=","optional":true,"description":"controls the level of initial and primal heuristics that PROC OPTNETWORK applies. This level determines how frequently PROC OPTNETWORK applies primal heuristics during the branch-and-bound tree search. It also affects the maximum number of iterations that are allowed in iterative heuristics. Some computationally expensive heuristics might be disabled by the solver at less aggressive levels.","help":"HEURISTICS=AUTOMATIC | NONE | BASIC | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"AUTOMATIC","description":"Applies the default level of heuristics.","type":"standalone"},{"name":"NONE","description":"Disables all initial and primal heuristics.","type":"standalone"},{"name":"BASIC","description":"Applies basic initial and primal heuristics at low frequency.","type":"standalone"},{"name":"MODERATE","description":"Applies most initial and primal heuristics at moderate frequency.","type":"standalone"},{"name":"AGGRESSIVE","description":"Applies all initial primal heuristics at high frequency.","type":"standalone"}]},{"name":"LOGFREQUENCY=","optional":true,"aliases":["LOGFREQ="],"description":"Specifies the time interval (in seconds) for printing information in the node log. The default value is 5. If number is set to 0, then the node log is disabled. If number is positive, then the root node processing information is printed and, if possible, an entry is made every number seconds. An entry is also made each time a better integer solution is found.","help":"LOGFREQUENCY=*number*","type":"value"},{"name":"MAXNODES=","optional":true,"description":"Specifies the maximum number of branch-and-bound nodes to be processed. The default is the largest number that can be represented by a 32-bit integer.","help":"MAXNODES=*number*","type":"value"},{"name":"MAXSOLS=","optional":true,"description":"Specifies a stopping criterion. If the number of solutions has been found, then the procedure stops. The default is the largest number that can be represented by a 32-bit integer.","help":"MAXSOLS=*number*","type":"value"},{"name":"MAXTIME=","optional":true,"description":"Specifies the maximum amount of time to spend solving the traveling salesman problem. The type of time (either CPU time or real time) is determined by the value of the TIMETYPE= option in the PROC OPTNETWORK statement. The default is the largest number that can be represented by a double.","help":"MAXTIME=*number*","type":"value"},{"name":"MILP=","optional":true,"description":"Specifies whether to use a mixed integer linear programming (MILP) solver to solve the traveling salesman problem. The MILP solver attempts to find the overall best TSP tour by using a branch-and-bound-based algorithm. This algorithm can be expensive for large-scale problems. If MILP=FALSE, then PROC OPTNETWORK uses its initial heuristics to find a feasible, but not necessarily optimal, tour as quickly as possible.","help":"MILP=TRUE | FALSE","type":"choice","arguments":[{"name":"TRUE","description":"Uses a mixed-integer linear programming","type":"standalone"},{"name":"FALSE","description":"Does not use a mixed-integer linear programming solver","type":"standalone"}]},{"name":"OUT=","optional":true,"description":"Specifies the output data table to contain the solution to the traveling salesman problem.","help":"OUT=*CAS-libref.data-table*","type":"dataSet"},{"name":"RELOBJGAP=","optional":true,"aliases":["RELATIVEOBJECTIVEGAP="],"description":"Specifies a stopping criterion that is based on the best integer objective (BestInteger) and the objective of the best remaining node (BestBound).","type":"value"},{"name":"TARGET=","optional":true,"description":"Specifies a stopping criterion for minimization problems. If the best integer objective is less than or equal to number, the solver stops. The default is the largest (in magnitude) negative number that can be represented by a double.","help":"TARGET=*number*","type":"value"}]},{"name":"UNLOADGRAPH","description":"The UNLOADGRAPH statement deletes the in-memory graph that is specified in the GRAPH= option in the PROC OPTNETWORK statement.","help":"UNLOADGRAPH ;"},{"name":"VRP","description":"The VRP statement invokes an algorithm that solves the vehicle routing problem. The algorithm that is used to solve this problem is built around the same method that the OPTMILP procedure uses: a branch-and-cut algorithm.","help":"VRP &lt;ABSOBJGAP=number | ABSOLUTEOBJECTIVEGAP=number&gt; &lt;CAPACITY=*number*&gt;&lt;CUTOFF=number&gt; &lt;CUTSTRATEGY=&lt;AUTOMATIC | NONE | MODERATE&gt;... &gt; ...","arguments":[{"name":"ABSOBJGAP=","optional":true,"aliases":["ABSOLUTEOBJECTIVEGAP="],"description":"Specifies a stopping criterion. When the absolute difference between the best integer objective and the objective of the best remaining branch-and-bound node becomes less than the value of number, the solver stops. The value of number can be any nonnegative number; the default value is 1E–6.","help":"ABSOBJGAP=*number*","type":"value"},{"name":"CAPACITY=","optional":true,"description":"specifies the capacity of each vehicle. The capacity is the maximum amount of goods that a vehicle can pick up from the depot to be delivered to customers. The value of number can be any nonnegative number. The default is the largest number that can be represented by a double.","help":"CAPACITY=*number*","type":"value"},{"name":"CUTOFF=","optional":true,"description":"cuts off any branch-and-bound nodes in a minimization problem that have an objective value at or above number. The default is the largest number that can be represented by a double.","help":"CUTOFF=*number*","type":"value"},{"name":"CUTSTRATEGY=","optional":true,"description":"specifies the level of mixed integer linear programming cutting planes to be generated. VRP-specific cutting planes are always generated. By default, CUTSTRATEGY=NONE.","help":"CUTSTRATEGY=AUTOMATIC | NONE | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"AUTOMATIC","description":"Generate cutting planes based on a strategy determined by the mixed integer linear programming solver.","type":"standalone"},{"name":"NONE","description":"Disables the generation of mixed integer linear programming cutting planes (some VRP-specific cutting planes are still active for validity).","type":"standalone"},{"name":"MODERATE","description":"Uses a moderate cutting strategy.","type":"standalone"},{"name":"AGGRESSIVE","description":"Uses an aggressive cutting strategy.","type":"standalone"}]},{"name":"DEPOT=","optional":true,"description":"specifies the depot node for the vehicle routing problem. The centralized depot is the source of goods to be delivered to customers (nodes). This option is required, because the depot must be specified.","help":"DEPOT=*depot-node*","type":"value"},{"name":"HEURISTICS=","optional":true,"description":"Determines how frequently to apply primal heuristics during the branch-and-bound tree search, and affects the maximum number of iterations that are allowed in iterative heuristics. Some computationally expensive heuristics might be disabled by the solver at less aggressive levels. By default, HEURISTICS=AUTOMATIC.","help":"HEURISTICS=AUTOMATIC | NONE | BASIC | MODERATE | AGGRESSIVE","type":"choice","arguments":[{"name":"AUTOMATIC","description":"Applies the default level of heuristics.","type":"standalone"},{"name":"NONE","description":"Disables all primal heuristics.","type":"standalone"},{"name":"BASIC","description":"Applies basic primal heuristics at low frequency.","type":"standalone"},{"name":"MODERATE","description":"Applies most primal heuristics at moderate frequency.","type":"standalone"},{"name":"AGGRESSIVE","description":"Applies all primal heuristics at high frequency.","type":"standalone"}]},{"name":"LOGFREQUENCY=","optional":true,"aliases":["LOGFREQ="],"description":"Specifies the time interval (in seconds) for printing information in the node log, where number can be any integer greater than or equal to 0. If number is 0, then the node log is disabled. If number is positive, then the root node processing information is printed and, if possible, an entry is made every number seconds. An entry is also made each time a better integer solution is found. By default, LOGFREQ=5.","help":"LOGFREQUENCY=*number*","type":"value"},{"name":"MAXNODES=","optional":true,"description":"Specifies the maximum number of branch-and-bound nodes to be processed. The default is the largest number that can be represented by a 32-bit integer.","help":"MAXNODES=*number*","type":"value"},{"name":"MAXROUTES=","optional":true,"description":"Specifies the maximum number of routes allowed to service demand. The value of number must be an integer greater than or equal to 1. The default is the largest number that can be represented by a 32-bit integer.","help":"MAXROUTES=number","type":"value"},{"name":"MAXSOLS=","optional":true,"description":"Specifies a stopping criterion. When the number of solutions are found, the procedure stops. The default is the largest number that can be represented by a 32-bit integer.","help":"MAXSOLS=*number*","type":"value"},{"name":"MAXTIME=","optional":true,"description":"Specifies the maximum amount of time to spend solving the vehicle routing problem. The type of time (either CPU time or real time) is determined by the value of the TIMETYPE= option in the PROC OPTNETWORK statement. The default is the largest number that can be represented by a double.","help":"MAXTIME=*number*","type":"value"},{"name":"MILP=","optional":true,"description":"Specifies whether to use a mixed integer linear programming (MILP) solver to solve the vehicle routing problem (VRP). The MILP solver attempts to find the overall best VRP solution by using a branch-and-cut algorithm. This algorithm can be expensive for large-scale problems. If MILP=FALSE, then PROC OPTNETWORK uses its initial heuristics to find a feasible, but not necessarily optimal, solution as quickly as possible.","help":"MILP=TRUE | FALSE","type":"choice","arguments":[{"name":"TRUE","description":"Uses a mixed-integer linear programming","type":"standalone"},{"name":"FALSE","description":"Does not use a mixed-integer linear programming solver","type":"standalone"}]},{"name":"MINROUTES=","optional":true,"description":"Specifies the minimum number of routes allowed to service demand. The value of number must be an integer greater than or equal to 1. By default, MINROUTES=1.","help":"MINROUTES=number","type":"value"},{"name":"OUT=","optional":true,"description":"Specifies the output data table to contain the solution to the traveling salesman problem.","help":"OUT=*CAS-libref.data-table*","type":"dataSet"},{"name":"RELOBJGAP=","optional":true,"aliases":["RELATIVEOBJECTIVEGAP="],"description":"Specifies a stopping criterion that is based on the best integer objective (BestInteger) and the objective of the best remaining node (BestBound).","type":"value"},{"name":"TARGET=","optional":true,"description":"Specifies a stopping criterion for minimization problems. If the best integer objective is less than or equal to number, the solver stops. The default is the largest (in magnitude) negative number that can be represented by a double.","help":"TARGET=*number*","type":"value"}]}],"supportSiteInformation":{"docsetId":"casnopt","docsetVersion":"v_011","docsetTargetFile":"casnopt_optnet_toc.htm"}}